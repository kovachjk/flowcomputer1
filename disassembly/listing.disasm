Disassembly Listing for FCX_MB0
Generated From:
C:/MC_XProjects/FCX_MB0/dist/default/debug/FCX_MB0.debug.elf
Jan 27, 2013 4:50:36 PM

---  C:/MC_XProjects/Microhip/Graphics/Primitive.c  -----------------------------------------------------
1:                   /*****************************************************************************
2:                    *  Module for Microchip Graphics Library
3:                    *  Graphic Primitives Layer
4:                    *****************************************************************************
5:                    * FileName:        Primitive.c
6:                    * Dependencies:    Graphics.h
7:                    * Processor:       PIC24F, PIC24H, dsPIC, PIC32
8:                    * Compiler:       	MPLAB C30 V3.00, MPLAB C32
9:                    * Linker:          MPLAB LINK30, MPLAB LINK32
10:                   * Company:         Microchip Technology Incorporated
11:                   *
12:                   * Software License Agreement
13:                   *
14:                   * Copyright © 2008 Microchip Technology Inc.  All rights reserved.
15:                   * Microchip licenses to you the right to use, modify, copy and distribute
16:                   * Software only when embedded on a Microchip microcontroller or digital
17:                   * signal controller, which is integrated into your product or third party
18:                   * product (pursuant to the sublicense terms in the accompanying license
19:                   * agreement).  
20:                   *
21:                   * You should refer to the license agreement accompanying this Software
22:                   * for additional information regarding your rights and obligations.
23:                   *
24:                   * SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY
25:                   * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
26:                   * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
27:                   * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
28:                   * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
29:                   * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
30:                   * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
31:                   * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
32:                   * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
33:                   * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
34:                   * OR OTHER SIMILAR COSTS.
35:                   *
36:                   * Author               Date        Comment
37:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
38:                   * Anton Alkhimenok and
39:                   * Paolo A. Tomayo      11/12/07    Version 1.0 release
40:                   *****************************************************************************/
41:                  #include "../Include/Graphics/Graphics.h"
42:                  
43:                  #define USE_PRIMITIVE_BEVEL
44:                  
45:                  /////////////////////// LOCAL FUNCTIONS PROTOTYPES ////////////////////////////
46:                  void    PutImage1BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch);
47:                  void    PutImage4BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch);
48:                  void    PutImage8BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch);
49:                  void    PutImage16BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch);
50:                  
51:                  void    PutImage1BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch);
52:                  void    PutImage4BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch);
53:                  void    PutImage8BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch);
54:                  void    PutImage16BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch);
55:                  
56:                  // Current line type
57:                  SHORT   _lineType;
58:                  
59:                  // Current line thickness
60:                  BYTE    _lineThickness;
61:                  
62:                  // Font orientation
63:                  BYTE    _fontOrientation;
64:                  
65:                  // Current cursor x-coordinates
66:                  SHORT   _cursorX;
67:                  
68:                  // Current cursor y-coordinates
69:                  SHORT   _cursorY;
70:                  
71:                  // Pointer to the current font
72:                  void    *_font;
73:                  
74:                  #ifdef USE_PALETTE
75:                  void    *_palette;
76:                  #endif
77:                  
78:                  // First and last characters in the font
79:                  WORD    _fontFirstChar; // First character in the font table.
80:                  WORD    _fontLastChar;  // Last character in the font table.
81:                  
82:                  // Installed font height
83:                  SHORT   _fontHeight;
84:                  
85:                  /*********************************************************************
86:                  * Function:  void InitGraph(void)
87:                  *
88:                  * PreCondition: none
89:                  *
90:                  * Input: none
91:                  *
92:                  * Output: none
93:                  *
94:                  * Side Effects: none
95:                  *
96:                  * Overview: initializes LCD controller,
97:                  *           sets cursor position to upper left corner,
98:                  *           sets active and visual pages to page 0,
99:                  *           clears active page with BLACK,
100:                 *           sets color to WHITE,
101:                 *           disables clipping
102:                 *
103:                 * Note: none
104:                 *
105:                 ********************************************************************/
106:                 void InitGraph(void)
107:                 {
9D000070  27BDFFE8   ADDIU SP, SP, -24
9D000074  AFBF0014   SW RA, 20(SP)
9D000078  AFBE0010   SW S8, 16(SP)
9D00007C  03A0F021   ADDU S8, SP, ZERO
108:                 
109:                     // Current line type
110:                     SetLineType(SOLID_LINE);
9D000080  A78081A2   SH ZERO, -32350(GP)
111:                 
112:                     // Current line thickness
113:                     SetLineThickness(NORMAL_LINE);
9D000084  A38081AA   SB ZERO, -32342(GP)
114:                 
115:                     // Current cursor coordinates to 0,0
116:                     MoveTo(0, 0);
9D000088  A78081B0   SH ZERO, -32336(GP)
9D00008C  A78081A6   SH ZERO, -32346(GP)
117:                 
118:                     // Reset device
119:                     ResetDevice();
9D000090  0F4009E8   JAL ResetDevice
9D000094  00000000   NOP
120:                 
121:                     // Set active and visual pages
122:                     SetActivePage(0);
123:                     SetVisualPage(0);
124:                 
125:                     // Set color to BLACK
126:                     SetColor(BLACK);
9D000098  A7808198   SH ZERO, -32360(GP)
127:                 
128:                     // Clear screen
129:                     ClearDevice();
9D00009C  0F400CE5   JAL ClearDevice
9D0000A0  00000000   NOP
130:                 
131:                     // Set color to WHITE
132:                     SetColor(WHITE);
9D0000A4  2402FFFF   ADDIU V0, ZERO, -1
9D0000A8  A7828198   SH V0, -32360(GP)
133:                 
134:                     // Disable clipping
135:                     SetClip(CLIP_DISABLE);
9D0000AC  A780819C   SH ZERO, -32356(GP)
136:                 
137:                     // Set font orientation
138:                     SetFontOrientation(ORIENT_HOR);
9D0000B0  A38081B2   SB ZERO, -32334(GP)
139:                 }
9D0000B4  03C0E821   ADDU SP, S8, ZERO
9D0000B8  8FBF0014   LW RA, 20(SP)
9D0000BC  8FBE0010   LW S8, 16(SP)
9D0000C0  27BD0018   ADDIU SP, SP, 24
9D0000C4  03E00008   JR RA
9D0000C8  00000000   NOP
140:                 
141:                 /*********************************************************************
142:                 * Function: WORD Arc(SHORT xL, SHORT yT, SHORT xR, SHORT yB, SHORT r1, SHORT r2, BYTE octant);
143:                 *
144:                 * PreCondition: none
145:                 *
146:                 * Input: xL, yT - location of the upper left center in the x,y coordinate
147:                 *		 xR, yB - location of the lower right left center in the x,y coordinate
148:                 *		 r1, r2 - the two concentric circle radii, r1 as the radius 
149:                 *				  of the smaller circle and and r2 as the radius of the 
150:                 *				  larger circle.
151:                 *		 octant - bitmask of the octant that will be drawn.
152:                 *				  Moving in a clockwise direction from x = 0, y = +radius
153:                 *                 bit0 : first octant 	bit4 : fifth octant
154:                 *                 bit1 : second octant  bit5 : sixth octant
155:                 *                 bit2 : third octant   bit6 : seventh octant
156:                 *                 bit3 : fourth octant  bit7 : eigth octant
157:                 *
158:                 * Output: For NON-Blocking configuration:
159:                 *         - Returns 0 when device is busy and the shape is not yet completely drawn.
160:                 *         - Returns 1 when the shape is completely drawn.
161:                 *         For Blocking configuration:
162:                 *         - Always return 1.
163:                 *
164:                 * Side Effects: none
165:                 *
166:                 * Overview: Draws the octant arc of a beveled figure with given centers, radii
167:                 *			and octant mask. When r1 is zero and r2 has some value, a filled 
168:                 *			circle is drawn; when the radii have values, an arc of
169:                 *			thickness (r2-r1) is drawn; when octant = 0xFF, a full ring 
170:                 *			is drawn. When r1 and r2 are zero, a rectangular object is drawn, where
171:                 *			xL, yT specifies the left top corner; xR, yB specifies the right bottom
172:                 *			corner.
173:                 *
174:                 * Note: none
175:                 *
176:                 ********************************************************************/
177:                 WORD Arc(SHORT xL, SHORT yT, SHORT xR, SHORT yB, SHORT r1, SHORT r2, BYTE octant)
178:                 {
9D0000CC  27BDFFB8   ADDIU SP, SP, -72
9D0000D0  AFBF0044   SW RA, 68(SP)
9D0000D4  AFBE0040   SW S8, 64(SP)
9D0000D8  03A0F021   ADDU S8, SP, ZERO
9D0000DC  00804821   ADDU T1, A0, ZERO
9D0000E0  00A04021   ADDU T0, A1, ZERO
9D0000E4  00E02821   ADDU A1, A3, ZERO
9D0000E8  8FC40058   LW A0, 88(S8)
9D0000EC  8FC3005C   LW V1, 92(S8)
9D0000F0  8FC20060   LW V0, 96(S8)
9D0000F4  A7C90048   SH T1, 72(S8)
9D0000F8  A7C8004C   SH T0, 76(S8)
9D0000FC  A7C60050   SH A2, 80(S8)
9D000100  A7C50054   SH A1, 84(S8)
9D000104  A7C40030   SH A0, 48(S8)
9D000108  A7C30034   SH V1, 52(S8)
9D00010C  A3C20038   SB V0, 56(S8)
179:                 
180:                     // this is using a variant of the Midpoint (Bresenham's) Algorithm
181:                     #ifndef USE_NONBLOCKING_CONFIG
182:                 
183:                     SHORT       y1Limit, y2Limit;
184:                     SHORT       x1, x2, y1, y2;
185:                     SHORT       err1, err2;
186:                     SHORT       x1Cur, y1Cur, y1New;
187:                     SHORT       x2Cur, y2Cur, y2New;
188:                     DWORD_VAL   temp;
189:                 
190:                     temp.Val = SIN45 * r1;
9D000110  87C30030   LH V1, 48(S8)
9D000114  3402B505   ORI V0, ZERO, -19195
9D000118  70621002   MUL V0, V1, V0
9D00011C  AFC2002C   SW V0, 44(S8)
191:                     y1Limit = temp.w[1];
9D000120  97C2002E   LHU V0, 46(S8)
9D000124  A7C20024   SH V0, 36(S8)
192:                     temp.Val = SIN45 * r2;
9D000128  87C30034   LH V1, 52(S8)
9D00012C  3402B505   ORI V0, ZERO, -19195
9D000130  70621002   MUL V0, V1, V0
9D000134  AFC2002C   SW V0, 44(S8)
193:                     y2Limit = temp.w[1];
9D000138  97C2002E   LHU V0, 46(S8)
9D00013C  A7C20026   SH V0, 38(S8)
194:                 
195:                     temp.Val = (DWORD) (ONEP25 - ((LONG) r1 << 16));
9D000140  87C20030   LH V0, 48(S8)
9D000144  00021400   SLL V0, V0, 16
9D000148  3C030001   LUI V1, 1
9D00014C  34634000   ORI V1, V1, 16384
9D000150  00621023   SUBU V0, V1, V0
9D000154  AFC2002C   SW V0, 44(S8)
196:                     err1 = (SHORT) (temp.w[1]);
9D000158  97C2002E   LHU V0, 46(S8)
9D00015C  A7C20018   SH V0, 24(S8)
197:                 
198:                     temp.Val = (DWORD) (ONEP25 - ((LONG) r2 << 16));
9D000160  87C20034   LH V0, 52(S8)
9D000164  00021400   SLL V0, V0, 16
9D000168  3C030001   LUI V1, 1
9D00016C  34634000   ORI V1, V1, 16384
9D000170  00621023   SUBU V0, V1, V0
9D000174  AFC2002C   SW V0, 44(S8)
199:                     err2 = (SHORT) (temp.w[1]);
9D000178  97C2002E   LHU V0, 46(S8)
9D00017C  A7C2001A   SH V0, 26(S8)
200:                 
201:                     x1 = r1;
9D000180  97C20030   LHU V0, 48(S8)
9D000184  A7C20010   SH V0, 16(S8)
202:                     x2 = r2;
9D000188  97C20034   LHU V0, 52(S8)
9D00018C  A7C20012   SH V0, 18(S8)
203:                     y1 = 0;
9D000190  A7C00014   SH ZERO, 20(S8)
204:                     y2 = 0;
9D000194  A7C00016   SH ZERO, 22(S8)
205:                 
206:                     x1Cur = x1;
9D000198  97C20010   LHU V0, 16(S8)
9D00019C  A7C2001C   SH V0, 28(S8)
207:                     y1Cur = y1;
9D0001A0  97C20014   LHU V0, 20(S8)
9D0001A4  A7C2001E   SH V0, 30(S8)
208:                     y1New = y1;
9D0001A8  97C20014   LHU V0, 20(S8)
9D0001AC  A7C20028   SH V0, 40(S8)
209:                     x2Cur = x2;
9D0001B0  97C20012   LHU V0, 18(S8)
9D0001B4  A7C20020   SH V0, 32(S8)
210:                     y2Cur = y2;
9D0001B8  97C20016   LHU V0, 22(S8)
9D0001BC  A7C20022   SH V0, 34(S8)
211:                     y2New = y2;
9D0001C0  97C20016   LHU V0, 22(S8)
9D0001C4  A7C2002A   SH V0, 42(S8)
212:                 
213:                     while(y2 <= y2Limit)
9D0001C8  0B4001D9   J 0x9D000764
9D0001CC  00000000   NOP
9D000764  87C30016   LH V1, 22(S8)
9D000768  87C20026   LH V0, 38(S8)
9D00076C  0043102A   SLT V0, V0, V1
9D000770  1040FE97   BEQ V0, ZERO, 0x9D0001D0
9D000774  00000000   NOP
214:                     {   // just watch for y2 limit since outer circle
215:                         // will have greater value.
216:                         // Drawing of the rounded panel is done only when there is a change in the
217:                         // x direction. Bars are drawn to be efficient.
218:                         // detect changes in the x position. Every change will mean a bar will be drawn
219:                         // to cover the previous area. y1New records the last position of y before the
220:                         // change in x position.
221:                         // y1New & y2New records the last y positions, must remember this to
222:                         // draw the correct bars (non-overlapping).
223:                         y1New = y1;
9D0001D0  97C20014   LHU V0, 20(S8)
9D0001D4  A7C20028   SH V0, 40(S8)
224:                         y2New = y2;
9D0001D8  97C20016   LHU V0, 22(S8)
9D0001DC  A7C2002A   SH V0, 42(S8)
225:                 
226:                         if(y1 <= y1Limit)
9D0001E0  87C30014   LH V1, 20(S8)
9D0001E4  87C20024   LH V0, 36(S8)
9D0001E8  0043102A   SLT V0, V0, V1
9D0001EC  14400027   BNE V0, ZERO, 0x9D00028C
9D0001F0  00000000   NOP
227:                         {
228:                             if(err1 > 0)
9D0001F4  87C20018   LH V0, 24(S8)
9D0001F8  18400014   BLEZ V0, 0x9D00024C
9D0001FC  00000000   NOP
229:                             {
230:                                 x1--;
9D000200  97C20010   LHU V0, 16(S8)
9D000204  2442FFFF   ADDIU V0, V0, -1
9D000208  A7C20010   SH V0, 16(S8)
231:                                 err1 += 5;
9D00020C  97C20018   LHU V0, 24(S8)
9D000210  24420005   ADDIU V0, V0, 5
9D000214  3042FFFF   ANDI V0, V0, -1
9D000218  A7C20018   SH V0, 24(S8)
232:                                 err1 += (y1 - x1) << 1;
9D00021C  97C30014   LHU V1, 20(S8)
9D000220  97C20010   LHU V0, 16(S8)
9D000224  00621023   SUBU V0, V1, V0
9D000228  3042FFFF   ANDI V0, V0, -1
9D00022C  00021040   SLL V0, V0, 1
9D000230  3043FFFF   ANDI V1, V0, -1
9D000234  97C20018   LHU V0, 24(S8)
9D000238  00621021   ADDU V0, V1, V0
9D00023C  3042FFFF   ANDI V0, V0, -1
9D000240  A7C20018   SH V0, 24(S8)
9D000244  0B40009E   J 0x9D000278
9D000248  00000000   NOP
233:                             }
234:                             else
235:                             {
236:                                 err1 += 3;
9D00024C  97C20018   LHU V0, 24(S8)
9D000250  24420003   ADDIU V0, V0, 3
9D000254  3042FFFF   ANDI V0, V0, -1
9D000258  A7C20018   SH V0, 24(S8)
237:                                 err1 += y1 << 1;
9D00025C  97C20014   LHU V0, 20(S8)
9D000260  00021040   SLL V0, V0, 1
9D000264  3043FFFF   ANDI V1, V0, -1
9D000268  97C20018   LHU V0, 24(S8)
9D00026C  00621021   ADDU V0, V1, V0
9D000270  3042FFFF   ANDI V0, V0, -1
9D000274  A7C20018   SH V0, 24(S8)
238:                             }
239:                 
240:                             y1++;
9D000278  97C20014   LHU V0, 20(S8)
9D00027C  24420001   ADDIU V0, V0, 1
9D000280  A7C20014   SH V0, 20(S8)
9D000284  0B4000AD   J 0x9D0002B4
9D000288  00000000   NOP
241:                         }
242:                         else
243:                         {
244:                             y1++;
9D00028C  97C20014   LHU V0, 20(S8)
9D000290  24420001   ADDIU V0, V0, 1
9D000294  A7C20014   SH V0, 20(S8)
245:                             if(x1 < y1)
9D000298  87C30010   LH V1, 16(S8)
9D00029C  87C20014   LH V0, 20(S8)
9D0002A0  0062102A   SLT V0, V1, V0
9D0002A4  10400003   BEQ V0, ZERO, 0x9D0002B4
9D0002A8  00000000   NOP
246:                                 x1 = y1;
9D0002AC  97C20014   LHU V0, 20(S8)
9D0002B0  A7C20010   SH V0, 16(S8)
247:                         }
248:                 
249:                         if(err2 > 0)
9D0002B4  87C2001A   LH V0, 26(S8)
9D0002B8  18400014   BLEZ V0, 0x9D00030C
9D0002BC  00000000   NOP
250:                         {
251:                             x2--;
9D0002C0  97C20012   LHU V0, 18(S8)
9D0002C4  2442FFFF   ADDIU V0, V0, -1
9D0002C8  A7C20012   SH V0, 18(S8)
252:                             err2 += 5;
9D0002CC  97C2001A   LHU V0, 26(S8)
9D0002D0  24420005   ADDIU V0, V0, 5
9D0002D4  3042FFFF   ANDI V0, V0, -1
9D0002D8  A7C2001A   SH V0, 26(S8)
253:                             err2 += (y2 - x2) << 1;
9D0002DC  97C30016   LHU V1, 22(S8)
9D0002E0  97C20012   LHU V0, 18(S8)
9D0002E4  00621023   SUBU V0, V1, V0
9D0002E8  3042FFFF   ANDI V0, V0, -1
9D0002EC  00021040   SLL V0, V0, 1
9D0002F0  3043FFFF   ANDI V1, V0, -1
9D0002F4  97C2001A   LHU V0, 26(S8)
9D0002F8  00621021   ADDU V0, V1, V0
9D0002FC  3042FFFF   ANDI V0, V0, -1
9D000300  A7C2001A   SH V0, 26(S8)
9D000304  0B4000CE   J 0x9D000338
9D000308  00000000   NOP
254:                         }
255:                         else
256:                         {
257:                             err2 += 3;
9D00030C  97C2001A   LHU V0, 26(S8)
9D000310  24420003   ADDIU V0, V0, 3
9D000314  3042FFFF   ANDI V0, V0, -1
9D000318  A7C2001A   SH V0, 26(S8)
258:                             err2 += y2 << 1;
9D00031C  97C20016   LHU V0, 22(S8)
9D000320  00021040   SLL V0, V0, 1
9D000324  3043FFFF   ANDI V1, V0, -1
9D000328  97C2001A   LHU V0, 26(S8)
9D00032C  00621021   ADDU V0, V1, V0
9D000330  3042FFFF   ANDI V0, V0, -1
9D000334  A7C2001A   SH V0, 26(S8)
259:                         }
260:                 
261:                         y2++;
9D000338  97C20016   LHU V0, 22(S8)
9D00033C  24420001   ADDIU V0, V0, 1
9D000340  A7C20016   SH V0, 22(S8)
262:                 
263:                         if((x1Cur != x1) || (x2Cur != x2))
9D000344  87C3001C   LH V1, 28(S8)
9D000348  87C20010   LH V0, 16(S8)
9D00034C  14620005   BNE V1, V0, 0x9D000364
9D000350  00000000   NOP
9D000354  87C30020   LH V1, 32(S8)
9D000358  87C20012   LH V0, 18(S8)
9D00035C  10620101   BEQ V1, V0, 0x9D000764
9D000360  00000000   NOP
264:                         {
265:                             if(octant & 0x01)
9D000364  93C20038   LBU V0, 56(S8)
9D000368  30420001   ANDI V0, V0, 1
9D00036C  304200FF   ANDI V0, V0, 255
9D000370  1040001C   BEQ V0, ZERO, 0x9D0003E4
9D000374  00000000   NOP
266:                             {
267:                                 Bar(xR + y2Cur, yT - x2Cur, xR + y1New, yT - x1Cur);    // 1st octant
9D000378  97C30050   LHU V1, 80(S8)
9D00037C  97C20022   LHU V0, 34(S8)
9D000380  00621021   ADDU V0, V1, V0
9D000384  3042FFFF   ANDI V0, V0, -1
9D000388  7C021620   SEH V0, V0
9D00038C  00402021   ADDU A0, V0, ZERO
9D000390  97C3004C   LHU V1, 76(S8)
9D000394  97C20020   LHU V0, 32(S8)
9D000398  00621023   SUBU V0, V1, V0
9D00039C  3042FFFF   ANDI V0, V0, -1
9D0003A0  7C021620   SEH V0, V0
9D0003A4  00402821   ADDU A1, V0, ZERO
9D0003A8  97C30050   LHU V1, 80(S8)
9D0003AC  97C20028   LHU V0, 40(S8)
9D0003B0  00621021   ADDU V0, V1, V0
9D0003B4  3042FFFF   ANDI V0, V0, -1
9D0003B8  7C021620   SEH V0, V0
9D0003BC  00401821   ADDU V1, V0, ZERO
9D0003C0  97C6004C   LHU A2, 76(S8)
9D0003C4  97C2001C   LHU V0, 28(S8)
9D0003C8  00C21023   SUBU V0, A2, V0
9D0003CC  3042FFFF   ANDI V0, V0, -1
9D0003D0  7C021620   SEH V0, V0
9D0003D4  00603021   ADDU A2, V1, ZERO
9D0003D8  00403821   ADDU A3, V0, ZERO
9D0003DC  0F400C02   JAL Bar
9D0003E0  00000000   NOP
268:                             }
269:                 
270:                             if(octant & 0x02)
9D0003E4  93C20038   LBU V0, 56(S8)
9D0003E8  30420002   ANDI V0, V0, 2
9D0003EC  1040001C   BEQ V0, ZERO, 0x9D000460
9D0003F0  00000000   NOP
271:                             {
272:                                 Bar(xR + x1Cur, yT - y1New, xR + x2Cur, yT - y2Cur);    // 2nd octant
9D0003F4  97C30050   LHU V1, 80(S8)
9D0003F8  97C2001C   LHU V0, 28(S8)
9D0003FC  00621021   ADDU V0, V1, V0
9D000400  3042FFFF   ANDI V0, V0, -1
9D000404  7C021620   SEH V0, V0
9D000408  00402021   ADDU A0, V0, ZERO
9D00040C  97C3004C   LHU V1, 76(S8)
9D000410  97C20028   LHU V0, 40(S8)
9D000414  00621023   SUBU V0, V1, V0
9D000418  3042FFFF   ANDI V0, V0, -1
9D00041C  7C021620   SEH V0, V0
9D000420  00402821   ADDU A1, V0, ZERO
9D000424  97C30050   LHU V1, 80(S8)
9D000428  97C20020   LHU V0, 32(S8)
9D00042C  00621021   ADDU V0, V1, V0
9D000430  3042FFFF   ANDI V0, V0, -1
9D000434  7C021620   SEH V0, V0
9D000438  00401821   ADDU V1, V0, ZERO
9D00043C  97C6004C   LHU A2, 76(S8)
9D000440  97C20022   LHU V0, 34(S8)
9D000444  00C21023   SUBU V0, A2, V0
9D000448  3042FFFF   ANDI V0, V0, -1
9D00044C  7C021620   SEH V0, V0
9D000450  00603021   ADDU A2, V1, ZERO
9D000454  00403821   ADDU A3, V0, ZERO
9D000458  0F400C02   JAL Bar
9D00045C  00000000   NOP
273:                             }
274:                 
275:                             if(octant & 0x04)
9D000460  93C20038   LBU V0, 56(S8)
9D000464  30420004   ANDI V0, V0, 4
9D000468  1040001C   BEQ V0, ZERO, 0x9D0004DC
9D00046C  00000000   NOP
276:                             {
277:                                 Bar(xR + x1Cur, yB + y1Cur, xR + x2Cur, yB + y2New);    // 3rd octant
9D000470  97C30050   LHU V1, 80(S8)
9D000474  97C2001C   LHU V0, 28(S8)
9D000478  00621021   ADDU V0, V1, V0
9D00047C  3042FFFF   ANDI V0, V0, -1
9D000480  7C021620   SEH V0, V0
9D000484  00402021   ADDU A0, V0, ZERO
9D000488  97C30054   LHU V1, 84(S8)
9D00048C  97C2001E   LHU V0, 30(S8)
9D000490  00621021   ADDU V0, V1, V0
9D000494  3042FFFF   ANDI V0, V0, -1
9D000498  7C021620   SEH V0, V0
9D00049C  00402821   ADDU A1, V0, ZERO
9D0004A0  97C30050   LHU V1, 80(S8)
9D0004A4  97C20020   LHU V0, 32(S8)
9D0004A8  00621021   ADDU V0, V1, V0
9D0004AC  3042FFFF   ANDI V0, V0, -1
9D0004B0  7C021620   SEH V0, V0
9D0004B4  00401821   ADDU V1, V0, ZERO
9D0004B8  97C60054   LHU A2, 84(S8)
9D0004BC  97C2002A   LHU V0, 42(S8)
9D0004C0  00C21021   ADDU V0, A2, V0
9D0004C4  3042FFFF   ANDI V0, V0, -1
9D0004C8  7C021620   SEH V0, V0
9D0004CC  00603021   ADDU A2, V1, ZERO
9D0004D0  00403821   ADDU A3, V0, ZERO
9D0004D4  0F400C02   JAL Bar
9D0004D8  00000000   NOP
278:                             }
279:                 
280:                             if(octant & 0x08)
9D0004DC  93C20038   LBU V0, 56(S8)
9D0004E0  30420008   ANDI V0, V0, 8
9D0004E4  1040001C   BEQ V0, ZERO, 0x9D000558
9D0004E8  00000000   NOP
281:                             {
282:                                 Bar(xR + y1Cur, yB + x1Cur, xR + y2New, yB + x2Cur);    // 4th octant
9D0004EC  97C30050   LHU V1, 80(S8)
9D0004F0  97C2001E   LHU V0, 30(S8)
9D0004F4  00621021   ADDU V0, V1, V0
9D0004F8  3042FFFF   ANDI V0, V0, -1
9D0004FC  7C021620   SEH V0, V0
9D000500  00402021   ADDU A0, V0, ZERO
9D000504  97C30054   LHU V1, 84(S8)
9D000508  97C2001C   LHU V0, 28(S8)
9D00050C  00621021   ADDU V0, V1, V0
9D000510  3042FFFF   ANDI V0, V0, -1
9D000514  7C021620   SEH V0, V0
9D000518  00402821   ADDU A1, V0, ZERO
9D00051C  97C30050   LHU V1, 80(S8)
9D000520  97C2002A   LHU V0, 42(S8)
9D000524  00621021   ADDU V0, V1, V0
9D000528  3042FFFF   ANDI V0, V0, -1
9D00052C  7C021620   SEH V0, V0
9D000530  00401821   ADDU V1, V0, ZERO
9D000534  97C60054   LHU A2, 84(S8)
9D000538  97C20020   LHU V0, 32(S8)
9D00053C  00C21021   ADDU V0, A2, V0
9D000540  3042FFFF   ANDI V0, V0, -1
9D000544  7C021620   SEH V0, V0
9D000548  00603021   ADDU A2, V1, ZERO
9D00054C  00403821   ADDU A3, V0, ZERO
9D000550  0F400C02   JAL Bar
9D000554  00000000   NOP
283:                             }
284:                 
285:                             if(octant & 0x10)
9D000558  93C20038   LBU V0, 56(S8)
9D00055C  30420010   ANDI V0, V0, 16
9D000560  1040001C   BEQ V0, ZERO, 0x9D0005D4
9D000564  00000000   NOP
286:                             {
287:                                 Bar(xL - y1New, yB + x1Cur, xL - y2Cur, yB + x2Cur);    // 5th octant
9D000568  97C30048   LHU V1, 72(S8)
9D00056C  97C20028   LHU V0, 40(S8)
9D000570  00621023   SUBU V0, V1, V0
9D000574  3042FFFF   ANDI V0, V0, -1
9D000578  7C021620   SEH V0, V0
9D00057C  00402021   ADDU A0, V0, ZERO
9D000580  97C30054   LHU V1, 84(S8)
9D000584  97C2001C   LHU V0, 28(S8)
9D000588  00621021   ADDU V0, V1, V0
9D00058C  3042FFFF   ANDI V0, V0, -1
9D000590  7C021620   SEH V0, V0
9D000594  00402821   ADDU A1, V0, ZERO
9D000598  97C30048   LHU V1, 72(S8)
9D00059C  97C20022   LHU V0, 34(S8)
9D0005A0  00621023   SUBU V0, V1, V0
9D0005A4  3042FFFF   ANDI V0, V0, -1
9D0005A8  7C021620   SEH V0, V0
9D0005AC  00401821   ADDU V1, V0, ZERO
9D0005B0  97C60054   LHU A2, 84(S8)
9D0005B4  97C20020   LHU V0, 32(S8)
9D0005B8  00C21021   ADDU V0, A2, V0
9D0005BC  3042FFFF   ANDI V0, V0, -1
9D0005C0  7C021620   SEH V0, V0
9D0005C4  00603021   ADDU A2, V1, ZERO
9D0005C8  00403821   ADDU A3, V0, ZERO
9D0005CC  0F400C02   JAL Bar
9D0005D0  00000000   NOP
288:                             }
289:                 
290:                             if(octant & 0x20)
9D0005D4  93C20038   LBU V0, 56(S8)
9D0005D8  30420020   ANDI V0, V0, 32
9D0005DC  1040001C   BEQ V0, ZERO, 0x9D000650
9D0005E0  00000000   NOP
291:                             {
292:                                 Bar(xL - x2Cur, yB + y2Cur, xL - x1Cur, yB + y1New);    // 6th octant
9D0005E4  97C30048   LHU V1, 72(S8)
9D0005E8  97C20020   LHU V0, 32(S8)
9D0005EC  00621023   SUBU V0, V1, V0
9D0005F0  3042FFFF   ANDI V0, V0, -1
9D0005F4  7C021620   SEH V0, V0
9D0005F8  00402021   ADDU A0, V0, ZERO
9D0005FC  97C30054   LHU V1, 84(S8)
9D000600  97C20022   LHU V0, 34(S8)
9D000604  00621021   ADDU V0, V1, V0
9D000608  3042FFFF   ANDI V0, V0, -1
9D00060C  7C021620   SEH V0, V0
9D000610  00402821   ADDU A1, V0, ZERO
9D000614  97C30048   LHU V1, 72(S8)
9D000618  97C2001C   LHU V0, 28(S8)
9D00061C  00621023   SUBU V0, V1, V0
9D000620  3042FFFF   ANDI V0, V0, -1
9D000624  7C021620   SEH V0, V0
9D000628  00401821   ADDU V1, V0, ZERO
9D00062C  97C60054   LHU A2, 84(S8)
9D000630  97C20028   LHU V0, 40(S8)
9D000634  00C21021   ADDU V0, A2, V0
9D000638  3042FFFF   ANDI V0, V0, -1
9D00063C  7C021620   SEH V0, V0
9D000640  00603021   ADDU A2, V1, ZERO
9D000644  00403821   ADDU A3, V0, ZERO
9D000648  0F400C02   JAL Bar
9D00064C  00000000   NOP
293:                             }
294:                 
295:                             if(octant & 0x40)
9D000650  93C20038   LBU V0, 56(S8)
9D000654  30420040   ANDI V0, V0, 64
9D000658  1040001C   BEQ V0, ZERO, 0x9D0006CC
9D00065C  00000000   NOP
296:                             {
297:                                 Bar(xL - x2Cur, yT - y2New, xL - x1Cur, yT - y1Cur);    // 7th octant
9D000660  97C30048   LHU V1, 72(S8)
9D000664  97C20020   LHU V0, 32(S8)
9D000668  00621023   SUBU V0, V1, V0
9D00066C  3042FFFF   ANDI V0, V0, -1
9D000670  7C021620   SEH V0, V0
9D000674  00402021   ADDU A0, V0, ZERO
9D000678  97C3004C   LHU V1, 76(S8)
9D00067C  97C2002A   LHU V0, 42(S8)
9D000680  00621023   SUBU V0, V1, V0
9D000684  3042FFFF   ANDI V0, V0, -1
9D000688  7C021620   SEH V0, V0
9D00068C  00402821   ADDU A1, V0, ZERO
9D000690  97C30048   LHU V1, 72(S8)
9D000694  97C2001C   LHU V0, 28(S8)
9D000698  00621023   SUBU V0, V1, V0
9D00069C  3042FFFF   ANDI V0, V0, -1
9D0006A0  7C021620   SEH V0, V0
9D0006A4  00401821   ADDU V1, V0, ZERO
9D0006A8  97C6004C   LHU A2, 76(S8)
9D0006AC  97C2001E   LHU V0, 30(S8)
9D0006B0  00C21023   SUBU V0, A2, V0
9D0006B4  3042FFFF   ANDI V0, V0, -1
9D0006B8  7C021620   SEH V0, V0
9D0006BC  00603021   ADDU A2, V1, ZERO
9D0006C0  00403821   ADDU A3, V0, ZERO
9D0006C4  0F400C02   JAL Bar
9D0006C8  00000000   NOP
298:                             }
299:                 
300:                             if(octant & 0x80)
9D0006CC  83C20038   LB V0, 56(S8)
9D0006D0  0441001C   BGEZ V0, 0x9D000744
9D0006D4  00000000   NOP
301:                             {
302:                                 Bar(xL - y2New, yT - x2Cur, xL - y1Cur, yT - x1Cur);    // 8th octant
9D0006D8  97C30048   LHU V1, 72(S8)
9D0006DC  97C2002A   LHU V0, 42(S8)
9D0006E0  00621023   SUBU V0, V1, V0
9D0006E4  3042FFFF   ANDI V0, V0, -1
9D0006E8  7C021620   SEH V0, V0
9D0006EC  00402021   ADDU A0, V0, ZERO
9D0006F0  97C3004C   LHU V1, 76(S8)
9D0006F4  97C20020   LHU V0, 32(S8)
9D0006F8  00621023   SUBU V0, V1, V0
9D0006FC  3042FFFF   ANDI V0, V0, -1
9D000700  7C021620   SEH V0, V0
9D000704  00402821   ADDU A1, V0, ZERO
9D000708  97C30048   LHU V1, 72(S8)
9D00070C  97C2001E   LHU V0, 30(S8)
9D000710  00621023   SUBU V0, V1, V0
9D000714  3042FFFF   ANDI V0, V0, -1
9D000718  7C021620   SEH V0, V0
9D00071C  00401821   ADDU V1, V0, ZERO
9D000720  97C6004C   LHU A2, 76(S8)
9D000724  97C2001C   LHU V0, 28(S8)
9D000728  00C21023   SUBU V0, A2, V0
9D00072C  3042FFFF   ANDI V0, V0, -1
9D000730  7C021620   SEH V0, V0
9D000734  00603021   ADDU A2, V1, ZERO
9D000738  00403821   ADDU A3, V0, ZERO
9D00073C  0F400C02   JAL Bar
9D000740  00000000   NOP
303:                             }
304:                 
305:                             // update current values
306:                             x1Cur = x1;
9D000744  97C20010   LHU V0, 16(S8)
9D000748  A7C2001C   SH V0, 28(S8)
307:                             y1Cur = y1;
9D00074C  97C20014   LHU V0, 20(S8)
9D000750  A7C2001E   SH V0, 30(S8)
308:                             x2Cur = x2;
9D000754  97C20012   LHU V0, 18(S8)
9D000758  A7C20020   SH V0, 32(S8)
309:                             y2Cur = y2;
9D00075C  97C20016   LHU V0, 22(S8)
9D000760  A7C20022   SH V0, 34(S8)
310:                         }
311:                     }                           // end of while loop
312:                 
313:                     // draw the width and height
314:                     if((xR - xL) || (yB - yT))
9D000778  87C30050   LH V1, 80(S8)
9D00077C  87C20048   LH V0, 72(S8)
9D000780  14620005   BNE V1, V0, 0x9D000798
9D000784  00000000   NOP
9D000788  87C30054   LH V1, 84(S8)
9D00078C  87C2004C   LH V0, 76(S8)
9D000790  106200DB   BEQ V1, V0, 0x9D000B00
9D000794  00000000   NOP
315:                     {
316:                 
317:                         // draw right
318:                         if(octant & 0x02)
9D000798  93C20038   LBU V0, 56(S8)
9D00079C  30420002   ANDI V0, V0, 2
9D0007A0  10400017   BEQ V0, ZERO, 0x9D000800
9D0007A4  00000000   NOP
319:                         {
320:                             Bar(xR + r1, yT, xR + r2, (yB + yT) >> 1);
9D0007A8  97C30050   LHU V1, 80(S8)
9D0007AC  97C20030   LHU V0, 48(S8)
9D0007B0  00621021   ADDU V0, V1, V0
9D0007B4  3042FFFF   ANDI V0, V0, -1
9D0007B8  7C021620   SEH V0, V0
9D0007BC  00402021   ADDU A0, V0, ZERO
9D0007C0  87C5004C   LH A1, 76(S8)
9D0007C4  97C30050   LHU V1, 80(S8)
9D0007C8  97C20034   LHU V0, 52(S8)
9D0007CC  00621021   ADDU V0, V1, V0
9D0007D0  3042FFFF   ANDI V0, V0, -1
9D0007D4  7C021620   SEH V0, V0
9D0007D8  00401821   ADDU V1, V0, ZERO
9D0007DC  87C60054   LH A2, 84(S8)
9D0007E0  87C2004C   LH V0, 76(S8)
9D0007E4  00C21021   ADDU V0, A2, V0
9D0007E8  00021043   SRA V0, V0, 1
9D0007EC  7C021620   SEH V0, V0
9D0007F0  00603021   ADDU A2, V1, ZERO
9D0007F4  00403821   ADDU A3, V0, ZERO
9D0007F8  0F400C02   JAL Bar
9D0007FC  00000000   NOP
321:                         }
322:                 
323:                         if(octant & 0x04)
9D000800  93C20038   LBU V0, 56(S8)
9D000804  30420004   ANDI V0, V0, 4
9D000808  10400018   BEQ V0, ZERO, 0x9D00086C
9D00080C  00000000   NOP
324:                         {
325:                             Bar(xR + r1, ((yB + yT) >> 1), xR + r2, yB);
9D000810  97C30050   LHU V1, 80(S8)
9D000814  97C20030   LHU V0, 48(S8)
9D000818  00621021   ADDU V0, V1, V0
9D00081C  3042FFFF   ANDI V0, V0, -1
9D000820  7C021620   SEH V0, V0
9D000824  00402021   ADDU A0, V0, ZERO
9D000828  87C30054   LH V1, 84(S8)
9D00082C  87C2004C   LH V0, 76(S8)
9D000830  00621021   ADDU V0, V1, V0
9D000834  00021043   SRA V0, V0, 1
9D000838  7C021620   SEH V0, V0
9D00083C  00402821   ADDU A1, V0, ZERO
9D000840  97C30050   LHU V1, 80(S8)
9D000844  97C20034   LHU V0, 52(S8)
9D000848  00621021   ADDU V0, V1, V0
9D00084C  3042FFFF   ANDI V0, V0, -1
9D000850  7C021620   SEH V0, V0
9D000854  00401821   ADDU V1, V0, ZERO
9D000858  87C20054   LH V0, 84(S8)
9D00085C  00603021   ADDU A2, V1, ZERO
9D000860  00403821   ADDU A3, V0, ZERO
9D000864  0F400C02   JAL Bar
9D000868  00000000   NOP
326:                         }
327:                 
328:                         // draw bottom
329:                         if(octant & 0x10)
9D00086C  93C20038   LBU V0, 56(S8)
9D000870  30420010   ANDI V0, V0, 16
9D000874  10400017   BEQ V0, ZERO, 0x9D0008D4
9D000878  00000000   NOP
330:                         {
331:                             Bar(xL, yB + r1, ((xR + xL) >> 1), yB + r2);
9D00087C  87C40048   LH A0, 72(S8)
9D000880  97C30054   LHU V1, 84(S8)
9D000884  97C20030   LHU V0, 48(S8)
9D000888  00621021   ADDU V0, V1, V0
9D00088C  3042FFFF   ANDI V0, V0, -1
9D000890  7C021620   SEH V0, V0
9D000894  00402821   ADDU A1, V0, ZERO
9D000898  87C30050   LH V1, 80(S8)
9D00089C  87C20048   LH V0, 72(S8)
9D0008A0  00621021   ADDU V0, V1, V0
9D0008A4  00021043   SRA V0, V0, 1
9D0008A8  7C021620   SEH V0, V0
9D0008AC  00401821   ADDU V1, V0, ZERO
9D0008B0  97C60054   LHU A2, 84(S8)
9D0008B4  97C20034   LHU V0, 52(S8)
9D0008B8  00C21021   ADDU V0, A2, V0
9D0008BC  3042FFFF   ANDI V0, V0, -1
9D0008C0  7C021620   SEH V0, V0
9D0008C4  00603021   ADDU A2, V1, ZERO
9D0008C8  00403821   ADDU A3, V0, ZERO
9D0008CC  0F400C02   JAL Bar
9D0008D0  00000000   NOP
332:                         }
333:                 
334:                         if(octant & 0x08)
9D0008D4  93C20038   LBU V0, 56(S8)
9D0008D8  30420008   ANDI V0, V0, 8
9D0008DC  10400017   BEQ V0, ZERO, 0x9D00093C
9D0008E0  00000000   NOP
335:                         {
336:                             Bar(((xR + xL) >> 1), yB + r1, xR, yB + r2);
9D0008E4  87C30050   LH V1, 80(S8)
9D0008E8  87C20048   LH V0, 72(S8)
9D0008EC  00621021   ADDU V0, V1, V0
9D0008F0  00021043   SRA V0, V0, 1
9D0008F4  7C021620   SEH V0, V0
9D0008F8  00402021   ADDU A0, V0, ZERO
9D0008FC  97C30054   LHU V1, 84(S8)
9D000900  97C20030   LHU V0, 48(S8)
9D000904  00621021   ADDU V0, V1, V0
9D000908  3042FFFF   ANDI V0, V0, -1
9D00090C  7C021620   SEH V0, V0
9D000910  00402821   ADDU A1, V0, ZERO
9D000914  87C30050   LH V1, 80(S8)
9D000918  97C60054   LHU A2, 84(S8)
9D00091C  97C20034   LHU V0, 52(S8)
9D000920  00C21021   ADDU V0, A2, V0
9D000924  3042FFFF   ANDI V0, V0, -1
9D000928  7C021620   SEH V0, V0
9D00092C  00603021   ADDU A2, V1, ZERO
9D000930  00403821   ADDU A3, V0, ZERO
9D000934  0F400C02   JAL Bar
9D000938  00000000   NOP
337:                         }
338:                 
339:                         if(xR - xL)
9D00093C  87C30050   LH V1, 80(S8)
9D000940  87C20048   LH V0, 72(S8)
9D000944  10620035   BEQ V1, V0, 0x9D000A1C
9D000948  00000000   NOP
340:                         {
341:                 
342:                             // draw top
343:                             if(octant & 0x80)
9D00094C  83C20038   LB V0, 56(S8)
9D000950  04410017   BGEZ V0, 0x9D0009B0
9D000954  00000000   NOP
344:                             {
345:                                 Bar(xL, yT - r2, ((xR + xL) >> 1), yT - r1);
9D000958  87C40048   LH A0, 72(S8)
9D00095C  97C3004C   LHU V1, 76(S8)
9D000960  97C20034   LHU V0, 52(S8)
9D000964  00621023   SUBU V0, V1, V0
9D000968  3042FFFF   ANDI V0, V0, -1
9D00096C  7C021620   SEH V0, V0
9D000970  00402821   ADDU A1, V0, ZERO
9D000974  87C30050   LH V1, 80(S8)
9D000978  87C20048   LH V0, 72(S8)
9D00097C  00621021   ADDU V0, V1, V0
9D000980  00021043   SRA V0, V0, 1
9D000984  7C021620   SEH V0, V0
9D000988  00401821   ADDU V1, V0, ZERO
9D00098C  97C6004C   LHU A2, 76(S8)
9D000990  97C20030   LHU V0, 48(S8)
9D000994  00C21023   SUBU V0, A2, V0
9D000998  3042FFFF   ANDI V0, V0, -1
9D00099C  7C021620   SEH V0, V0
9D0009A0  00603021   ADDU A2, V1, ZERO
9D0009A4  00403821   ADDU A3, V0, ZERO
9D0009A8  0F400C02   JAL Bar
9D0009AC  00000000   NOP
346:                             }
347:                 
348:                             if(octant & 0x01)
9D0009B0  93C20038   LBU V0, 56(S8)
9D0009B4  30420001   ANDI V0, V0, 1
9D0009B8  304200FF   ANDI V0, V0, 255
9D0009BC  10400017   BEQ V0, ZERO, 0x9D000A1C
9D0009C0  00000000   NOP
349:                             {
350:                                 Bar(((xR + xL) >> 1), yT - r2, xR, yT - r1);
9D0009C4  87C30050   LH V1, 80(S8)
9D0009C8  87C20048   LH V0, 72(S8)
9D0009CC  00621021   ADDU V0, V1, V0
9D0009D0  00021043   SRA V0, V0, 1
9D0009D4  7C021620   SEH V0, V0
9D0009D8  00402021   ADDU A0, V0, ZERO
9D0009DC  97C3004C   LHU V1, 76(S8)
9D0009E0  97C20034   LHU V0, 52(S8)
9D0009E4  00621023   SUBU V0, V1, V0
9D0009E8  3042FFFF   ANDI V0, V0, -1
9D0009EC  7C021620   SEH V0, V0
9D0009F0  00402821   ADDU A1, V0, ZERO
9D0009F4  87C30050   LH V1, 80(S8)
9D0009F8  97C6004C   LHU A2, 76(S8)
9D0009FC  97C20030   LHU V0, 48(S8)
9D000A00  00C21023   SUBU V0, A2, V0
9D000A04  3042FFFF   ANDI V0, V0, -1
9D000A08  7C021620   SEH V0, V0
9D000A0C  00603021   ADDU A2, V1, ZERO
9D000A10  00403821   ADDU A3, V0, ZERO
9D000A14  0F400C02   JAL Bar
9D000A18  00000000   NOP
351:                             }
352:                         }
353:                 
354:                         if(yT - yB)
9D000A1C  87C3004C   LH V1, 76(S8)
9D000A20  87C20054   LH V0, 84(S8)
9D000A24  10620036   BEQ V1, V0, 0x9D000B00
9D000A28  00000000   NOP
355:                         {
356:                 
357:                             // draw left
358:                             if(octant & 0x40)
9D000A2C  93C20038   LBU V0, 56(S8)
9D000A30  30420040   ANDI V0, V0, 64
9D000A34  10400017   BEQ V0, ZERO, 0x9D000A94
9D000A38  00000000   NOP
359:                             {
360:                                 Bar(xL - r2, yT, xL - r1, ((yB + yT) >> 1));
9D000A3C  97C30048   LHU V1, 72(S8)
9D000A40  97C20034   LHU V0, 52(S8)
9D000A44  00621023   SUBU V0, V1, V0
9D000A48  3042FFFF   ANDI V0, V0, -1
9D000A4C  7C021620   SEH V0, V0
9D000A50  00402021   ADDU A0, V0, ZERO
9D000A54  87C5004C   LH A1, 76(S8)
9D000A58  97C30048   LHU V1, 72(S8)
9D000A5C  97C20030   LHU V0, 48(S8)
9D000A60  00621023   SUBU V0, V1, V0
9D000A64  3042FFFF   ANDI V0, V0, -1
9D000A68  7C021620   SEH V0, V0
9D000A6C  00401821   ADDU V1, V0, ZERO
9D000A70  87C60054   LH A2, 84(S8)
9D000A74  87C2004C   LH V0, 76(S8)
9D000A78  00C21021   ADDU V0, A2, V0
9D000A7C  00021043   SRA V0, V0, 1
9D000A80  7C021620   SEH V0, V0
9D000A84  00603021   ADDU A2, V1, ZERO
9D000A88  00403821   ADDU A3, V0, ZERO
9D000A8C  0F400C02   JAL Bar
9D000A90  00000000   NOP
361:                             }
362:                 
363:                             if(octant & 0x20)
9D000A94  93C20038   LBU V0, 56(S8)
9D000A98  30420020   ANDI V0, V0, 32
9D000A9C  10400018   BEQ V0, ZERO, 0x9D000B00
9D000AA0  00000000   NOP
364:                             {
365:                                 Bar(xL - r2, ((yB + yT) >> 1), xL - r1, yB);
9D000AA4  97C30048   LHU V1, 72(S8)
9D000AA8  97C20034   LHU V0, 52(S8)
9D000AAC  00621023   SUBU V0, V1, V0
9D000AB0  3042FFFF   ANDI V0, V0, -1
9D000AB4  7C021620   SEH V0, V0
9D000AB8  00402021   ADDU A0, V0, ZERO
9D000ABC  87C30054   LH V1, 84(S8)
9D000AC0  87C2004C   LH V0, 76(S8)
9D000AC4  00621021   ADDU V0, V1, V0
9D000AC8  00021043   SRA V0, V0, 1
9D000ACC  7C021620   SEH V0, V0
9D000AD0  00402821   ADDU A1, V0, ZERO
9D000AD4  97C30048   LHU V1, 72(S8)
9D000AD8  97C20030   LHU V0, 48(S8)
9D000ADC  00621023   SUBU V0, V1, V0
9D000AE0  3042FFFF   ANDI V0, V0, -1
9D000AE4  7C021620   SEH V0, V0
9D000AE8  00401821   ADDU V1, V0, ZERO
9D000AEC  87C20054   LH V0, 84(S8)
9D000AF0  00603021   ADDU A2, V1, ZERO
9D000AF4  00403821   ADDU A3, V0, ZERO
9D000AF8  0F400C02   JAL Bar
9D000AFC  00000000   NOP
366:                             }
367:                         }
368:                     }
369:                 
370:                     return (1);
9D000B00  24020001   ADDIU V0, ZERO, 1
371:                     #else
372:                 
373:                     typedef enum
374:                     {
375:                         BEGIN,
376:                         QUAD11,
377:                         BARRIGHT1,
378:                         QUAD12,
379:                         BARRIGHT2,
380:                         QUAD21,
381:                         BARLEFT1,
382:                         QUAD22,
383:                         BARLEFT2,
384:                         QUAD31,
385:                         BARTOP1,
386:                         QUAD32,
387:                         BARTOP2,
388:                         QUAD41,
389:                         BARBOTTOM1,
390:                         QUAD42,
391:                         BARBOTTOM2,
392:                         CHECK,
393:                     } OCTANTARC_STATES;
394:                 
395:                     DWORD_VAL temp;
396:                 
397:                     //	LONG temp1;
398:                     static SHORT y1Limit, y2Limit;
399:                     static SHORT x1, x2, y1, y2;
400:                     static SHORT err1, err2;
401:                     static SHORT x1Cur, y1Cur, y1New;
402:                     static SHORT x2Cur, y2Cur, y2New;
403:                     static OCTANTARC_STATES state = BEGIN;
404:                 
405:                     while(1)
406:                     {
407:                         if(IsDeviceBusy())
408:                             return (0);
409:                         switch(state)
410:                         {
411:                             case BEGIN:
412:                                 temp.Val = SIN45 * r1;
413:                                 y1Limit = temp.w[1];
414:                                 temp.Val = SIN45 * r2;
415:                                 y2Limit = temp.w[1];
416:                 
417:                                 temp.Val = (DWORD) (ONEP25 - ((LONG) r1 << 16));
418:                                 err1 = (SHORT) (temp.w[1]);
419:                 
420:                                 temp.Val = (DWORD) (ONEP25 - ((LONG) r2 << 16));
421:                                 err2 = (SHORT) (temp.w[1]);
422:                 
423:                                 x1 = r1;
424:                                 x2 = r2;
425:                                 y1 = 0;
426:                                 y2 = 0;
427:                 
428:                                 x1Cur = x1;
429:                                 y1Cur = y1;
430:                                 y1New = y1;
431:                                 x2Cur = x2;
432:                                 y2Cur = y2;
433:                                 y2New = y2;
434:                                 state = CHECK;
435:                 
436:                             case CHECK:
437:                                 arc_check_state : if(y2 > y2Limit)
438:                                 {
439:                                     state = BARRIGHT1;
440:                                     goto arc_draw_width_height_state;
441:                                 }
442:                 
443:                                 // y1New & y2New records the last y positions
444:                                 y1New = y1;
445:                                 y2New = y2;
446:                 
447:                                 if(y1 <= y1Limit)
448:                                 {
449:                                     if(err1 > 0)
450:                                     {
451:                                         x1--;
452:                                         err1 += 5;
453:                                         err1 += (y1 - x1) << 1;
454:                                     }
455:                                     else
456:                                     {
457:                                         err1 += 3;
458:                                         err1 += y1 << 1;
459:                                     }
460:                 
461:                                     y1++;
462:                                 }
463:                                 else
464:                                 {
465:                                     y1++;
466:                                     if(x1 < y1)
467:                                         x1 = y1;
468:                                 }
469:                 
470:                                 if(err2 > 0)
471:                                 {
472:                                     x2--;
473:                                     err2 += 5;
474:                                     err2 += (y2 - x2) << 1;
475:                                 }
476:                                 else
477:                                 {
478:                                     err2 += 3;
479:                                     err2 += y2 << 1;
480:                                 }
481:                 
482:                                 y2++;
483:                 
484:                                 state = QUAD11;
485:                                 break;
486:                 
487:                             case QUAD11:
488:                                 if((x1Cur != x1) || (x2Cur != x2))
489:                                 {
490:                 
491:                                     // 1st octant
492:                                     if(octant & 0x01)
493:                                     {
494:                                         if(Bar(xR + y2Cur, yT - x2Cur, xR + y1New, yT - x1Cur) == 0)
495:                                             return (0);
496:                                     }
497:                                 }
498:                                 else
499:                                 {
500:                                     state = CHECK;
501:                                     goto arc_check_state;
502:                                 }
503:                 
504:                                 state = QUAD12;
505:                                 break;
506:                 
507:                             case QUAD12:
508:                 
509:                                 // 2nd octant
510:                                 if(octant & 0x02)
511:                                 {
512:                                     if(Bar(xR + x1Cur, yT - y1New, xR + x2Cur, yT - y2Cur) == 0)
513:                                         return (0);
514:                                 }
515:                 
516:                                 state = QUAD21;
517:                                 break;
518:                 
519:                             case QUAD21:
520:                 
521:                                 // 3rd octant
522:                                 if(octant & 0x04)
523:                                 {
524:                                     if(Bar(xR + x1Cur, yB + y1Cur, xR + x2Cur, yB + y2New) == 0)
525:                                         return (0);
526:                                 }
527:                 
528:                                 state = QUAD22;
529:                                 break;
530:                 
531:                             case QUAD22:
532:                 
533:                                 // 4th octant
534:                                 if(octant & 0x08)
535:                                 {
536:                                     if(Bar(xR + y1Cur, yB + x1Cur, xR + y2New, yB + x2Cur) == 0)
537:                                         return (0);
538:                                 }
539:                 
540:                                 state = QUAD31;
541:                                 break;
542:                 
543:                             case QUAD31:
544:                 
545:                                 // 5th octant
546:                                 if(octant & 0x10)
547:                                 {
548:                                     if(Bar(xL - y1New, yB + x1Cur, xL - y2Cur, yB + x2Cur) == 0)
549:                                         return (0);
550:                                 }
551:                 
552:                                 state = QUAD32;
553:                                 break;
554:                 
555:                             case QUAD32:
556:                 
557:                                 // 6th octant
558:                                 if(octant & 0x20)
559:                                 {
560:                                     if(Bar(xL - x2Cur, yB + y2Cur, xL - x1Cur, yB + y1New) == 0)
561:                                         return (0);
562:                                 }
563:                 
564:                                 state = QUAD41;
565:                                 break;
566:                 
567:                             case QUAD41:
568:                 
569:                                 // 7th octant
570:                                 if(octant & 0x40)
571:                                 {
572:                                     if(Bar(xL - x2Cur, yT - y2New, xL - x1Cur, yT - y1Cur) == 0)
573:                                         return (0);
574:                                 }
575:                 
576:                                 state = QUAD42;
577:                                 break;
578:                 
579:                             case QUAD42:
580:                 
581:                                 // 8th octant
582:                                 if(octant & 0x80)
583:                                 {
584:                                     if(Bar(xL - y2New, yT - x2Cur, xL - y1Cur, yT - x1Cur) == 0)
585:                                         return (0);
586:                                 }
587:                 
588:                                 // update current values
589:                                 x1Cur = x1;
590:                                 y1Cur = y1;
591:                                 x2Cur = x2;
592:                                 y2Cur = y2;
593:                                 state = CHECK;
594:                                 break;
595:                 
596:                             case BARRIGHT1:     // draw upper right
597:                                 arc_draw_width_height_state : if((xR - xL) || (yB - yT))
598:                                 {
599:                 
600:                                     // draw right
601:                                     if(octant & 0x02)
602:                                     {
603:                                         if(Bar(xR + r1, yT, xR + r2, (yB + yT) >> 1) == 0)
604:                                             return (0);
605:                                     }
606:                                 }
607:                                 else
608:                                 {
609:                                     state = BEGIN;
610:                                     return (1);
611:                                 }
612:                 
613:                                 state = BARRIGHT2;
614:                                 break;
615:                 
616:                             case BARRIGHT2:     // draw lower right
617:                                 if(octant & 0x04)
618:                                 {
619:                                     if(Bar(xR + r1, ((yB + yT) >> 1), xR + r2, yB) == 0)
620:                                         return (0);
621:                                 }
622:                 
623:                                 state = BARBOTTOM1;
624:                                 break;
625:                 
626:                             case BARBOTTOM1:    // draw left bottom
627:                                 // draw bottom
628:                                 if(octant & 0x10)
629:                                 {
630:                                     if(Bar(xL, yB + r1, ((xR + xL) >> 1), yB + r2) == 0)
631:                                         return (0);
632:                                 }
633:                 
634:                                 state = BARBOTTOM2;
635:                                 break;
636:                 
637:                             case BARBOTTOM2:    // draw right bottom
638:                                 if(octant & 0x08)
639:                                 {
640:                                     if(Bar(((xR + xL) >> 1), yB + r1, xR, yB + r2) == 0)
641:                                         return (0);
642:                                 }
643:                 
644:                                 state = BARTOP1;
645:                                 break;
646:                 
647:                             case BARTOP1:       // draw left top
648:                                 if(xR - xL)
649:                                 {
650:                 
651:                                     // draw top
652:                                     if(octant & 0x80)
653:                                     {
654:                                         if(Bar(xL, yT - r2, ((xR + xL) >> 1), yT - r1) == 0)
655:                                             return (0);
656:                                     }
657:                 
658:                                     state = BARTOP2;
659:                                 }
660:                                 else
661:                                     state = BARLEFT1;   // no width go directly to height bar
662:                                 break;
663:                 
664:                             case BARTOP2:               // draw right top
665:                                 if(octant & 0x01)
666:                                 {
667:                                     if(Bar(((xR + xL) >> 1), yT - r2, xR, yT - r1) == 0)
668:                                         return (0);
669:                                 }
670:                 
671:                                 state = BARLEFT1;
672:                                 break;
673:                 
674:                             case BARLEFT1:              // draw upper left
675:                                 if(yT - yB)
676:                                 {
677:                 
678:                                     // draw left
679:                                     if(octant & 0x40)
680:                                     {
681:                                         if(Bar(xL - r2, yT, xL - r1, ((yB + yT) >> 1)) == 0)
682:                                             return (0);
683:                                     }
684:                 
685:                                     state = BARLEFT2;
686:                                 }
687:                                 else
688:                                 {
689:                                     state = BEGIN;      // no height go back to BEGIN
690:                                     return (1);
691:                                 }
692:                 
693:                                 break;
694:                 
695:                             case BARLEFT2:              // draw lower left
696:                                 if(octant & 0x20)
697:                                 {
698:                                     if(Bar(xL - r2, ((yB + yT) >> 1), xL - r1, yB) == 0)
699:                                         return (0);
700:                                 }
701:                 
702:                                 state = BEGIN;
703:                                 return (1);
704:                         }                               // end of switch
705:                     }   // end of while
706:                     #endif // USE_NONBLOCKING_CONFIG
707:                 }
9D000B04  03C0E821   ADDU SP, S8, ZERO
9D000B08  8FBF0044   LW RA, 68(SP)
9D000B0C  8FBE0040   LW S8, 64(SP)
9D000B10  27BD0048   ADDIU SP, SP, 72
9D000B14  03E00008   JR RA
9D000B18  00000000   NOP
708:                 
709:                 /*********************************************************************
710:                 * Function: WORD Line(SHORT x1, SHORT y1, SHORT x2, SHORT y2)
711:                 *
712:                 * PreCondition: none
713:                 *
714:                 * Input: x1,y1 - starting coordinates, x2,y2 - ending coordinates
715:                 *
716:                 * Output: For NON-Blocking configuration:
717:                 *         - Returns 0 when device is busy and the shape is not yet completely drawn.
718:                 *         - Returns 1 when the shape is completely drawn.
719:                 *         For Blocking configuration:
720:                 *         - Always return 1.
721:                 *
722:                 * Side Effects: none
723:                 *
724:                 * Overview: draws line
725:                 *
726:                 * Note: none
727:                 *
728:                 ********************************************************************/
729:                 #ifndef USE_DRV_LINE
730:                 
731:                 /* */
732:                 WORD Line(SHORT x1, SHORT y1, SHORT x2, SHORT y2)
733:                 {
9D000B1C  27BDFFD0   ADDIU SP, SP, -48
9D000B20  AFBF002C   SW RA, 44(SP)
9D000B24  AFBE0028   SW S8, 40(SP)
9D000B28  03A0F021   ADDU S8, SP, ZERO
9D000B2C  00804021   ADDU T0, A0, ZERO
9D000B30  00A02021   ADDU A0, A1, ZERO
9D000B34  00C01821   ADDU V1, A2, ZERO
9D000B38  00E01021   ADDU V0, A3, ZERO
9D000B3C  A7C80030   SH T0, 48(S8)
9D000B40  A7C40034   SH A0, 52(S8)
9D000B44  A7C30038   SH V1, 56(S8)
9D000B48  A7C2003C   SH V0, 60(S8)
734:                     SHORT   deltaX, deltaY;
735:                     SHORT   error, stepErrorLT, stepErrorGE;
736:                     SHORT   stepX, stepY;
737:                     SHORT   steep;
738:                     SHORT   temp;
739:                     SHORT   style, type;
740:                 
741:                         #ifndef USE_NONBLOCKING_CONFIG
742:                     while(IsDeviceBusy() != 0) Nop();
743:                 
744:                     /* Ready */
745:                         #else
746:                     if(IsDeviceBusy() != 0)
747:                         return (0);
748:                         #endif
749:                 
750:                     // Move cursor
751:                     MoveTo(x2, y2);
9D000B4C  97C20038   LHU V0, 56(S8)
9D000B50  A78281B0   SH V0, -32336(GP)
9D000B54  97C2003C   LHU V0, 60(S8)
9D000B58  A78281A6   SH V0, -32346(GP)
752:                 
753:                     if(x1 == x2)
9D000B5C  87C30030   LH V1, 48(S8)
9D000B60  87C20038   LH V0, 56(S8)
9D000B64  1462004A   BNE V1, V0, 0x9D000C90
9D000B68  00000000   NOP
754:                     {
755:                         if(y1 > y2)
9D000B6C  87C30034   LH V1, 52(S8)
9D000B70  87C2003C   LH V0, 60(S8)
9D000B74  0043102A   SLT V0, V0, V1
9D000B78  10400007   BEQ V0, ZERO, 0x9D000B98
9D000B7C  00000000   NOP
756:                         {
757:                             temp = y1;
9D000B80  97C20034   LHU V0, 52(S8)
9D000B84  A7C2001C   SH V0, 28(S8)
758:                             y1 = y2;
9D000B88  97C2003C   LHU V0, 60(S8)
9D000B8C  A7C20034   SH V0, 52(S8)
759:                             y2 = temp;
9D000B90  97C2001C   LHU V0, 28(S8)
9D000B94  A7C2003C   SH V0, 60(S8)
760:                         }
761:                 
762:                         style = 0;
9D000B98  A7C0001E   SH ZERO, 30(S8)
763:                         type = 1;
9D000B9C  24020001   ADDIU V0, ZERO, 1
9D000BA0  A7C20020   SH V0, 32(S8)
764:                         for(temp = y1; temp < y2 + 1; temp++)
9D000BA4  97C20034   LHU V0, 52(S8)
9D000BA8  A7C2001C   SH V0, 28(S8)
9D000BAC  0B40031B   J 0x9D000C6C
9D000BB0  00000000   NOP
9D000C60  97C2001C   LHU V0, 28(S8)
9D000C64  24420001   ADDIU V0, V0, 1
9D000C68  A7C2001C   SH V0, 28(S8)
9D000C6C  87C3001C   LH V1, 28(S8)
9D000C70  87C2003C   LH V0, 60(S8)
9D000C74  24420001   ADDIU V0, V0, 1
9D000C78  0062102A   SLT V0, V1, V0
9D000C7C  1440FFCD   BNE V0, ZERO, 0x9D000BB4
9D000C80  00000000   NOP
765:                         {
766:                             if((++style) == _lineType)
9D000BB4  97C2001E   LHU V0, 30(S8)
9D000BB8  24420001   ADDIU V0, V0, 1
9D000BBC  A7C2001E   SH V0, 30(S8)
9D000BC0  878281A2   LH V0, -32350(GP)
9D000BC4  87C3001E   LH V1, 30(S8)
9D000BC8  14620005   BNE V1, V0, 0x9D000BE0
9D000BCC  00000000   NOP
767:                             {
768:                                 type ^= 1;
9D000BD0  97C20020   LHU V0, 32(S8)
9D000BD4  38420001   XORI V0, V0, 1
9D000BD8  A7C20020   SH V0, 32(S8)
769:                                 style = 0;
9D000BDC  A7C0001E   SH ZERO, 30(S8)
770:                             }
771:                 
772:                             if(type)
9D000BE0  87C20020   LH V0, 32(S8)
9D000BE4  1040001E   BEQ V0, ZERO, 0x9D000C60
9D000BE8  00000000   NOP
773:                             {
774:                                 PutPixel(x1, temp);
9D000BEC  87C30030   LH V1, 48(S8)
9D000BF0  87C2001C   LH V0, 28(S8)
9D000BF4  00602021   ADDU A0, V1, ZERO
9D000BF8  00402821   ADDU A1, V0, ZERO
9D000BFC  0F400B3A   JAL PutPixel
9D000C00  00000000   NOP
775:                                 if(_lineThickness)
9D000C04  938281AA   LBU V0, -32342(GP)
9D000C08  10400015   BEQ V0, ZERO, 0x9D000C60
9D000C0C  00000000   NOP
776:                                 {
777:                                     PutPixel(x1 + 1, temp);
9D000C10  97C20030   LHU V0, 48(S8)
9D000C14  24420001   ADDIU V0, V0, 1
9D000C18  3042FFFF   ANDI V0, V0, -1
9D000C1C  7C021620   SEH V0, V0
9D000C20  00401821   ADDU V1, V0, ZERO
9D000C24  87C2001C   LH V0, 28(S8)
9D000C28  00602021   ADDU A0, V1, ZERO
9D000C2C  00402821   ADDU A1, V0, ZERO
9D000C30  0F400B3A   JAL PutPixel
9D000C34  00000000   NOP
778:                                     PutPixel(x1 - 1, temp);
9D000C38  97C20030   LHU V0, 48(S8)
9D000C3C  2442FFFF   ADDIU V0, V0, -1
9D000C40  3042FFFF   ANDI V0, V0, -1
9D000C44  7C021620   SEH V0, V0
9D000C48  00401821   ADDU V1, V0, ZERO
9D000C4C  87C2001C   LH V0, 28(S8)
9D000C50  00602021   ADDU A0, V1, ZERO
9D000C54  00402821   ADDU A1, V0, ZERO
9D000C58  0F400B3A   JAL PutPixel
9D000C5C  00000000   NOP
779:                                 }
780:                             }
781:                         }
782:                 
783:                         return (1);
9D000C84  24020001   ADDIU V0, ZERO, 1
9D000C88  0B40043B   J 0x9D0010EC
9D000C8C  00000000   NOP
784:                     }
785:                 
786:                     if(y1 == y2)
9D000C90  87C30034   LH V1, 52(S8)
9D000C94  87C2003C   LH V0, 60(S8)
9D000C98  14620048   BNE V1, V0, 0x9D000DBC
9D000C9C  00000000   NOP
787:                     {
788:                         if(x1 > x2)
9D000CA0  87C30030   LH V1, 48(S8)
9D000CA4  87C20038   LH V0, 56(S8)
9D000CA8  0043102A   SLT V0, V0, V1
9D000CAC  10400007   BEQ V0, ZERO, 0x9D000CCC
9D000CB0  00000000   NOP
789:                         {
790:                             temp = x1;
9D000CB4  97C20030   LHU V0, 48(S8)
9D000CB8  A7C2001C   SH V0, 28(S8)
791:                             x1 = x2;
9D000CBC  97C20038   LHU V0, 56(S8)
9D000CC0  A7C20030   SH V0, 48(S8)
792:                             x2 = temp;
9D000CC4  97C2001C   LHU V0, 28(S8)
9D000CC8  A7C20038   SH V0, 56(S8)
793:                         }
794:                 
795:                         style = 0;
9D000CCC  A7C0001E   SH ZERO, 30(S8)
796:                         type = 1;
9D000CD0  24020001   ADDIU V0, ZERO, 1
9D000CD4  A7C20020   SH V0, 32(S8)
797:                         for(temp = x1; temp < x2 + 1; temp++)
9D000CD8  97C20030   LHU V0, 48(S8)
9D000CDC  A7C2001C   SH V0, 28(S8)
9D000CE0  0B400366   J 0x9D000D98
9D000CE4  00000000   NOP
9D000D8C  97C2001C   LHU V0, 28(S8)
9D000D90  24420001   ADDIU V0, V0, 1
9D000D94  A7C2001C   SH V0, 28(S8)
9D000D98  87C3001C   LH V1, 28(S8)
9D000D9C  87C20038   LH V0, 56(S8)
9D000DA0  24420001   ADDIU V0, V0, 1
9D000DA4  0062102A   SLT V0, V1, V0
9D000DA8  1440FFCF   BNE V0, ZERO, 0x9D000CE8
9D000DAC  00000000   NOP
798:                         {
799:                             if((++style) == _lineType)
9D000CE8  97C2001E   LHU V0, 30(S8)
9D000CEC  24420001   ADDIU V0, V0, 1
9D000CF0  A7C2001E   SH V0, 30(S8)
9D000CF4  878281A2   LH V0, -32350(GP)
9D000CF8  87C3001E   LH V1, 30(S8)
9D000CFC  14620005   BNE V1, V0, 0x9D000D14
9D000D00  00000000   NOP
800:                             {
801:                                 type ^= 1;
9D000D04  97C20020   LHU V0, 32(S8)
9D000D08  38420001   XORI V0, V0, 1
9D000D0C  A7C20020   SH V0, 32(S8)
802:                                 style = 0;
9D000D10  A7C0001E   SH ZERO, 30(S8)
803:                             }
804:                 
805:                             if(type)
9D000D14  87C20020   LH V0, 32(S8)
9D000D18  1040001C   BEQ V0, ZERO, 0x9D000D8C
9D000D1C  00000000   NOP
806:                             {
807:                                 PutPixel(temp, y1);
9D000D20  87C3001C   LH V1, 28(S8)
9D000D24  87C20034   LH V0, 52(S8)
9D000D28  00602021   ADDU A0, V1, ZERO
9D000D2C  00402821   ADDU A1, V0, ZERO
9D000D30  0F400B3A   JAL PutPixel
9D000D34  00000000   NOP
808:                                 if(_lineThickness)
9D000D38  938281AA   LBU V0, -32342(GP)
9D000D3C  10400013   BEQ V0, ZERO, 0x9D000D8C
9D000D40  00000000   NOP
809:                                 {
810:                                     PutPixel(temp, y1 + 1);
9D000D44  87C3001C   LH V1, 28(S8)
9D000D48  97C20034   LHU V0, 52(S8)
9D000D4C  24420001   ADDIU V0, V0, 1
9D000D50  3042FFFF   ANDI V0, V0, -1
9D000D54  7C021620   SEH V0, V0
9D000D58  00602021   ADDU A0, V1, ZERO
9D000D5C  00402821   ADDU A1, V0, ZERO
9D000D60  0F400B3A   JAL PutPixel
9D000D64  00000000   NOP
811:                                     PutPixel(temp, y1 - 1);
9D000D68  87C3001C   LH V1, 28(S8)
9D000D6C  97C20034   LHU V0, 52(S8)
9D000D70  2442FFFF   ADDIU V0, V0, -1
9D000D74  3042FFFF   ANDI V0, V0, -1
9D000D78  7C021620   SEH V0, V0
9D000D7C  00602021   ADDU A0, V1, ZERO
9D000D80  00402821   ADDU A1, V0, ZERO
9D000D84  0F400B3A   JAL PutPixel
9D000D88  00000000   NOP
812:                                 }
813:                             }
814:                         }
815:                 
816:                         return (1);
9D000DB0  24020001   ADDIU V0, ZERO, 1
9D000DB4  0B40043B   J 0x9D0010EC
9D000DB8  00000000   NOP
817:                     }
818:                 
819:                     stepX = 0;
9D000DBC  A7C00016   SH ZERO, 22(S8)
820:                     deltaX = x2 - x1;
9D000DC0  97C30038   LHU V1, 56(S8)
9D000DC4  97C20030   LHU V0, 48(S8)
9D000DC8  00621023   SUBU V0, V1, V0
9D000DCC  3042FFFF   ANDI V0, V0, -1
9D000DD0  A7C20010   SH V0, 16(S8)
821:                     if(deltaX < 0)
9D000DD4  87C20010   LH V0, 16(S8)
9D000DD8  0441000A   BGEZ V0, 0x9D000E04
9D000DDC  00000000   NOP
822:                     {
823:                         deltaX = -deltaX;
9D000DE0  97C20010   LHU V0, 16(S8)
9D000DE4  00021023   SUBU V0, ZERO, V0
9D000DE8  3042FFFF   ANDI V0, V0, -1
9D000DEC  A7C20010   SH V0, 16(S8)
824:                         --stepX;
9D000DF0  97C20016   LHU V0, 22(S8)
9D000DF4  2442FFFF   ADDIU V0, V0, -1
9D000DF8  A7C20016   SH V0, 22(S8)
9D000DFC  0B400384   J 0x9D000E10
9D000E00  00000000   NOP
825:                     }
826:                     else
827:                     {
828:                         ++stepX;
9D000E04  97C20016   LHU V0, 22(S8)
9D000E08  24420001   ADDIU V0, V0, 1
9D000E0C  A7C20016   SH V0, 22(S8)
829:                     }
830:                 
831:                     stepY = 0;
9D000E10  A7C00018   SH ZERO, 24(S8)
832:                     deltaY = y2 - y1;
9D000E14  97C3003C   LHU V1, 60(S8)
9D000E18  97C20034   LHU V0, 52(S8)
9D000E1C  00621023   SUBU V0, V1, V0
9D000E20  3042FFFF   ANDI V0, V0, -1
9D000E24  A7C20012   SH V0, 18(S8)
833:                     if(deltaY < 0)
9D000E28  87C20012   LH V0, 18(S8)
9D000E2C  0441000A   BGEZ V0, 0x9D000E58
9D000E30  00000000   NOP
834:                     {
835:                         deltaY = -deltaY;
9D000E34  97C20012   LHU V0, 18(S8)
9D000E38  00021023   SUBU V0, ZERO, V0
9D000E3C  3042FFFF   ANDI V0, V0, -1
9D000E40  A7C20012   SH V0, 18(S8)
836:                         --stepY;
9D000E44  97C20018   LHU V0, 24(S8)
9D000E48  2442FFFF   ADDIU V0, V0, -1
9D000E4C  A7C20018   SH V0, 24(S8)
9D000E50  0B400399   J 0x9D000E64
9D000E54  00000000   NOP
837:                     }
838:                     else
839:                     {
840:                         ++stepY;
9D000E58  97C20018   LHU V0, 24(S8)
9D000E5C  24420001   ADDIU V0, V0, 1
9D000E60  A7C20018   SH V0, 24(S8)
841:                     }
842:                 
843:                     steep = 0;
9D000E64  A7C0001A   SH ZERO, 26(S8)
844:                     if(deltaX < deltaY)
9D000E68  87C30010   LH V1, 16(S8)
9D000E6C  87C20012   LH V0, 18(S8)
9D000E70  0062102A   SLT V0, V1, V0
9D000E74  1040001E   BEQ V0, ZERO, 0x9D000EF0
9D000E78  00000000   NOP
845:                     {
846:                         ++steep;
9D000E7C  97C2001A   LHU V0, 26(S8)
9D000E80  24420001   ADDIU V0, V0, 1
9D000E84  A7C2001A   SH V0, 26(S8)
847:                         temp = deltaX;
9D000E88  97C20010   LHU V0, 16(S8)
9D000E8C  A7C2001C   SH V0, 28(S8)
848:                         deltaX = deltaY;
9D000E90  97C20012   LHU V0, 18(S8)
9D000E94  A7C20010   SH V0, 16(S8)
849:                         deltaY = temp;
9D000E98  97C2001C   LHU V0, 28(S8)
9D000E9C  A7C20012   SH V0, 18(S8)
850:                         temp = x1;
9D000EA0  97C20030   LHU V0, 48(S8)
9D000EA4  A7C2001C   SH V0, 28(S8)
851:                         x1 = y1;
9D000EA8  97C20034   LHU V0, 52(S8)
9D000EAC  A7C20030   SH V0, 48(S8)
852:                         y1 = temp;
9D000EB0  97C2001C   LHU V0, 28(S8)
9D000EB4  A7C20034   SH V0, 52(S8)
853:                         temp = stepX;
9D000EB8  97C20016   LHU V0, 22(S8)
9D000EBC  A7C2001C   SH V0, 28(S8)
854:                         stepX = stepY;
9D000EC0  97C20018   LHU V0, 24(S8)
9D000EC4  A7C20016   SH V0, 22(S8)
855:                         stepY = temp;
9D000EC8  97C2001C   LHU V0, 28(S8)
9D000ECC  A7C20018   SH V0, 24(S8)
856:                         PutPixel(y1, x1);
9D000ED0  87C30034   LH V1, 52(S8)
9D000ED4  87C20030   LH V0, 48(S8)
9D000ED8  00602021   ADDU A0, V1, ZERO
9D000EDC  00402821   ADDU A1, V0, ZERO
9D000EE0  0F400B3A   JAL PutPixel
9D000EE4  00000000   NOP
9D000EE8  0B4003C2   J 0x9D000F08
9D000EEC  00000000   NOP
857:                     }
858:                     else
859:                     {
860:                         PutPixel(x1, y1);
9D000EF0  87C30030   LH V1, 48(S8)
9D000EF4  87C20034   LH V0, 52(S8)
9D000EF8  00602021   ADDU A0, V1, ZERO
9D000EFC  00402821   ADDU A1, V0, ZERO
9D000F00  0F400B3A   JAL PutPixel
9D000F04  00000000   NOP
861:                     }
862:                 
863:                     // If the current error greater or equal zero
864:                     stepErrorGE = deltaX << 1;
9D000F08  87C20010   LH V0, 16(S8)
9D000F0C  00021040   SLL V0, V0, 1
9D000F10  A7C20022   SH V0, 34(S8)
865:                 
866:                     // If the current error less than zero
867:                     stepErrorLT = deltaY << 1;
9D000F14  87C20012   LH V0, 18(S8)
9D000F18  00021040   SLL V0, V0, 1
9D000F1C  A7C20024   SH V0, 36(S8)
868:                 
869:                     // Error for the first pixel
870:                     error = stepErrorLT - deltaX;
9D000F20  97C30024   LHU V1, 36(S8)
9D000F24  97C20010   LHU V0, 16(S8)
9D000F28  00621023   SUBU V0, V1, V0
9D000F2C  3042FFFF   ANDI V0, V0, -1
9D000F30  A7C20014   SH V0, 20(S8)
871:                 
872:                     style = 0;
9D000F34  A7C0001E   SH ZERO, 30(S8)
873:                     type = 1;
9D000F38  24020001   ADDIU V0, ZERO, 1
9D000F3C  A7C20020   SH V0, 32(S8)
874:                 
875:                     while(--deltaX >= 0)
9D000F40  0B400434   J 0x9D0010D0
9D000F44  00000000   NOP
9D0010D0  97C20010   LHU V0, 16(S8)
9D0010D4  2442FFFF   ADDIU V0, V0, -1
9D0010D8  A7C20010   SH V0, 16(S8)
9D0010DC  87C20010   LH V0, 16(S8)
9D0010E0  0441FF99   BGEZ V0, 0x9D000F48
9D0010E4  00000000   NOP
876:                     {
877:                         if(error >= 0)
9D000F48  87C20014   LH V0, 20(S8)
9D000F4C  0440000B   BLTZ V0, 0x9D000F7C
9D000F50  00000000   NOP
878:                         {
879:                             y1 += stepY;
9D000F54  97C30034   LHU V1, 52(S8)
9D000F58  97C20018   LHU V0, 24(S8)
9D000F5C  00621021   ADDU V0, V1, V0
9D000F60  3042FFFF   ANDI V0, V0, -1
9D000F64  A7C20034   SH V0, 52(S8)
880:                             error -= stepErrorGE;
9D000F68  97C30014   LHU V1, 20(S8)
9D000F6C  97C20022   LHU V0, 34(S8)
9D000F70  00621023   SUBU V0, V1, V0
9D000F74  3042FFFF   ANDI V0, V0, -1
9D000F78  A7C20014   SH V0, 20(S8)
881:                         }
882:                 
883:                         x1 += stepX;
9D000F7C  97C30030   LHU V1, 48(S8)
9D000F80  97C20016   LHU V0, 22(S8)
9D000F84  00621021   ADDU V0, V1, V0
9D000F88  3042FFFF   ANDI V0, V0, -1
9D000F8C  A7C20030   SH V0, 48(S8)
884:                         error += stepErrorLT;
9D000F90  97C30014   LHU V1, 20(S8)
9D000F94  97C20024   LHU V0, 36(S8)
9D000F98  00621021   ADDU V0, V1, V0
9D000F9C  3042FFFF   ANDI V0, V0, -1
9D000FA0  A7C20014   SH V0, 20(S8)
885:                 
886:                         if((++style) == _lineType)
9D000FA4  97C2001E   LHU V0, 30(S8)
9D000FA8  24420001   ADDIU V0, V0, 1
9D000FAC  A7C2001E   SH V0, 30(S8)
9D000FB0  878281A2   LH V0, -32350(GP)
9D000FB4  87C3001E   LH V1, 30(S8)
9D000FB8  14620005   BNE V1, V0, 0x9D000FD0
9D000FBC  00000000   NOP
887:                         {
888:                             type ^= 1;
9D000FC0  97C20020   LHU V0, 32(S8)
9D000FC4  38420001   XORI V0, V0, 1
9D000FC8  A7C20020   SH V0, 32(S8)
889:                             style = 0;
9D000FCC  A7C0001E   SH ZERO, 30(S8)
890:                         }
891:                 
892:                         if(type)
9D000FD0  87C20020   LH V0, 32(S8)
9D000FD4  1040003E   BEQ V0, ZERO, 0x9D0010D0
9D000FD8  00000000   NOP
893:                         {
894:                             if(steep)
9D000FDC  87C2001A   LH V0, 26(S8)
9D000FE0  10400020   BEQ V0, ZERO, 0x9D001064
9D000FE4  00000000   NOP
895:                             {
896:                                 PutPixel(y1, x1);
9D000FE8  87C30034   LH V1, 52(S8)
9D000FEC  87C20030   LH V0, 48(S8)
9D000FF0  00602021   ADDU A0, V1, ZERO
9D000FF4  00402821   ADDU A1, V0, ZERO
9D000FF8  0F400B3A   JAL PutPixel
9D000FFC  00000000   NOP
897:                                 if(_lineThickness)
9D001000  938281AA   LBU V0, -32342(GP)
9D001004  10400032   BEQ V0, ZERO, 0x9D0010D0
9D001008  00000000   NOP
898:                                 {
899:                                     PutPixel(y1 + 1, x1);
9D00100C  97C20034   LHU V0, 52(S8)
9D001010  24420001   ADDIU V0, V0, 1
9D001014  3042FFFF   ANDI V0, V0, -1
9D001018  7C021620   SEH V0, V0
9D00101C  00401821   ADDU V1, V0, ZERO
9D001020  87C20030   LH V0, 48(S8)
9D001024  00602021   ADDU A0, V1, ZERO
9D001028  00402821   ADDU A1, V0, ZERO
9D00102C  0F400B3A   JAL PutPixel
9D001030  00000000   NOP
900:                                     PutPixel(y1 - 1, x1);
9D001034  97C20034   LHU V0, 52(S8)
9D001038  2442FFFF   ADDIU V0, V0, -1
9D00103C  3042FFFF   ANDI V0, V0, -1
9D001040  7C021620   SEH V0, V0
9D001044  00401821   ADDU V1, V0, ZERO
9D001048  87C20030   LH V0, 48(S8)
9D00104C  00602021   ADDU A0, V1, ZERO
9D001050  00402821   ADDU A1, V0, ZERO
9D001054  0F400B3A   JAL PutPixel
9D001058  00000000   NOP
9D00105C  0B400434   J 0x9D0010D0
9D001060  00000000   NOP
901:                                 }
902:                             }
903:                             else
904:                             {
905:                                 PutPixel(x1, y1);
9D001064  87C30030   LH V1, 48(S8)
9D001068  87C20034   LH V0, 52(S8)
9D00106C  00602021   ADDU A0, V1, ZERO
9D001070  00402821   ADDU A1, V0, ZERO
9D001074  0F400B3A   JAL PutPixel
9D001078  00000000   NOP
906:                                 if(_lineThickness)
9D00107C  938281AA   LBU V0, -32342(GP)
9D001080  10400013   BEQ V0, ZERO, 0x9D0010D0
9D001084  00000000   NOP
907:                                 {
908:                                     PutPixel(x1, y1 + 1);
9D001088  87C30030   LH V1, 48(S8)
9D00108C  97C20034   LHU V0, 52(S8)
9D001090  24420001   ADDIU V0, V0, 1
9D001094  3042FFFF   ANDI V0, V0, -1
9D001098  7C021620   SEH V0, V0
9D00109C  00602021   ADDU A0, V1, ZERO
9D0010A0  00402821   ADDU A1, V0, ZERO
9D0010A4  0F400B3A   JAL PutPixel
9D0010A8  00000000   NOP
909:                                     PutPixel(x1, y1 - 1);
9D0010AC  87C30030   LH V1, 48(S8)
9D0010B0  97C20034   LHU V0, 52(S8)
9D0010B4  2442FFFF   ADDIU V0, V0, -1
9D0010B8  3042FFFF   ANDI V0, V0, -1
9D0010BC  7C021620   SEH V0, V0
9D0010C0  00602021   ADDU A0, V1, ZERO
9D0010C4  00402821   ADDU A1, V0, ZERO
9D0010C8  0F400B3A   JAL PutPixel
9D0010CC  00000000   NOP
910:                                 }
911:                             }
912:                         }
913:                     }   // end of while
914:                 
915:                     return (1);
9D0010E8  24020001   ADDIU V0, ZERO, 1
916:                 }
9D0010EC  03C0E821   ADDU SP, S8, ZERO
9D0010F0  8FBF002C   LW RA, 44(SP)
9D0010F4  8FBE0028   LW S8, 40(SP)
9D0010F8  27BD0030   ADDIU SP, SP, 48
9D0010FC  03E00008   JR RA
9D001100  00000000   NOP
917:                 
918:                 #endif
919:                 
920:                 /*********************************************************************
921:                 * Function: WORD Bevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
922:                 *
923:                 * PreCondition: None
924:                 *
925:                 * Input: x1, y1 - coordinate position of the upper left center of the 
926:                 * 				  circle that draws the rounded corners,
927:                 *		 x2, y2 - coordinate position of the lower right center of the 
928:                 * 				  circle that draws the rounded corners,
929:                 *        rad - defines the redius of the circle,
930:                 *
931:                 * Output: For NON-Blocking configuration:
932:                 *         - Returns 0 when device is busy and the shape is not yet completely drawn.
933:                 *         - Returns 1 when the shape is completely drawn.
934:                 *         For Blocking configuration:
935:                 *         - Always return 1.
936:                 *
937:                 * Overview: Draws a beveled figure on the screen. 
938:                 *           For a pure circular object x1 = x2 and y1 = y2. 
939:                 *           For a rectangular object radius = 0.
940:                 *
941:                 * Note: none
942:                 *
943:                 ********************************************************************/
944:                 WORD Bevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
945:                 {
9D001104  27BDFFD0   ADDIU SP, SP, -48
9D001108  AFBF002C   SW RA, 44(SP)
9D00110C  AFBE0028   SW S8, 40(SP)
9D001110  03A0F021   ADDU S8, SP, ZERO
9D001114  00804021   ADDU T0, A0, ZERO
9D001118  00C02021   ADDU A0, A2, ZERO
9D00111C  00E01821   ADDU V1, A3, ZERO
9D001120  8FC20040   LW V0, 64(S8)
9D001124  A7C80030   SH T0, 48(S8)
9D001128  A7C50034   SH A1, 52(S8)
9D00112C  A7C40038   SH A0, 56(S8)
9D001130  A7C3003C   SH V1, 60(S8)
9D001134  A7C20020   SH V0, 32(S8)
946:                     SHORT       style, type, xLimit, xPos, yPos, error;
947:                     DWORD_VAL   temp;
948:                 
949:                     #ifndef USE_NONBLOCKING_CONFIG
950:                     while(IsDeviceBusy() != 0) Nop();
951:                 
952:                     /* Ready */
953:                     #else
954:                     if(IsDeviceBusy() != 0)
955:                         return (0);
956:                     #endif
957:                     temp.Val = SIN45 * rad;
9D001138  87C30020   LH V1, 32(S8)
9D00113C  3402B505   ORI V0, ZERO, -19195
9D001140  70621002   MUL V0, V1, V0
9D001144  AFC2001C   SW V0, 28(S8)
958:                     xLimit = temp.w[1] + 1;
9D001148  97C2001E   LHU V0, 30(S8)
9D00114C  24420001   ADDIU V0, V0, 1
9D001150  3042FFFF   ANDI V0, V0, -1
9D001154  A7C2001A   SH V0, 26(S8)
959:                     temp.Val = (DWORD) (ONEP25 - ((LONG) rad << 16));
9D001158  87C20020   LH V0, 32(S8)
9D00115C  00021400   SLL V0, V0, 16
9D001160  3C030001   LUI V1, 1
9D001164  34634000   ORI V1, V1, 16384
9D001168  00621023   SUBU V0, V1, V0
9D00116C  AFC2001C   SW V0, 28(S8)
960:                     error = (SHORT) (temp.w[1]);
9D001170  97C2001E   LHU V0, 30(S8)
9D001174  A7C20018   SH V0, 24(S8)
961:                     yPos = rad;
9D001178  97C20020   LHU V0, 32(S8)
9D00117C  A7C20016   SH V0, 22(S8)
962:                 
963:                     style = 0;
9D001180  A7C00010   SH ZERO, 16(S8)
964:                     type = 1;
9D001184  24020001   ADDIU V0, ZERO, 1
9D001188  A7C20012   SH V0, 18(S8)
965:                 
966:                     if(rad)
9D00118C  87C20020   LH V0, 32(S8)
9D001190  104001C2   BEQ V0, ZERO, 0x9D00189C
9D001194  00000000   NOP
967:                     {
968:                         for(xPos = 0; xPos <= xLimit; xPos++)
9D001198  A7C00014   SH ZERO, 20(S8)
9D00119C  0B400622   J 0x9D001888
9D0011A0  00000000   NOP
9D00187C  97C20014   LHU V0, 20(S8)
9D001880  24420001   ADDIU V0, V0, 1
9D001884  A7C20014   SH V0, 20(S8)
9D001888  87C30014   LH V1, 20(S8)
9D00188C  87C2001A   LH V0, 26(S8)
9D001890  0043102A   SLT V0, V0, V1
9D001894  1040FE43   BEQ V0, ZERO, 0x9D0011A4
9D001898  00000000   NOP
969:                         {
970:                             if((++style) == _lineType)
9D0011A4  97C20010   LHU V0, 16(S8)
9D0011A8  24420001   ADDIU V0, V0, 1
9D0011AC  A7C20010   SH V0, 16(S8)
9D0011B0  878281A2   LH V0, -32350(GP)
9D0011B4  87C30010   LH V1, 16(S8)
9D0011B8  14620005   BNE V1, V0, 0x9D0011D0
9D0011BC  00000000   NOP
971:                             {
972:                                 type ^= 1;
9D0011C0  97C20012   LHU V0, 18(S8)
9D0011C4  38420001   XORI V0, V0, 1
9D0011C8  A7C20012   SH V0, 18(S8)
973:                                 style = 0;
9D0011CC  A7C00010   SH ZERO, 16(S8)
974:                             }
975:                 
976:                             if(type)
9D0011D0  87C20012   LH V0, 18(S8)
9D0011D4  1040018C   BEQ V0, ZERO, 0x9D001808
9D0011D8  00000000   NOP
977:                             {
978:                                 PutPixel(x2 + xPos, y1 - yPos);         // 1st quadrant
9D0011DC  97C30038   LHU V1, 56(S8)
9D0011E0  97C20014   LHU V0, 20(S8)
9D0011E4  00621021   ADDU V0, V1, V0
9D0011E8  3042FFFF   ANDI V0, V0, -1
9D0011EC  7C021620   SEH V0, V0
9D0011F0  00401821   ADDU V1, V0, ZERO
9D0011F4  97C40034   LHU A0, 52(S8)
9D0011F8  97C20016   LHU V0, 22(S8)
9D0011FC  00821023   SUBU V0, A0, V0
9D001200  3042FFFF   ANDI V0, V0, -1
9D001204  7C021620   SEH V0, V0
9D001208  00602021   ADDU A0, V1, ZERO
9D00120C  00402821   ADDU A1, V0, ZERO
9D001210  0F400B3A   JAL PutPixel
9D001214  00000000   NOP
979:                                 PutPixel(x2 + yPos, y1 - xPos);
9D001218  97C30038   LHU V1, 56(S8)
9D00121C  97C20016   LHU V0, 22(S8)
9D001220  00621021   ADDU V0, V1, V0
9D001224  3042FFFF   ANDI V0, V0, -1
9D001228  7C021620   SEH V0, V0
9D00122C  00401821   ADDU V1, V0, ZERO
9D001230  97C40034   LHU A0, 52(S8)
9D001234  97C20014   LHU V0, 20(S8)
9D001238  00821023   SUBU V0, A0, V0
9D00123C  3042FFFF   ANDI V0, V0, -1
9D001240  7C021620   SEH V0, V0
9D001244  00602021   ADDU A0, V1, ZERO
9D001248  00402821   ADDU A1, V0, ZERO
9D00124C  0F400B3A   JAL PutPixel
9D001250  00000000   NOP
980:                                 PutPixel(x2 + xPos, y2 + yPos);         // 2nd quadrant
9D001254  97C30038   LHU V1, 56(S8)
9D001258  97C20014   LHU V0, 20(S8)
9D00125C  00621021   ADDU V0, V1, V0
9D001260  3042FFFF   ANDI V0, V0, -1
9D001264  7C021620   SEH V0, V0
9D001268  00401821   ADDU V1, V0, ZERO
9D00126C  97C4003C   LHU A0, 60(S8)
9D001270  97C20016   LHU V0, 22(S8)
9D001274  00821021   ADDU V0, A0, V0
9D001278  3042FFFF   ANDI V0, V0, -1
9D00127C  7C021620   SEH V0, V0
9D001280  00602021   ADDU A0, V1, ZERO
9D001284  00402821   ADDU A1, V0, ZERO
9D001288  0F400B3A   JAL PutPixel
9D00128C  00000000   NOP
981:                                 PutPixel(x2 + yPos, y2 + xPos);
9D001290  97C30038   LHU V1, 56(S8)
9D001294  97C20016   LHU V0, 22(S8)
9D001298  00621021   ADDU V0, V1, V0
9D00129C  3042FFFF   ANDI V0, V0, -1
9D0012A0  7C021620   SEH V0, V0
9D0012A4  00401821   ADDU V1, V0, ZERO
9D0012A8  97C4003C   LHU A0, 60(S8)
9D0012AC  97C20014   LHU V0, 20(S8)
9D0012B0  00821021   ADDU V0, A0, V0
9D0012B4  3042FFFF   ANDI V0, V0, -1
9D0012B8  7C021620   SEH V0, V0
9D0012BC  00602021   ADDU A0, V1, ZERO
9D0012C0  00402821   ADDU A1, V0, ZERO
9D0012C4  0F400B3A   JAL PutPixel
9D0012C8  00000000   NOP
982:                                 PutPixel(x1 - xPos, y2 + yPos);         // 3rd quadrant
9D0012CC  97C30030   LHU V1, 48(S8)
9D0012D0  97C20014   LHU V0, 20(S8)
9D0012D4  00621023   SUBU V0, V1, V0
9D0012D8  3042FFFF   ANDI V0, V0, -1
9D0012DC  7C021620   SEH V0, V0
9D0012E0  00401821   ADDU V1, V0, ZERO
9D0012E4  97C4003C   LHU A0, 60(S8)
9D0012E8  97C20016   LHU V0, 22(S8)
9D0012EC  00821021   ADDU V0, A0, V0
9D0012F0  3042FFFF   ANDI V0, V0, -1
9D0012F4  7C021620   SEH V0, V0
9D0012F8  00602021   ADDU A0, V1, ZERO
9D0012FC  00402821   ADDU A1, V0, ZERO
9D001300  0F400B3A   JAL PutPixel
9D001304  00000000   NOP
983:                                 PutPixel(x1 - yPos, y2 + xPos);
9D001308  97C30030   LHU V1, 48(S8)
9D00130C  97C20016   LHU V0, 22(S8)
9D001310  00621023   SUBU V0, V1, V0
9D001314  3042FFFF   ANDI V0, V0, -1
9D001318  7C021620   SEH V0, V0
9D00131C  00401821   ADDU V1, V0, ZERO
9D001320  97C4003C   LHU A0, 60(S8)
9D001324  97C20014   LHU V0, 20(S8)
9D001328  00821021   ADDU V0, A0, V0
9D00132C  3042FFFF   ANDI V0, V0, -1
9D001330  7C021620   SEH V0, V0
9D001334  00602021   ADDU A0, V1, ZERO
9D001338  00402821   ADDU A1, V0, ZERO
9D00133C  0F400B3A   JAL PutPixel
9D001340  00000000   NOP
984:                                 PutPixel(x1 - yPos, y1 - xPos);         // 4th quadrant
9D001344  97C30030   LHU V1, 48(S8)
9D001348  97C20016   LHU V0, 22(S8)
9D00134C  00621023   SUBU V0, V1, V0
9D001350  3042FFFF   ANDI V0, V0, -1
9D001354  7C021620   SEH V0, V0
9D001358  00401821   ADDU V1, V0, ZERO
9D00135C  97C40034   LHU A0, 52(S8)
9D001360  97C20014   LHU V0, 20(S8)
9D001364  00821023   SUBU V0, A0, V0
9D001368  3042FFFF   ANDI V0, V0, -1
9D00136C  7C021620   SEH V0, V0
9D001370  00602021   ADDU A0, V1, ZERO
9D001374  00402821   ADDU A1, V0, ZERO
9D001378  0F400B3A   JAL PutPixel
9D00137C  00000000   NOP
985:                                 PutPixel(x1 - xPos, y1 - yPos);
9D001380  97C30030   LHU V1, 48(S8)
9D001384  97C20014   LHU V0, 20(S8)
9D001388  00621023   SUBU V0, V1, V0
9D00138C  3042FFFF   ANDI V0, V0, -1
9D001390  7C021620   SEH V0, V0
9D001394  00401821   ADDU V1, V0, ZERO
9D001398  97C40034   LHU A0, 52(S8)
9D00139C  97C20016   LHU V0, 22(S8)
9D0013A0  00821023   SUBU V0, A0, V0
9D0013A4  3042FFFF   ANDI V0, V0, -1
9D0013A8  7C021620   SEH V0, V0
9D0013AC  00602021   ADDU A0, V1, ZERO
9D0013B0  00402821   ADDU A1, V0, ZERO
9D0013B4  0F400B3A   JAL PutPixel
9D0013B8  00000000   NOP
986:                 
987:                                 if(_lineThickness)
9D0013BC  938281AA   LBU V0, -32342(GP)
9D0013C0  10400111   BEQ V0, ZERO, 0x9D001808
9D0013C4  00000000   NOP
988:                                 {
989:                                     PutPixel(x2 + xPos, y1 - yPos - 1); // 1st quadrant
9D0013C8  97C30038   LHU V1, 56(S8)
9D0013CC  97C20014   LHU V0, 20(S8)
9D0013D0  00621021   ADDU V0, V1, V0
9D0013D4  3042FFFF   ANDI V0, V0, -1
9D0013D8  7C021620   SEH V0, V0
9D0013DC  00401821   ADDU V1, V0, ZERO
9D0013E0  97C40034   LHU A0, 52(S8)
9D0013E4  97C20016   LHU V0, 22(S8)
9D0013E8  00821023   SUBU V0, A0, V0
9D0013EC  3042FFFF   ANDI V0, V0, -1
9D0013F0  2442FFFF   ADDIU V0, V0, -1
9D0013F4  3042FFFF   ANDI V0, V0, -1
9D0013F8  7C021620   SEH V0, V0
9D0013FC  00602021   ADDU A0, V1, ZERO
9D001400  00402821   ADDU A1, V0, ZERO
9D001404  0F400B3A   JAL PutPixel
9D001408  00000000   NOP
990:                                     PutPixel(x2 + xPos, y1 - yPos + 1);
9D00140C  97C30038   LHU V1, 56(S8)
9D001410  97C20014   LHU V0, 20(S8)
9D001414  00621021   ADDU V0, V1, V0
9D001418  3042FFFF   ANDI V0, V0, -1
9D00141C  7C021620   SEH V0, V0
9D001420  00401821   ADDU V1, V0, ZERO
9D001424  97C40034   LHU A0, 52(S8)
9D001428  97C20016   LHU V0, 22(S8)
9D00142C  00821023   SUBU V0, A0, V0
9D001430  3042FFFF   ANDI V0, V0, -1
9D001434  24420001   ADDIU V0, V0, 1
9D001438  3042FFFF   ANDI V0, V0, -1
9D00143C  7C021620   SEH V0, V0
9D001440  00602021   ADDU A0, V1, ZERO
9D001444  00402821   ADDU A1, V0, ZERO
9D001448  0F400B3A   JAL PutPixel
9D00144C  00000000   NOP
991:                                     PutPixel(x2 + yPos + 1, y1 - xPos);
9D001450  97C30038   LHU V1, 56(S8)
9D001454  97C20016   LHU V0, 22(S8)
9D001458  00621021   ADDU V0, V1, V0
9D00145C  3042FFFF   ANDI V0, V0, -1
9D001460  24420001   ADDIU V0, V0, 1
9D001464  3042FFFF   ANDI V0, V0, -1
9D001468  7C021620   SEH V0, V0
9D00146C  00401821   ADDU V1, V0, ZERO
9D001470  97C40034   LHU A0, 52(S8)
9D001474  97C20014   LHU V0, 20(S8)
9D001478  00821023   SUBU V0, A0, V0
9D00147C  3042FFFF   ANDI V0, V0, -1
9D001480  7C021620   SEH V0, V0
9D001484  00602021   ADDU A0, V1, ZERO
9D001488  00402821   ADDU A1, V0, ZERO
9D00148C  0F400B3A   JAL PutPixel
9D001490  00000000   NOP
992:                                     PutPixel(x2 + yPos - 1, y1 - xPos);
9D001494  97C30038   LHU V1, 56(S8)
9D001498  97C20016   LHU V0, 22(S8)
9D00149C  00621021   ADDU V0, V1, V0
9D0014A0  3042FFFF   ANDI V0, V0, -1
9D0014A4  2442FFFF   ADDIU V0, V0, -1
9D0014A8  3042FFFF   ANDI V0, V0, -1
9D0014AC  7C021620   SEH V0, V0
9D0014B0  00401821   ADDU V1, V0, ZERO
9D0014B4  97C40034   LHU A0, 52(S8)
9D0014B8  97C20014   LHU V0, 20(S8)
9D0014BC  00821023   SUBU V0, A0, V0
9D0014C0  3042FFFF   ANDI V0, V0, -1
9D0014C4  7C021620   SEH V0, V0
9D0014C8  00602021   ADDU A0, V1, ZERO
9D0014CC  00402821   ADDU A1, V0, ZERO
9D0014D0  0F400B3A   JAL PutPixel
9D0014D4  00000000   NOP
993:                                     PutPixel(x2 + xPos, y2 + yPos - 1); // 2nd quadrant
9D0014D8  97C30038   LHU V1, 56(S8)
9D0014DC  97C20014   LHU V0, 20(S8)
9D0014E0  00621021   ADDU V0, V1, V0
9D0014E4  3042FFFF   ANDI V0, V0, -1
9D0014E8  7C021620   SEH V0, V0
9D0014EC  00401821   ADDU V1, V0, ZERO
9D0014F0  97C4003C   LHU A0, 60(S8)
9D0014F4  97C20016   LHU V0, 22(S8)
9D0014F8  00821021   ADDU V0, A0, V0
9D0014FC  3042FFFF   ANDI V0, V0, -1
9D001500  2442FFFF   ADDIU V0, V0, -1
9D001504  3042FFFF   ANDI V0, V0, -1
9D001508  7C021620   SEH V0, V0
9D00150C  00602021   ADDU A0, V1, ZERO
9D001510  00402821   ADDU A1, V0, ZERO
9D001514  0F400B3A   JAL PutPixel
9D001518  00000000   NOP
994:                                     PutPixel(x2 + xPos, y2 + yPos + 1);
9D00151C  97C30038   LHU V1, 56(S8)
9D001520  97C20014   LHU V0, 20(S8)
9D001524  00621021   ADDU V0, V1, V0
9D001528  3042FFFF   ANDI V0, V0, -1
9D00152C  7C021620   SEH V0, V0
9D001530  00401821   ADDU V1, V0, ZERO
9D001534  97C4003C   LHU A0, 60(S8)
9D001538  97C20016   LHU V0, 22(S8)
9D00153C  00821021   ADDU V0, A0, V0
9D001540  3042FFFF   ANDI V0, V0, -1
9D001544  24420001   ADDIU V0, V0, 1
9D001548  3042FFFF   ANDI V0, V0, -1
9D00154C  7C021620   SEH V0, V0
9D001550  00602021   ADDU A0, V1, ZERO
9D001554  00402821   ADDU A1, V0, ZERO
9D001558  0F400B3A   JAL PutPixel
9D00155C  00000000   NOP
995:                                     PutPixel(x2 + yPos + 1, y2 + xPos);
9D001560  97C30038   LHU V1, 56(S8)
9D001564  97C20016   LHU V0, 22(S8)
9D001568  00621021   ADDU V0, V1, V0
9D00156C  3042FFFF   ANDI V0, V0, -1
9D001570  24420001   ADDIU V0, V0, 1
9D001574  3042FFFF   ANDI V0, V0, -1
9D001578  7C021620   SEH V0, V0
9D00157C  00401821   ADDU V1, V0, ZERO
9D001580  97C4003C   LHU A0, 60(S8)
9D001584  97C20014   LHU V0, 20(S8)
9D001588  00821021   ADDU V0, A0, V0
9D00158C  3042FFFF   ANDI V0, V0, -1
9D001590  7C021620   SEH V0, V0
9D001594  00602021   ADDU A0, V1, ZERO
9D001598  00402821   ADDU A1, V0, ZERO
9D00159C  0F400B3A   JAL PutPixel
9D0015A0  00000000   NOP
996:                                     PutPixel(x2 + yPos - 1, y2 + xPos);
9D0015A4  97C30038   LHU V1, 56(S8)
9D0015A8  97C20016   LHU V0, 22(S8)
9D0015AC  00621021   ADDU V0, V1, V0
9D0015B0  3042FFFF   ANDI V0, V0, -1
9D0015B4  2442FFFF   ADDIU V0, V0, -1
9D0015B8  3042FFFF   ANDI V0, V0, -1
9D0015BC  7C021620   SEH V0, V0
9D0015C0  00401821   ADDU V1, V0, ZERO
9D0015C4  97C4003C   LHU A0, 60(S8)
9D0015C8  97C20014   LHU V0, 20(S8)
9D0015CC  00821021   ADDU V0, A0, V0
9D0015D0  3042FFFF   ANDI V0, V0, -1
9D0015D4  7C021620   SEH V0, V0
9D0015D8  00602021   ADDU A0, V1, ZERO
9D0015DC  00402821   ADDU A1, V0, ZERO
9D0015E0  0F400B3A   JAL PutPixel
9D0015E4  00000000   NOP
997:                                     PutPixel(x1 - xPos, y2 + yPos - 1); // 3rd quadrant
9D0015E8  97C30030   LHU V1, 48(S8)
9D0015EC  97C20014   LHU V0, 20(S8)
9D0015F0  00621023   SUBU V0, V1, V0
9D0015F4  3042FFFF   ANDI V0, V0, -1
9D0015F8  7C021620   SEH V0, V0
9D0015FC  00401821   ADDU V1, V0, ZERO
9D001600  97C4003C   LHU A0, 60(S8)
9D001604  97C20016   LHU V0, 22(S8)
9D001608  00821021   ADDU V0, A0, V0
9D00160C  3042FFFF   ANDI V0, V0, -1
9D001610  2442FFFF   ADDIU V0, V0, -1
9D001614  3042FFFF   ANDI V0, V0, -1
9D001618  7C021620   SEH V0, V0
9D00161C  00602021   ADDU A0, V1, ZERO
9D001620  00402821   ADDU A1, V0, ZERO
9D001624  0F400B3A   JAL PutPixel
9D001628  00000000   NOP
998:                                     PutPixel(x1 - xPos, y2 + yPos + 1);
9D00162C  97C30030   LHU V1, 48(S8)
9D001630  97C20014   LHU V0, 20(S8)
9D001634  00621023   SUBU V0, V1, V0
9D001638  3042FFFF   ANDI V0, V0, -1
9D00163C  7C021620   SEH V0, V0
9D001640  00401821   ADDU V1, V0, ZERO
9D001644  97C4003C   LHU A0, 60(S8)
9D001648  97C20016   LHU V0, 22(S8)
9D00164C  00821021   ADDU V0, A0, V0
9D001650  3042FFFF   ANDI V0, V0, -1
9D001654  24420001   ADDIU V0, V0, 1
9D001658  3042FFFF   ANDI V0, V0, -1
9D00165C  7C021620   SEH V0, V0
9D001660  00602021   ADDU A0, V1, ZERO
9D001664  00402821   ADDU A1, V0, ZERO
9D001668  0F400B3A   JAL PutPixel
9D00166C  00000000   NOP
999:                                     PutPixel(x1 - yPos + 1, y2 + xPos);
9D001670  97C30030   LHU V1, 48(S8)
9D001674  97C20016   LHU V0, 22(S8)
9D001678  00621023   SUBU V0, V1, V0
9D00167C  3042FFFF   ANDI V0, V0, -1
9D001680  24420001   ADDIU V0, V0, 1
9D001684  3042FFFF   ANDI V0, V0, -1
9D001688  7C021620   SEH V0, V0
9D00168C  00401821   ADDU V1, V0, ZERO
9D001690  97C4003C   LHU A0, 60(S8)
9D001694  97C20014   LHU V0, 20(S8)
9D001698  00821021   ADDU V0, A0, V0
9D00169C  3042FFFF   ANDI V0, V0, -1
9D0016A0  7C021620   SEH V0, V0
9D0016A4  00602021   ADDU A0, V1, ZERO
9D0016A8  00402821   ADDU A1, V0, ZERO
9D0016AC  0F400B3A   JAL PutPixel
9D0016B0  00000000   NOP
1000:                                    PutPixel(x1 - yPos - 1, y2 + xPos);
9D0016B4  97C30030   LHU V1, 48(S8)
9D0016B8  97C20016   LHU V0, 22(S8)
9D0016BC  00621023   SUBU V0, V1, V0
9D0016C0  3042FFFF   ANDI V0, V0, -1
9D0016C4  2442FFFF   ADDIU V0, V0, -1
9D0016C8  3042FFFF   ANDI V0, V0, -1
9D0016CC  7C021620   SEH V0, V0
9D0016D0  00401821   ADDU V1, V0, ZERO
9D0016D4  97C4003C   LHU A0, 60(S8)
9D0016D8  97C20014   LHU V0, 20(S8)
9D0016DC  00821021   ADDU V0, A0, V0
9D0016E0  3042FFFF   ANDI V0, V0, -1
9D0016E4  7C021620   SEH V0, V0
9D0016E8  00602021   ADDU A0, V1, ZERO
9D0016EC  00402821   ADDU A1, V0, ZERO
9D0016F0  0F400B3A   JAL PutPixel
9D0016F4  00000000   NOP
1001:                                    PutPixel(x1 - yPos + 1, y1 - xPos); // 4th quadrant
9D0016F8  97C30030   LHU V1, 48(S8)
9D0016FC  97C20016   LHU V0, 22(S8)
9D001700  00621023   SUBU V0, V1, V0
9D001704  3042FFFF   ANDI V0, V0, -1
9D001708  24420001   ADDIU V0, V0, 1
9D00170C  3042FFFF   ANDI V0, V0, -1
9D001710  7C021620   SEH V0, V0
9D001714  00401821   ADDU V1, V0, ZERO
9D001718  97C40034   LHU A0, 52(S8)
9D00171C  97C20014   LHU V0, 20(S8)
9D001720  00821023   SUBU V0, A0, V0
9D001724  3042FFFF   ANDI V0, V0, -1
9D001728  7C021620   SEH V0, V0
9D00172C  00602021   ADDU A0, V1, ZERO
9D001730  00402821   ADDU A1, V0, ZERO
9D001734  0F400B3A   JAL PutPixel
9D001738  00000000   NOP
1002:                                    PutPixel(x1 - yPos - 1, y1 - xPos);
9D00173C  97C30030   LHU V1, 48(S8)
9D001740  97C20016   LHU V0, 22(S8)
9D001744  00621023   SUBU V0, V1, V0
9D001748  3042FFFF   ANDI V0, V0, -1
9D00174C  2442FFFF   ADDIU V0, V0, -1
9D001750  3042FFFF   ANDI V0, V0, -1
9D001754  7C021620   SEH V0, V0
9D001758  00401821   ADDU V1, V0, ZERO
9D00175C  97C40034   LHU A0, 52(S8)
9D001760  97C20014   LHU V0, 20(S8)
9D001764  00821023   SUBU V0, A0, V0
9D001768  3042FFFF   ANDI V0, V0, -1
9D00176C  7C021620   SEH V0, V0
9D001770  00602021   ADDU A0, V1, ZERO
9D001774  00402821   ADDU A1, V0, ZERO
9D001778  0F400B3A   JAL PutPixel
9D00177C  00000000   NOP
1003:                                    PutPixel(x1 - xPos, y1 - yPos + 1);
9D001780  97C30030   LHU V1, 48(S8)
9D001784  97C20014   LHU V0, 20(S8)
9D001788  00621023   SUBU V0, V1, V0
9D00178C  3042FFFF   ANDI V0, V0, -1
9D001790  7C021620   SEH V0, V0
9D001794  00401821   ADDU V1, V0, ZERO
9D001798  97C40034   LHU A0, 52(S8)
9D00179C  97C20016   LHU V0, 22(S8)
9D0017A0  00821023   SUBU V0, A0, V0
9D0017A4  3042FFFF   ANDI V0, V0, -1
9D0017A8  24420001   ADDIU V0, V0, 1
9D0017AC  3042FFFF   ANDI V0, V0, -1
9D0017B0  7C021620   SEH V0, V0
9D0017B4  00602021   ADDU A0, V1, ZERO
9D0017B8  00402821   ADDU A1, V0, ZERO
9D0017BC  0F400B3A   JAL PutPixel
9D0017C0  00000000   NOP
1004:                                    PutPixel(x1 - xPos, y1 - yPos - 1);
9D0017C4  97C30030   LHU V1, 48(S8)
9D0017C8  97C20014   LHU V0, 20(S8)
9D0017CC  00621023   SUBU V0, V1, V0
9D0017D0  3042FFFF   ANDI V0, V0, -1
9D0017D4  7C021620   SEH V0, V0
9D0017D8  00401821   ADDU V1, V0, ZERO
9D0017DC  97C40034   LHU A0, 52(S8)
9D0017E0  97C20016   LHU V0, 22(S8)
9D0017E4  00821023   SUBU V0, A0, V0
9D0017E8  3042FFFF   ANDI V0, V0, -1
9D0017EC  2442FFFF   ADDIU V0, V0, -1
9D0017F0  3042FFFF   ANDI V0, V0, -1
9D0017F4  7C021620   SEH V0, V0
9D0017F8  00602021   ADDU A0, V1, ZERO
9D0017FC  00402821   ADDU A1, V0, ZERO
9D001800  0F400B3A   JAL PutPixel
9D001804  00000000   NOP
1005:                                }
1006:                            }
1007:                
1008:                            if(error > 0)
9D001808  87C20018   LH V0, 24(S8)
9D00180C  18400012   BLEZ V0, 0x9D001858
9D001810  00000000   NOP
1009:                            {
1010:                                yPos--;
9D001814  97C20016   LHU V0, 22(S8)
9D001818  2442FFFF   ADDIU V0, V0, -1
9D00181C  A7C20016   SH V0, 22(S8)
1011:                                error += 5 + ((xPos - yPos) << 1);
9D001820  97C30014   LHU V1, 20(S8)
9D001824  97C20016   LHU V0, 22(S8)
9D001828  00621023   SUBU V0, V1, V0
9D00182C  3042FFFF   ANDI V0, V0, -1
9D001830  00021040   SLL V0, V0, 1
9D001834  3043FFFF   ANDI V1, V0, -1
9D001838  97C20018   LHU V0, 24(S8)
9D00183C  00621021   ADDU V0, V1, V0
9D001840  3042FFFF   ANDI V0, V0, -1
9D001844  24420005   ADDIU V0, V0, 5
9D001848  3042FFFF   ANDI V0, V0, -1
9D00184C  A7C20018   SH V0, 24(S8)
9D001850  0B40061F   J 0x9D00187C
9D001854  00000000   NOP
1012:                            }
1013:                            else
1014:                                error += 3 + (xPos << 1);
9D001858  97C20014   LHU V0, 20(S8)
9D00185C  00021040   SLL V0, V0, 1
9D001860  3043FFFF   ANDI V1, V0, -1
9D001864  97C20018   LHU V0, 24(S8)
9D001868  00621021   ADDU V0, V1, V0
9D00186C  3042FFFF   ANDI V0, V0, -1
9D001870  24420003   ADDIU V0, V0, 3
9D001874  3042FFFF   ANDI V0, V0, -1
9D001878  A7C20018   SH V0, 24(S8)
1015:                        }
1016:                    }
1017:                    // Must use lines here since this can also be used to draw focus of round buttons
1018:                    if(x2 - x1)
9D00189C  87C30038   LH V1, 56(S8)
9D0018A0  87C20030   LH V0, 48(S8)
9D0018A4  10620015   BEQ V1, V0, 0x9D0018FC
9D0018A8  00000000   NOP
1019:                    {
1020:                        while(!Line(x1, y1 - rad, x2, y1 - rad));
9D0018AC  00000000   NOP
9D0018B0  87C40030   LH A0, 48(S8)
9D0018B4  97C30034   LHU V1, 52(S8)
9D0018B8  97C20020   LHU V0, 32(S8)
9D0018BC  00621023   SUBU V0, V1, V0
9D0018C0  3042FFFF   ANDI V0, V0, -1
9D0018C4  7C021620   SEH V0, V0
9D0018C8  00402821   ADDU A1, V0, ZERO
9D0018CC  87C30038   LH V1, 56(S8)
9D0018D0  97C60034   LHU A2, 52(S8)
9D0018D4  97C20020   LHU V0, 32(S8)
9D0018D8  00C21023   SUBU V0, A2, V0
9D0018DC  3042FFFF   ANDI V0, V0, -1
9D0018E0  7C021620   SEH V0, V0
9D0018E4  00603021   ADDU A2, V1, ZERO
9D0018E8  00403821   ADDU A3, V0, ZERO
9D0018EC  0F4002C7   JAL Line
9D0018F0  00000000   NOP
9D0018F4  1040FFEE   BEQ V0, ZERO, 0x9D0018B0
9D0018F8  00000000   NOP
1021:                
1022:                        // draw top
1023:                    }
1024:                
1025:                    if(y2 - y1)
9D0018FC  87C3003C   LH V1, 60(S8)
9D001900  87C20034   LH V0, 52(S8)
9D001904  10620016   BEQ V1, V0, 0x9D001960
9D001908  00000000   NOP
1026:                    {
1027:                        while(!Line(x1 - rad, y1, x1 - rad, y2));
9D00190C  00000000   NOP
9D001910  97C30030   LHU V1, 48(S8)
9D001914  97C20020   LHU V0, 32(S8)
9D001918  00621023   SUBU V0, V1, V0
9D00191C  3042FFFF   ANDI V0, V0, -1
9D001920  7C021620   SEH V0, V0
9D001924  00402021   ADDU A0, V0, ZERO
9D001928  87C50034   LH A1, 52(S8)
9D00192C  97C30030   LHU V1, 48(S8)
9D001930  97C20020   LHU V0, 32(S8)
9D001934  00621023   SUBU V0, V1, V0
9D001938  3042FFFF   ANDI V0, V0, -1
9D00193C  7C021620   SEH V0, V0
9D001940  00401821   ADDU V1, V0, ZERO
9D001944  87C2003C   LH V0, 60(S8)
9D001948  00603021   ADDU A2, V1, ZERO
9D00194C  00403821   ADDU A3, V0, ZERO
9D001950  0F4002C7   JAL Line
9D001954  00000000   NOP
9D001958  1040FFED   BEQ V0, ZERO, 0x9D001910
9D00195C  00000000   NOP
1028:                
1029:                        // draw left
1030:                    }
1031:                
1032:                    if((x2 - x1) || (y2 - y1))
9D001960  87C30038   LH V1, 56(S8)
9D001964  87C20030   LH V0, 48(S8)
9D001968  14620007   BNE V1, V0, 0x9D001988
9D00196C  00000000   NOP
9D001970  87C3003C   LH V1, 60(S8)
9D001974  87C20034   LH V0, 52(S8)
9D001978  1062002C   BEQ V1, V0, 0x9D001A2C
9D00197C  00000000   NOP
1033:                    {
1034:                        while(!Line(x2 + rad, y1, x2 + rad, y2));
9D001980  0B400663   J 0x9D00198C
9D001984  00000000   NOP
9D001988  00000000   NOP
9D00198C  97C30038   LHU V1, 56(S8)
9D001990  97C20020   LHU V0, 32(S8)
9D001994  00621021   ADDU V0, V1, V0
9D001998  3042FFFF   ANDI V0, V0, -1
9D00199C  7C021620   SEH V0, V0
9D0019A0  00402021   ADDU A0, V0, ZERO
9D0019A4  87C50034   LH A1, 52(S8)
9D0019A8  97C30038   LHU V1, 56(S8)
9D0019AC  97C20020   LHU V0, 32(S8)
9D0019B0  00621021   ADDU V0, V1, V0
9D0019B4  3042FFFF   ANDI V0, V0, -1
9D0019B8  7C021620   SEH V0, V0
9D0019BC  00401821   ADDU V1, V0, ZERO
9D0019C0  87C2003C   LH V0, 60(S8)
9D0019C4  00603021   ADDU A2, V1, ZERO
9D0019C8  00403821   ADDU A3, V0, ZERO
9D0019CC  0F4002C7   JAL Line
9D0019D0  00000000   NOP
9D0019D4  1040FFED   BEQ V0, ZERO, 0x9D00198C
9D0019D8  00000000   NOP
1035:                
1036:                        // draw right
1037:                        while(!Line(x1, y2 + rad, x2, y2 + rad));
9D0019DC  00000000   NOP
9D0019E0  87C40030   LH A0, 48(S8)
9D0019E4  97C3003C   LHU V1, 60(S8)
9D0019E8  97C20020   LHU V0, 32(S8)
9D0019EC  00621021   ADDU V0, V1, V0
9D0019F0  3042FFFF   ANDI V0, V0, -1
9D0019F4  7C021620   SEH V0, V0
9D0019F8  00402821   ADDU A1, V0, ZERO
9D0019FC  87C30038   LH V1, 56(S8)
9D001A00  97C6003C   LHU A2, 60(S8)
9D001A04  97C20020   LHU V0, 32(S8)
9D001A08  00C21021   ADDU V0, A2, V0
9D001A0C  3042FFFF   ANDI V0, V0, -1
9D001A10  7C021620   SEH V0, V0
9D001A14  00603021   ADDU A2, V1, ZERO
9D001A18  00403821   ADDU A3, V0, ZERO
9D001A1C  0F4002C7   JAL Line
9D001A20  00000000   NOP
9D001A24  1040FFEE   BEQ V0, ZERO, 0x9D0019E0
9D001A28  00000000   NOP
1038:                
1039:                        // draw bottom
1040:                    }
1041:                
1042:                    return (1);
9D001A2C  24020001   ADDIU V0, ZERO, 1
1043:                }
9D001A30  03C0E821   ADDU SP, S8, ZERO
9D001A34  8FBF002C   LW RA, 44(SP)
9D001A38  8FBE0028   LW S8, 40(SP)
9D001A3C  27BD0030   ADDIU SP, SP, 48
9D001A40  03E00008   JR RA
9D001A44  00000000   NOP
1044:                
1045:                /*********************************************************************
1046:                * Function: WORD FillBevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
1047:                *
1048:                * PreCondition: None
1049:                *
1050:                * Input: x1, y1 - coordinate position of the upper left center of the 
1051:                * 				  circle that draws the rounded corners,
1052:                *		 x2, y2 - coordinate position of the lower right center of the 
1053:                * 				  circle that draws the rounded corners,
1054:                *        rad - defines the redius of the circle,
1055:                *
1056:                * Output: For NON-Blocking configuration:
1057:                *         - Returns 0 when device is busy and the shape is not yet completely drawn.
1058:                *         - Returns 1 when the shape is completely drawn.
1059:                *         For Blocking configuration:
1060:                *         - Always return 1.
1061:                *
1062:                * Overview: Draws a filled beveled figure on the screen. 
1063:                *           For a filled circular object x1 = x2 and y1 = y2. 
1064:                *           For a filled rectangular object radius = 0.
1065:                *
1066:                * Note: none
1067:                *
1068:                ********************************************************************/
1069:                WORD FillBevel(SHORT x1, SHORT y1, SHORT x2, SHORT y2, SHORT rad)
1070:                {
9D001A48  27BDFFC8   ADDIU SP, SP, -56
9D001A4C  AFBF0034   SW RA, 52(SP)
9D001A50  AFBE0030   SW S8, 48(SP)
9D001A54  03A0F021   ADDU S8, SP, ZERO
9D001A58  00804021   ADDU T0, A0, ZERO
9D001A5C  00C02021   ADDU A0, A2, ZERO
9D001A60  00E01821   ADDU V1, A3, ZERO
9D001A64  8FC20048   LW V0, 72(S8)
9D001A68  A7C80038   SH T0, 56(S8)
9D001A6C  A7C5003C   SH A1, 60(S8)
9D001A70  A7C40040   SH A0, 64(S8)
9D001A74  A7C30044   SH V1, 68(S8)
9D001A78  A7C20028   SH V0, 40(S8)
1071:                    #ifndef USE_NONBLOCKING_CONFIG
1072:                
1073:                    SHORT       yLimit, xPos, yPos, err;
1074:                    SHORT       xCur, yCur, yNew;
1075:                    DWORD_VAL   temp;
1076:                
1077:                    // note that octants here is defined as:
1078:                    // from yPos=-radius, xPos=0 in the clockwise direction octant 1 to 8 are labeled
1079:                    // assumes an origin at 0,0. Quadrants are defined in the same manner
1080:                    if(rad)
9D001A7C  87C20028   LH V0, 40(S8)
9D001A80  104000B5   BEQ V0, ZERO, 0x9D001D58
9D001A84  00000000   NOP
1081:                    {
1082:                        temp.Val = SIN45 * rad;
9D001A88  87C30028   LH V1, 40(S8)
9D001A8C  3402B505   ORI V0, ZERO, -19195
9D001A90  70621002   MUL V0, V1, V0
9D001A94  AFC20020   SW V0, 32(S8)
1083:                        yLimit = temp.w[1];
9D001A98  97C20022   LHU V0, 34(S8)
9D001A9C  A7C2001A   SH V0, 26(S8)
1084:                        temp.Val = (DWORD) (ONEP25 - ((LONG) rad << 16));
9D001AA0  87C20028   LH V0, 40(S8)
9D001AA4  00021400   SLL V0, V0, 16
9D001AA8  3C030001   LUI V1, 1
9D001AAC  34634000   ORI V1, V1, 16384
9D001AB0  00621023   SUBU V0, V1, V0
9D001AB4  AFC20020   SW V0, 32(S8)
1085:                        err = (SHORT) (temp.w[1]);
9D001AB8  97C20022   LHU V0, 34(S8)
9D001ABC  A7C20014   SH V0, 20(S8)
1086:                        xPos = rad;
9D001AC0  97C20028   LHU V0, 40(S8)
9D001AC4  A7C20010   SH V0, 16(S8)
1087:                        yPos = 0;
9D001AC8  A7C00012   SH ZERO, 18(S8)
1088:                
1089:                        xCur = xPos;
9D001ACC  97C20010   LHU V0, 16(S8)
9D001AD0  A7C20016   SH V0, 22(S8)
1090:                        yCur = yPos;
9D001AD4  97C20012   LHU V0, 18(S8)
9D001AD8  A7C20018   SH V0, 24(S8)
1091:                        yNew = yPos;
9D001ADC  97C20012   LHU V0, 18(S8)
9D001AE0  A7C2001C   SH V0, 28(S8)
1092:                
1093:                        while(yPos <= yLimit)
9D001AE4  0B400751   J 0x9D001D44
9D001AE8  00000000   NOP
9D001D44  87C30012   LH V1, 18(S8)
9D001D48  87C2001A   LH V0, 26(S8)
9D001D4C  0043102A   SLT V0, V0, V1
9D001D50  1040FF66   BEQ V0, ZERO, 0x9D001AEC
9D001D54  00000000   NOP
1094:                        {
1095:                
1096:                            // Drawing of the rounded panel is done only when there is a change in the
1097:                            // x direction. Bars are drawn to be efficient.
1098:                            // detect changes in the x position. Every change will mean a bar will be drawn
1099:                            // to cover the previous area. y1New records the last position of y before the
1100:                            // change in x position.
1101:                            // y1New records the last y position
1102:                            yNew = yPos;
9D001AEC  97C20012   LHU V0, 18(S8)
9D001AF0  A7C2001C   SH V0, 28(S8)
1103:                
1104:                            if(err > 0)
9D001AF4  87C20014   LH V0, 20(S8)
9D001AF8  18400012   BLEZ V0, 0x9D001B44
9D001AFC  00000000   NOP
1105:                            {
1106:                                xPos--;
9D001B00  97C20010   LHU V0, 16(S8)
9D001B04  2442FFFF   ADDIU V0, V0, -1
9D001B08  A7C20010   SH V0, 16(S8)
1107:                                err += 5 + ((yPos - xPos) << 1);
9D001B0C  97C30012   LHU V1, 18(S8)
9D001B10  97C20010   LHU V0, 16(S8)
9D001B14  00621023   SUBU V0, V1, V0
9D001B18  3042FFFF   ANDI V0, V0, -1
9D001B1C  00021040   SLL V0, V0, 1
9D001B20  3043FFFF   ANDI V1, V0, -1
9D001B24  97C20014   LHU V0, 20(S8)
9D001B28  00621021   ADDU V0, V1, V0
9D001B2C  3042FFFF   ANDI V0, V0, -1
9D001B30  24420005   ADDIU V0, V0, 5
9D001B34  3042FFFF   ANDI V0, V0, -1
9D001B38  A7C20014   SH V0, 20(S8)
9D001B3C  0B4006DA   J 0x9D001B68
9D001B40  00000000   NOP
1108:                            }
1109:                            else
1110:                                err += 3 + (yPos << 1);
9D001B44  97C20012   LHU V0, 18(S8)
9D001B48  00021040   SLL V0, V0, 1
9D001B4C  3043FFFF   ANDI V1, V0, -1
9D001B50  97C20014   LHU V0, 20(S8)
9D001B54  00621021   ADDU V0, V1, V0
9D001B58  3042FFFF   ANDI V0, V0, -1
9D001B5C  24420003   ADDIU V0, V0, 3
9D001B60  3042FFFF   ANDI V0, V0, -1
9D001B64  A7C20014   SH V0, 20(S8)
1111:                            yPos++;
9D001B68  97C20012   LHU V0, 18(S8)
9D001B6C  24420001   ADDIU V0, V0, 1
9D001B70  A7C20012   SH V0, 18(S8)
1112:                
1113:                            if(xCur != xPos)
9D001B74  87C30016   LH V1, 22(S8)
9D001B78  87C20010   LH V0, 16(S8)
9D001B7C  10620071   BEQ V1, V0, 0x9D001D44
9D001B80  00000000   NOP
1114:                            {
1115:                
1116:                                // 6th octant to 3rd octant
1117:                                Bar(x1 - xCur, y2 + yCur, x2 + xCur, y2 + yNew);
9D001B84  97C30038   LHU V1, 56(S8)
9D001B88  97C20016   LHU V0, 22(S8)
9D001B8C  00621023   SUBU V0, V1, V0
9D001B90  3042FFFF   ANDI V0, V0, -1
9D001B94  7C021620   SEH V0, V0
9D001B98  00402021   ADDU A0, V0, ZERO
9D001B9C  97C30044   LHU V1, 68(S8)
9D001BA0  97C20018   LHU V0, 24(S8)
9D001BA4  00621021   ADDU V0, V1, V0
9D001BA8  3042FFFF   ANDI V0, V0, -1
9D001BAC  7C021620   SEH V0, V0
9D001BB0  00402821   ADDU A1, V0, ZERO
9D001BB4  97C30040   LHU V1, 64(S8)
9D001BB8  97C20016   LHU V0, 22(S8)
9D001BBC  00621021   ADDU V0, V1, V0
9D001BC0  3042FFFF   ANDI V0, V0, -1
9D001BC4  7C021620   SEH V0, V0
9D001BC8  00401821   ADDU V1, V0, ZERO
9D001BCC  97C60044   LHU A2, 68(S8)
9D001BD0  97C2001C   LHU V0, 28(S8)
9D001BD4  00C21021   ADDU V0, A2, V0
9D001BD8  3042FFFF   ANDI V0, V0, -1
9D001BDC  7C021620   SEH V0, V0
9D001BE0  00603021   ADDU A2, V1, ZERO
9D001BE4  00403821   ADDU A3, V0, ZERO
9D001BE8  0F400C02   JAL Bar
9D001BEC  00000000   NOP
1118:                
1119:                                // 5th octant to 4th octant
1120:                                Bar(x1 - yNew, y2 + xPos, x2 + yNew, y2 + xCur);
9D001BF0  97C30038   LHU V1, 56(S8)
9D001BF4  97C2001C   LHU V0, 28(S8)
9D001BF8  00621023   SUBU V0, V1, V0
9D001BFC  3042FFFF   ANDI V0, V0, -1
9D001C00  7C021620   SEH V0, V0
9D001C04  00402021   ADDU A0, V0, ZERO
9D001C08  97C30044   LHU V1, 68(S8)
9D001C0C  97C20010   LHU V0, 16(S8)
9D001C10  00621021   ADDU V0, V1, V0
9D001C14  3042FFFF   ANDI V0, V0, -1
9D001C18  7C021620   SEH V0, V0
9D001C1C  00402821   ADDU A1, V0, ZERO
9D001C20  97C30040   LHU V1, 64(S8)
9D001C24  97C2001C   LHU V0, 28(S8)
9D001C28  00621021   ADDU V0, V1, V0
9D001C2C  3042FFFF   ANDI V0, V0, -1
9D001C30  7C021620   SEH V0, V0
9D001C34  00401821   ADDU V1, V0, ZERO
9D001C38  97C60044   LHU A2, 68(S8)
9D001C3C  97C20016   LHU V0, 22(S8)
9D001C40  00C21021   ADDU V0, A2, V0
9D001C44  3042FFFF   ANDI V0, V0, -1
9D001C48  7C021620   SEH V0, V0
9D001C4C  00603021   ADDU A2, V1, ZERO
9D001C50  00403821   ADDU A3, V0, ZERO
9D001C54  0F400C02   JAL Bar
9D001C58  00000000   NOP
1121:                
1122:                                // 8th octant to 1st octant
1123:                                Bar(x1 - yNew, y1 - xCur, x2 + yNew, y1 - xPos);
9D001C5C  97C30038   LHU V1, 56(S8)
9D001C60  97C2001C   LHU V0, 28(S8)
9D001C64  00621023   SUBU V0, V1, V0
9D001C68  3042FFFF   ANDI V0, V0, -1
9D001C6C  7C021620   SEH V0, V0
9D001C70  00402021   ADDU A0, V0, ZERO
9D001C74  97C3003C   LHU V1, 60(S8)
9D001C78  97C20016   LHU V0, 22(S8)
9D001C7C  00621023   SUBU V0, V1, V0
9D001C80  3042FFFF   ANDI V0, V0, -1
9D001C84  7C021620   SEH V0, V0
9D001C88  00402821   ADDU A1, V0, ZERO
9D001C8C  97C30040   LHU V1, 64(S8)
9D001C90  97C2001C   LHU V0, 28(S8)
9D001C94  00621021   ADDU V0, V1, V0
9D001C98  3042FFFF   ANDI V0, V0, -1
9D001C9C  7C021620   SEH V0, V0
9D001CA0  00401821   ADDU V1, V0, ZERO
9D001CA4  97C6003C   LHU A2, 60(S8)
9D001CA8  97C20010   LHU V0, 16(S8)
9D001CAC  00C21023   SUBU V0, A2, V0
9D001CB0  3042FFFF   ANDI V0, V0, -1
9D001CB4  7C021620   SEH V0, V0
9D001CB8  00603021   ADDU A2, V1, ZERO
9D001CBC  00403821   ADDU A3, V0, ZERO
9D001CC0  0F400C02   JAL Bar
9D001CC4  00000000   NOP
1124:                
1125:                                // 7th octant to 2nd octant
1126:                                Bar(x1 - xCur, y1 - yNew, x2 + xCur, y1 - yCur);
9D001CC8  97C30038   LHU V1, 56(S8)
9D001CCC  97C20016   LHU V0, 22(S8)
9D001CD0  00621023   SUBU V0, V1, V0
9D001CD4  3042FFFF   ANDI V0, V0, -1
9D001CD8  7C021620   SEH V0, V0
9D001CDC  00402021   ADDU A0, V0, ZERO
9D001CE0  97C3003C   LHU V1, 60(S8)
9D001CE4  97C2001C   LHU V0, 28(S8)
9D001CE8  00621023   SUBU V0, V1, V0
9D001CEC  3042FFFF   ANDI V0, V0, -1
9D001CF0  7C021620   SEH V0, V0
9D001CF4  00402821   ADDU A1, V0, ZERO
9D001CF8  97C30040   LHU V1, 64(S8)
9D001CFC  97C20016   LHU V0, 22(S8)
9D001D00  00621021   ADDU V0, V1, V0
9D001D04  3042FFFF   ANDI V0, V0, -1
9D001D08  7C021620   SEH V0, V0
9D001D0C  00401821   ADDU V1, V0, ZERO
9D001D10  97C6003C   LHU A2, 60(S8)
9D001D14  97C20018   LHU V0, 24(S8)
9D001D18  00C21023   SUBU V0, A2, V0
9D001D1C  3042FFFF   ANDI V0, V0, -1
9D001D20  7C021620   SEH V0, V0
9D001D24  00603021   ADDU A2, V1, ZERO
9D001D28  00403821   ADDU A3, V0, ZERO
9D001D2C  0F400C02   JAL Bar
9D001D30  00000000   NOP
1127:                
1128:                                // update current values
1129:                                xCur = xPos;
9D001D34  97C20010   LHU V0, 16(S8)
9D001D38  A7C20016   SH V0, 22(S8)
1130:                                yCur = yPos;
9D001D3C  97C20012   LHU V0, 18(S8)
9D001D40  A7C20018   SH V0, 24(S8)
1131:                            }
1132:                        }
1133:                    }
1134:                
1135:                    // this covers both filled rounded object and filled rectangle.
1136:                    if((x2 - x1) || (y2 - y1))
9D001D58  87C30040   LH V1, 64(S8)
9D001D5C  87C20038   LH V0, 56(S8)
9D001D60  14620005   BNE V1, V0, 0x9D001D78
9D001D64  00000000   NOP
9D001D68  87C30044   LH V1, 68(S8)
9D001D6C  87C2003C   LH V0, 60(S8)
9D001D70  10620013   BEQ V1, V0, 0x9D001DC0
9D001D74  00000000   NOP
1137:                        Bar(x1 - rad, y1, x2 + rad, y2);
9D001D78  97C30038   LHU V1, 56(S8)
9D001D7C  97C20028   LHU V0, 40(S8)
9D001D80  00621023   SUBU V0, V1, V0
9D001D84  3042FFFF   ANDI V0, V0, -1
9D001D88  7C021620   SEH V0, V0
9D001D8C  00402021   ADDU A0, V0, ZERO
9D001D90  87C5003C   LH A1, 60(S8)
9D001D94  97C30040   LHU V1, 64(S8)
9D001D98  97C20028   LHU V0, 40(S8)
9D001D9C  00621021   ADDU V0, V1, V0
9D001DA0  3042FFFF   ANDI V0, V0, -1
9D001DA4  7C021620   SEH V0, V0
9D001DA8  00401821   ADDU V1, V0, ZERO
9D001DAC  87C20044   LH V0, 68(S8)
9D001DB0  00603021   ADDU A2, V1, ZERO
9D001DB4  00403821   ADDU A3, V0, ZERO
9D001DB8  0F400C02   JAL Bar
9D001DBC  00000000   NOP
1138:                    return (1);
9D001DC0  24020001   ADDIU V0, ZERO, 1
1139:                    #else
1140:                
1141:                    typedef enum
1142:                    {
1143:                        BEGIN,
1144:                        CHECK,
1145:                        Q8TOQ1,
1146:                        Q7TOQ2,
1147:                        Q6TOQ3,
1148:                        Q5TOQ4,
1149:                        WAITFORDONE,
1150:                        FACE
1151:                    } FILLCIRCLE_STATES;
1152:                
1153:                    DWORD_VAL temp;
1154:                    static LONG err;
1155:                    static SHORT yLimit, xPos, yPos;
1156:                    static SHORT xCur, yCur, yNew;
1157:                
1158:                    static FILLCIRCLE_STATES state = BEGIN;
1159:                
1160:                    while(1)
1161:                    {
1162:                        if(IsDeviceBusy())
1163:                            return (0);
1164:                        switch(state)
1165:                        {
1166:                            case BEGIN:
1167:                                if(!rad)
1168:                                {   // no radius object is a filled rectangle
1169:                                    state = FACE;
1170:                                    break;
1171:                                }
1172:                
1173:                                // compute variables
1174:                                temp.Val = SIN45 * rad;
1175:                                yLimit = temp.w[1];
1176:                                temp.Val = (DWORD) (ONEP25 - ((LONG) rad << 16));
1177:                                err = (SHORT) (temp.w[1]);
1178:                                xPos = rad;
1179:                                yPos = 0;
1180:                                xCur = xPos;
1181:                                yCur = yPos;
1182:                                yNew = yPos;
1183:                                state = CHECK;
1184:                
1185:                            case CHECK:
1186:                                bevel_fill_check : if(yPos > yLimit)
1187:                                {
1188:                                    state = FACE;
1189:                                    break;
1190:                                }
1191:                
1192:                                // y1New records the last y position
1193:                                yNew = yPos;
1194:                
1195:                                // calculate the next value of x and y
1196:                                if(err > 0)
1197:                                {
1198:                                    xPos--;
1199:                                    err += 5 + ((yPos - xPos) << 1);
1200:                                }
1201:                                else
1202:                                    err += 3 + (yPos << 1);
1203:                                yPos++;
1204:                                state = Q6TOQ3;
1205:                
1206:                            case Q6TOQ3:
1207:                                if(xCur != xPos)
1208:                                {
1209:                
1210:                                    // 6th octant to 3rd octant
1211:                                    if(Bar(x1 - xCur, y2 + yCur, x2 + xCur, y2 + yNew) == 0)
1212:                                        return (0);
1213:                                    state = Q5TOQ4;
1214:                                    break;
1215:                                }
1216:                
1217:                                state = CHECK;
1218:                                goto bevel_fill_check;
1219:                
1220:                            case Q5TOQ4:
1221:                
1222:                                // 5th octant to 4th octant
1223:                                if(Bar(x1 - yNew, y2 + xPos, x2 + yNew, y2 + xCur) == 0)
1224:                                    return (0);
1225:                                state = Q8TOQ1;
1226:                                break;
1227:                
1228:                            case Q8TOQ1:
1229:                
1230:                                // 8th octant to 1st octant
1231:                                if(Bar(x1 - yNew, y1 - xCur, x2 + yNew, y1 - xPos) == 0)
1232:                                    return (0);
1233:                                state = Q7TOQ2;
1234:                                break;
1235:                
1236:                            case Q7TOQ2:
1237:                
1238:                                // 7th octant to 2nd octant
1239:                                if(Bar(x1 - xCur, y1 - yNew, x2 + xCur, y1 - yCur) == 0)
1240:                                    return (0);
1241:                
1242:                                // update current values
1243:                                xCur = xPos;
1244:                                yCur = yPos;
1245:                                state = CHECK;
1246:                                break;
1247:                
1248:                            case FACE:
1249:                                if((x2 - x1) || (y2 - y1))
1250:                                {
1251:                                    if(Bar(x1 - rad, y1, x2 + rad, y2) == 0)
1252:                                        return (0);
1253:                                    state = WAITFORDONE;
1254:                                }
1255:                                else
1256:                                {
1257:                                    state = BEGIN;
1258:                                    return (1);
1259:                                }
1260:                
1261:                            case WAITFORDONE:
1262:                                if(IsDeviceBusy())
1263:                                    return (0);
1264:                                state = BEGIN;
1265:                                return (1);
1266:                        }           // end of switch
1267:                    }               // end of while
1268:                    #endif // end of USE_NONBLOCKING_CONFIG
1269:                }
9D001DC4  03C0E821   ADDU SP, S8, ZERO
9D001DC8  8FBF0034   LW RA, 52(SP)
9D001DCC  8FBE0030   LW S8, 48(SP)
9D001DD0  27BD0038   ADDIU SP, SP, 56
9D001DD4  03E00008   JR RA
9D001DD8  00000000   NOP
1270:                
1271:                /*********************************************************************
1272:                * Function: WORD DrawPoly(SHORT numPoints, SHORT* polyPoints)
1273:                *
1274:                * PreCondition: none
1275:                *
1276:                * Input: numPoints - points number, polyPoints - pointer to points array
1277:                *
1278:                * Output: For NON-Blocking configuration:
1279:                *         - Returns 0 when device is busy and the shape is not yet completely drawn.
1280:                *         - Returns 1 when the shape is completely drawn.
1281:                *         For Blocking configuration:
1282:                *         - Always return 1.
1283:                *
1284:                * Side Effects: none
1285:                *
1286:                * Overview: draws line polygon
1287:                *
1288:                * Note: none
1289:                *
1290:                ********************************************************************/
1291:                WORD DrawPoly(SHORT numPoints, SHORT *polyPoints)
1292:                {
9D001DDC  27BDFFD8   ADDIU SP, SP, -40
9D001DE0  AFBF0024   SW RA, 36(SP)
9D001DE4  AFBE0020   SW S8, 32(SP)
9D001DE8  03A0F021   ADDU S8, SP, ZERO
9D001DEC  00801021   ADDU V0, A0, ZERO
9D001DF0  AFC5002C   SW A1, 44(S8)
9D001DF4  A7C20028   SH V0, 40(S8)
1293:                    #ifndef USE_NONBLOCKING_CONFIG
1294:                
1295:                    SHORT   counter;
1296:                    SHORT   sx, sy, ex, ey;
1297:                
1298:                        #ifndef USE_NONBLOCKING_CONFIG
1299:                    while(IsDeviceBusy() != 0) Nop();
1300:                
1301:                    /* Ready */
1302:                        #else
1303:                    if(IsDeviceBusy() != 0)
1304:                        return (0);
1305:                        #endif
1306:                    sx = *polyPoints++;
9D001DF8  8FC2002C   LW V0, 44(S8)
9D001DFC  94420000   LHU V0, 0(V0)
9D001E00  A7C20012   SH V0, 18(S8)
9D001E04  8FC2002C   LW V0, 44(S8)
9D001E08  24420002   ADDIU V0, V0, 2
9D001E0C  AFC2002C   SW V0, 44(S8)
1307:                    sy = *polyPoints++;
9D001E10  8FC2002C   LW V0, 44(S8)
9D001E14  94420000   LHU V0, 0(V0)
9D001E18  A7C20014   SH V0, 20(S8)
9D001E1C  8FC2002C   LW V0, 44(S8)
9D001E20  24420002   ADDIU V0, V0, 2
9D001E24  AFC2002C   SW V0, 44(S8)
1308:                    for(counter = 0; counter < numPoints - 1; counter++)
9D001E28  A7C00010   SH ZERO, 16(S8)
9D001E2C  0B4007AB   J 0x9D001EAC
9D001E30  00000000   NOP
9D001EA0  97C20010   LHU V0, 16(S8)
9D001EA4  24420001   ADDIU V0, V0, 1
9D001EA8  A7C20010   SH V0, 16(S8)
9D001EAC  87C30010   LH V1, 16(S8)
9D001EB0  87C20028   LH V0, 40(S8)
9D001EB4  2442FFFF   ADDIU V0, V0, -1
9D001EB8  0062102A   SLT V0, V1, V0
9D001EBC  1440FFDD   BNE V0, ZERO, 0x9D001E34
9D001EC0  00000000   NOP
1309:                    {
1310:                        ex = *polyPoints++;
9D001E34  8FC2002C   LW V0, 44(S8)
9D001E38  94420000   LHU V0, 0(V0)
9D001E3C  A7C20016   SH V0, 22(S8)
9D001E40  8FC2002C   LW V0, 44(S8)
9D001E44  24420002   ADDIU V0, V0, 2
9D001E48  AFC2002C   SW V0, 44(S8)
1311:                        ey = *polyPoints++;
9D001E4C  8FC2002C   LW V0, 44(S8)
9D001E50  94420000   LHU V0, 0(V0)
9D001E54  A7C20018   SH V0, 24(S8)
9D001E58  8FC2002C   LW V0, 44(S8)
9D001E5C  24420002   ADDIU V0, V0, 2
9D001E60  AFC2002C   SW V0, 44(S8)
1312:                        while(Line(sx, sy, ex, ey) == 0);
9D001E64  00000000   NOP
9D001E68  87C40012   LH A0, 18(S8)
9D001E6C  87C50014   LH A1, 20(S8)
9D001E70  87C30016   LH V1, 22(S8)
9D001E74  87C20018   LH V0, 24(S8)
9D001E78  00603021   ADDU A2, V1, ZERO
9D001E7C  00403821   ADDU A3, V0, ZERO
9D001E80  0F4002C7   JAL Line
9D001E84  00000000   NOP
9D001E88  1040FFF7   BEQ V0, ZERO, 0x9D001E68
9D001E8C  00000000   NOP
1313:                        sx = ex;
9D001E90  97C20016   LHU V0, 22(S8)
9D001E94  A7C20012   SH V0, 18(S8)
1314:                        sy = ey;
9D001E98  97C20018   LHU V0, 24(S8)
9D001E9C  A7C20014   SH V0, 20(S8)
1315:                    }
1316:                
1317:                    #else
1318:                
1319:                    typedef enum
1320:                    {
1321:                        POLY_BEGIN,
1322:                        POLY_DRAWING,
1323:                    } DRAWPOLY_STATES;
1324:                
1325:                    static DRAWPOLY_STATES state = POLY_BEGIN;
1326:                    static SHORT counter;
1327:                    SHORT sx, sy, ex, ey;
1328:                    while(1)
1329:                    {
1330:                        if(IsDeviceBusy())
1331:                            return (0);
1332:                        switch(state)
1333:                        {
1334:                            case POLY_BEGIN:
1335:                                counter = 1;
1336:                                state = POLY_DRAWING;
1337:                
1338:                            case POLY_DRAWING:
1339:                                if(counter == 0 || counter >= numPoints)
1340:                                {
1341:                                    state = POLY_BEGIN;
1342:                                    break;
1343:                                }
1344:                
1345:                                while(counter < numPoints)
1346:                                {
1347:                                    sx = polyPoints[(counter - 1) * 2];
1348:                                    sy = polyPoints[(counter * 2) - 1];
1349:                                    ex = polyPoints[counter * 2];
1350:                                    ey = polyPoints[counter * 2 + 1];
1351:                                    if(Line(sx, sy, ex, ey) == 0)
1352:                                    {
1353:                                        return (0);
1354:                                    }
1355:                
1356:                                    counter++;
1357:                                }
1358:                
1359:                                state = POLY_BEGIN;
1360:                                return (1);
1361:                        }
1362:                    }
1363:                
1364:                    #endif
1365:                    return (1);
9D001EC4  24020001   ADDIU V0, ZERO, 1
1366:                }
9D001EC8  03C0E821   ADDU SP, S8, ZERO
9D001ECC  8FBF0024   LW RA, 36(SP)
9D001ED0  8FBE0020   LW S8, 32(SP)
9D001ED4  27BD0028   ADDIU SP, SP, 40
9D001ED8  03E00008   JR RA
9D001EDC  00000000   NOP
1367:                
1368:                /*********************************************************************
1369:                * Function: WORD Bar(SHORT left, SHORT top, SHORT right, SHORT bottom)
1370:                *
1371:                * PreCondition: none
1372:                *
1373:                * Input: left,top - top left corner coordinates,
1374:                *        right,bottom - bottom right corner coordinates
1375:                *
1376:                * Output: For NON-Blocking configuration:
1377:                *         - Returns 0 when device is busy and the shape is not yet completely drawn.
1378:                *         - Returns 1 when the shape is completely drawn.
1379:                *         For Blocking configuration:
1380:                *         - Always return 1.
1381:                *
1382:                * Side Effects: none
1383:                *
1384:                * Overview: draws rectangle filled with current color
1385:                *
1386:                * Note: none
1387:                *
1388:                ********************************************************************/
1389:                #ifndef USE_DRV_BAR
1390:                
1391:                /* */
1392:                WORD Bar(SHORT left, SHORT top, SHORT right, SHORT bottom)
1393:                {
1394:                    SHORT   x, y;
1395:                
1396:                        #ifndef USE_NONBLOCKING_CONFIG
1397:                    while(IsDeviceBusy() != 0) Nop();
1398:                
1399:                    /* Ready */
1400:                        #else
1401:                    if(IsDeviceBusy() != 0)
1402:                        return (0);
1403:                        #endif
1404:                    for(y = top; y < bottom + 1; y++)
1405:                        for(x = left; x < right + 1; x++)
1406:                            PutPixel(x, y);
1407:                
1408:                    return (1);
1409:                }
1410:                
1411:                #endif
1412:                
1413:                /*********************************************************************
1414:                * Function: void ClearDevice(void)
1415:                *
1416:                * PreCondition: none
1417:                *
1418:                * Input: none
1419:                *
1420:                * Output: none
1421:                *
1422:                * Side Effects: none
1423:                *
1424:                * Overview: clears screen with current color and sets cursor to 0,0
1425:                *
1426:                * Note: none
1427:                *
1428:                ********************************************************************/
1429:                #ifndef USE_DRV_CLEARDEVICE
1430:                
1431:                /* */
1432:                void ClearDevice(void)
1433:                {
1434:                    while(Bar(0, 0, GetMaxX(), GetMaxY()) == 0);
1435:                    MoveTo(0, 0);
1436:                }
1437:                
1438:                #endif
1439:                
1440:                #ifndef USE_DRV_FONT
1441:                /*********************************************************************
1442:                * Function: void SetFont(void* font)
1443:                *
1444:                * PreCondition: none
1445:                *
1446:                * Input: pointer to the font image
1447:                *
1448:                * Output: none
1449:                *
1450:                * Side Effects: none
1451:                *
1452:                * Overview: defines current font
1453:                *
1454:                * Note: none
1455:                *
1456:                ********************************************************************/
1457:                void SetFont(void *font)
1458:                {
9D001EE0  27BDFFF0   ADDIU SP, SP, -16
9D001EE4  AFBE000C   SW S8, 12(SP)
9D001EE8  03A0F021   ADDU S8, SP, ZERO
9D001EEC  AFC40010   SW A0, 16(S8)
1459:                    FONT_HEADER *pHeader;
1460:                
1461:                        #ifdef USE_FONT_EXTERNAL
1462:                    FONT_HEADER header;
1463:                        #endif
1464:                    _font = font;
9D001EF0  8FC20010   LW V0, 16(S8)
9D001EF4  AF8281AC   SW V0, -32340(GP)
1465:                    switch(*((SHORT *)font))
9D001EF8  8FC20010   LW V0, 16(S8)
9D001EFC  84420000   LH V0, 0(V0)
9D001F00  14400010   BNE V0, ZERO, 0x9D001F44
9D001F04  00000000   NOP
1466:                    {
1467:                                #ifdef USE_FONT_FLASH
1468:                
1469:                        case FLASH:
1470:                            pHeader = (FONT_HEADER *) ((FONT_FLASH *)font)->address;
9D001F08  8FC20010   LW V0, 16(S8)
9D001F0C  8C420004   LW V0, 4(V0)
9D001F10  AFC20000   SW V0, 0(S8)
1471:                            break;
1472:                                #endif
1473:                                #ifdef USE_FONT_EXTERNAL
1474:                
1475:                        case EXTERNAL:
1476:                            pHeader = &header;
1477:                            ExternalMemoryCallback(font, 0, sizeof(FONT_HEADER), pHeader);
1478:                            break;
1479:                                #endif
1480:                
1481:                        default:
1482:                            return;
9D001F44  00000000   NOP
1483:                    }
1484:                
1485:                    _fontFirstChar = pHeader->firstChar;
9D001F14  8FC20000   LW V0, 0(S8)
9D001F18  94420002   LHU V0, 2(V0)
9D001F1C  A78281A0   SH V0, -32352(GP)
1486:                    _fontLastChar = pHeader->lastChar;
9D001F20  8FC20000   LW V0, 0(S8)
9D001F24  94420004   LHU V0, 4(V0)
9D001F28  A78281A4   SH V0, -32348(GP)
1487:                    _fontHeight = pHeader->height;
9D001F2C  8FC20000   LW V0, 0(S8)
9D001F30  90420006   LBU V0, 6(V0)
9D001F34  7C021620   SEH V0, V0
9D001F38  A78281A8   SH V0, -32344(GP)
9D001F3C  0B4007D2   J 0x9D001F48
9D001F40  00000000   NOP
1488:                }
9D001F48  03C0E821   ADDU SP, S8, ZERO
9D001F4C  8FBE000C   LW S8, 12(SP)
9D001F50  27BD0010   ADDIU SP, SP, 16
9D001F54  03E00008   JR RA
9D001F58  00000000   NOP
1489:                
1490:                #endif
1491:                
1492:                /*********************************************************************
1493:                * Function: WORD OutText(XCHAR* textString)
1494:                *
1495:                * PreCondition: none
1496:                *
1497:                * Input: textString - pointer to text string
1498:                *
1499:                * Output: non-zero if drawing done (used for NON-BLOCKING configuration)
1500:                *
1501:                * Side Effects: none
1502:                *
1503:                * Overview: outputs text from current position
1504:                *
1505:                * Note: none
1506:                *
1507:                ********************************************************************/
1508:                WORD OutText(XCHAR *textString)
1509:                {
9D001F5C  27BDFFE0   ADDIU SP, SP, -32
9D001F60  AFBF001C   SW RA, 28(SP)
9D001F64  AFBE0018   SW S8, 24(SP)
9D001F68  03A0F021   ADDU S8, SP, ZERO
9D001F6C  AFC40020   SW A0, 32(S8)
1510:                    #ifndef USE_NONBLOCKING_CONFIG
1511:                
1512:                    XCHAR   ch;
1513:                    while((unsigned XCHAR)15 < (unsigned XCHAR)(ch = *textString++))
9D001F70  0B4007E5   J 0x9D001F94
9D001F74  00000000   NOP
9D001F94  8FC20020   LW V0, 32(S8)
9D001F98  90420000   LBU V0, 0(V0)
9D001F9C  A3C20010   SB V0, 16(S8)
9D001FA0  93C20010   LBU V0, 16(S8)
9D001FA4  2C420010   SLTIU V0, V0, 16
9D001FA8  38420001   XORI V0, V0, 1
9D001FAC  304200FF   ANDI V0, V0, 255
9D001FB0  8FC30020   LW V1, 32(S8)
9D001FB4  24630001   ADDIU V1, V1, 1
9D001FB8  AFC30020   SW V1, 32(S8)
9D001FBC  1440FFEE   BNE V0, ZERO, 0x9D001F78
9D001FC0  00000000   NOP
1514:                        while(OutChar(ch) == 0);
9D001F78  00000000   NOP
9D001F7C  83C20010   LB V0, 16(S8)
9D001F80  00402021   ADDU A0, V0, ZERO
9D001F84  0F40080F   JAL OutChar
9D001F88  00000000   NOP
9D001F8C  1040FFFB   BEQ V0, ZERO, 0x9D001F7C
9D001F90  00000000   NOP
1515:                    return (1);
9D001FC4  24020001   ADDIU V0, ZERO, 1
1516:                
1517:                    #else
1518:                
1519:                    XCHAR       ch;
1520:                    static WORD counter = 0;
1521:                
1522:                    while((unsigned XCHAR)(ch = *(textString + counter)) > (unsigned XCHAR)15)
1523:                    {
1524:                        if(OutChar(ch) == 0)
1525:                            return (0);
1526:                        counter++;
1527:                    }
1528:                
1529:                    counter = 0;
1530:                    return (1);
1531:                    #endif
1532:                }
9D001FC8  03C0E821   ADDU SP, S8, ZERO
9D001FCC  8FBF001C   LW RA, 28(SP)
9D001FD0  8FBE0018   LW S8, 24(SP)
9D001FD4  27BD0020   ADDIU SP, SP, 32
9D001FD8  03E00008   JR RA
9D001FDC  00000000   NOP
1533:                
1534:                /*********************************************************************
1535:                * Function: WORD OutTextXY(SHORT x, SHORT y, XCHAR* textString)
1536:                *
1537:                * PreCondition: none
1538:                *
1539:                * Input: x,y - starting coordinates, textString - pointer to text string
1540:                *
1541:                * Output: non-zero if drawing done (used for NON-BLOCKING configuration)
1542:                *
1543:                * Side Effects: none
1544:                *
1545:                * Overview: outputs text from x,y position
1546:                *
1547:                * Note: none
1548:                *
1549:                ********************************************************************/
1550:                WORD OutTextXY(SHORT x, SHORT y, XCHAR *textString)
1551:                {
9D001FE0  27BDFFE8   ADDIU SP, SP, -24
9D001FE4  AFBF0014   SW RA, 20(SP)
9D001FE8  AFBE0010   SW S8, 16(SP)
9D001FEC  03A0F021   ADDU S8, SP, ZERO
9D001FF0  00801821   ADDU V1, A0, ZERO
9D001FF4  00A01021   ADDU V0, A1, ZERO
9D001FF8  AFC60020   SW A2, 32(S8)
9D001FFC  A7C30018   SH V1, 24(S8)
9D002000  A7C2001C   SH V0, 28(S8)
1552:                    #ifndef USE_NONBLOCKING_CONFIG
1553:                    MoveTo(x, y);
9D002004  97C20018   LHU V0, 24(S8)
9D002008  A78281B0   SH V0, -32336(GP)
9D00200C  97C2001C   LHU V0, 28(S8)
9D002010  A78281A6   SH V0, -32346(GP)
1554:                    OutText(textString);
9D002014  8FC40020   LW A0, 32(S8)
9D002018  0F4007D7   JAL OutText
9D00201C  00000000   NOP
1555:                    return (1);
9D002020  24020001   ADDIU V0, ZERO, 1
1556:                
1557:                    #else
1558:                
1559:                    static BYTE start = 1;
1560:                
1561:                    if(start)
1562:                    {
1563:                        MoveTo(x, y);
1564:                        start = 0;
1565:                    }
1566:                
1567:                    if(OutText(textString) == 0)
1568:                    {
1569:                        return (0);
1570:                    }
1571:                    else
1572:                    {
1573:                        start = 1;
1574:                        return (1);
1575:                    }
1576:                
1577:                    #endif
1578:                }
9D002024  03C0E821   ADDU SP, S8, ZERO
9D002028  8FBF0014   LW RA, 20(SP)
9D00202C  8FBE0010   LW S8, 16(SP)
9D002030  27BD0018   ADDIU SP, SP, 24
9D002034  03E00008   JR RA
9D002038  00000000   NOP
1579:                
1580:                #ifndef USE_DRV_FONT
1581:                /*********************************************************************
1582:                * Function: WORD OutChar(XCHAR ch)
1583:                *
1584:                * PreCondition: none
1585:                *
1586:                * Input: character code
1587:                *
1588:                * Output: For NON-Blocking configuration:
1589:                *         - Returns 0 when device is busy and the character is not yet completely drawn.
1590:                *         - Returns 1 when the character is completely drawn.
1591:                *         For Blocking configuration:
1592:                *         - Always return 1.
1593:                *
1594:                * Side Effects: none
1595:                *
1596:                * Overview: outputs a character
1597:                *
1598:                * Note: none
1599:                *
1600:                ********************************************************************/
1601:                WORD OutChar(XCHAR ch)
1602:                {
9D00203C  27BDFFD0   ADDIU SP, SP, -48
9D002040  AFBF002C   SW RA, 44(SP)
9D002044  AFBE0028   SW S8, 40(SP)
9D002048  03A0F021   ADDU S8, SP, ZERO
9D00204C  00801021   ADDU V0, A0, ZERO
9D002050  A3C20030   SB V0, 48(S8)
1603:                    GLYPH_ENTRY *pChTable = NULL;
9D002054  AFC00020   SW ZERO, 32(S8)
1604:                    BYTE        *pChImage = NULL;
9D002058  AFC00010   SW ZERO, 16(S8)
1605:                
1606:                        #ifdef USE_FONT_EXTERNAL
1607:                    GLYPH_ENTRY chTable;
1608:                    BYTE        chImage[EXTERNAL_FONT_BUFFER_SIZE];
1609:                    WORD        imageSize;
1610:                    DWORD_VAL   glyphOffset;
1611:                        #endif
1612:                    SHORT       chWidth = 0;
9D00205C  A7C00014   SH ZERO, 20(S8)
1613:                    SHORT       xCnt, yCnt, x = 0, y;
9D002060  A7C0001A   SH ZERO, 26(S8)
1614:                    BYTE        temp = 0, mask;
9D002064  A3C0001E   SB ZERO, 30(S8)
1615:                
1616:                        #ifndef USE_NONBLOCKING_CONFIG
1617:                    while(IsDeviceBusy() != 0) Nop();
1618:                
1619:                    /* Ready */
1620:                        #else
1621:                    if(IsDeviceBusy() != 0)
1622:                        return (0);
1623:                        #endif
1624:                    if((unsigned XCHAR)ch < (unsigned XCHAR)_fontFirstChar)
9D002068  93C30030   LBU V1, 48(S8)
9D00206C  978281A0   LHU V0, -32352(GP)
9D002070  304200FF   ANDI V0, V0, 255
9D002074  0062102B   SLTU V0, V1, V0
9D002078  10400004   BEQ V0, ZERO, 0x9D00208C
9D00207C  00000000   NOP
1625:                        return (-1);
9D002080  3402FFFF   ORI V0, ZERO, -1
9D002084  0B4008CC   J 0x9D002330
9D002088  00000000   NOP
1626:                    if((unsigned XCHAR)ch > (unsigned XCHAR)_fontLastChar)
9D00208C  93C30030   LBU V1, 48(S8)
9D002090  978281A4   LHU V0, -32348(GP)
9D002094  304200FF   ANDI V0, V0, 255
9D002098  0043102B   SLTU V0, V0, V1
9D00209C  10400004   BEQ V0, ZERO, 0x9D0020B0
9D0020A0  00000000   NOP
1627:                        return (-1);
9D0020A4  3402FFFF   ORI V0, ZERO, -1
9D0020A8  0B4008CC   J 0x9D002330
9D0020AC  00000000   NOP
1628:                
1629:                    switch(*((SHORT *)_font))
9D0020B0  8F8281AC   LW V0, -32340(GP)
9D0020B4  84420000   LH V0, 0(V0)
9D0020B8  1440001C   BNE V0, ZERO, 0x9D00212C
9D0020BC  00000000   NOP
1630:                    {
1631:                                #ifdef USE_FONT_FLASH
1632:                
1633:                        case FLASH:
1634:                            pChTable = (GLYPH_ENTRY *) (((FONT_FLASH *)_font)->address + sizeof(FONT_HEADER)) + ((unsigned XCHAR)ch - (unsigned XCHAR)_fontFirstChar);
9D0020C0  8F8281AC   LW V0, -32340(GP)
9D0020C4  8C420004   LW V0, 4(V0)
9D0020C8  00401821   ADDU V1, V0, ZERO
9D0020CC  93C20030   LBU V0, 48(S8)
9D0020D0  00402021   ADDU A0, V0, ZERO
9D0020D4  978281A0   LHU V0, -32352(GP)
9D0020D8  304200FF   ANDI V0, V0, 255
9D0020DC  00821023   SUBU V0, A0, V0
9D0020E0  24420002   ADDIU V0, V0, 2
9D0020E4  00021080   SLL V0, V0, 2
9D0020E8  00621021   ADDU V0, V1, V0
9D0020EC  AFC20020   SW V0, 32(S8)
1635:                
1636:                            pChImage = (BYTE *) (((FONT_FLASH *)_font)->address + ((DWORD)(pChTable->offsetMSB) << 8) + pChTable->offsetLSB);
9D0020F0  8F8281AC   LW V0, -32340(GP)
9D0020F4  8C430004   LW V1, 4(V0)
9D0020F8  8FC20020   LW V0, 32(S8)
9D0020FC  94420002   LHU V0, 2(V0)
9D002100  00022200   SLL A0, V0, 8
9D002104  8FC20020   LW V0, 32(S8)
9D002108  90420001   LBU V0, 1(V0)
9D00210C  00821021   ADDU V0, A0, V0
9D002110  00621021   ADDU V0, V1, V0
9D002114  AFC20010   SW V0, 16(S8)
1637:                
1638:                            chWidth = pChTable->width;
9D002118  8FC20020   LW V0, 32(S8)
9D00211C  90420000   LBU V0, 0(V0)
9D002120  A7C20014   SH V0, 20(S8)
1639:                
1640:                            break;
9D002124  0B40084C   J 0x9D002130
9D002128  00000000   NOP
1641:                                #endif
1642:                                #ifdef USE_FONT_EXTERNAL
1643:                
1644:                        case EXTERNAL:
1645:                
1646:                            // get glyph entry
1647:                            ExternalMemoryCallback
1648:                            (
1649:                                _font,
1650:                                sizeof(FONT_HEADER) + ((unsigned XCHAR)ch - (unsigned XCHAR)_fontFirstChar) * sizeof(GLYPH_ENTRY),
1651:                                sizeof(GLYPH_ENTRY),
1652:                                &chTable
1653:                            );
1654:                
1655:                            chWidth = chTable.width;
1656:                
1657:                            // width of glyph in bytes
1658:                            imageSize = 0;
1659:                            if(chWidth & 0x0007)
1660:                                imageSize = 1;
1661:                            imageSize += (chWidth >> 3);
1662:                
1663:                            // glyph image size
1664:                            imageSize *= _fontHeight;
1665:                
1666:                            // get glyph image
1667:                            glyphOffset.w[1] = (chTable.offsetMSB >> 8);
1668:                            glyphOffset.w[0] = (chTable.offsetMSB << 8) + (chTable.offsetLSB);
1669:                
1670:                            ExternalMemoryCallback(_font, glyphOffset.Val, imageSize, &chImage);
1671:                            pChImage = (BYTE *) &chImage;
1672:                
1673:                            break;
1674:                                #endif
1675:                
1676:                        default:
1677:                            break;
9D00212C  00000000   NOP
1678:                    }
1679:                
1680:                    if(_fontOrientation == ORIENT_HOR)
9D002130  938281B2   LBU V0, -32334(GP)
9D002134  14400040   BNE V0, ZERO, 0x9D002238
9D002138  00000000   NOP
1681:                    {
1682:                        y = GetY();
9D00213C  978281A6   LHU V0, -32346(GP)
9D002140  A7C2001C   SH V0, 28(S8)
1683:                        for(yCnt = 0; yCnt < _fontHeight; yCnt++)
9D002144  A7C00018   SH ZERO, 24(S8)
9D002148  0B400885   J 0x9D002214
9D00214C  00000000   NOP
9D002208  97C20018   LHU V0, 24(S8)
9D00220C  24420001   ADDIU V0, V0, 1
9D002210  A7C20018   SH V0, 24(S8)
9D002214  878281A8   LH V0, -32344(GP)
9D002218  87C30018   LH V1, 24(S8)
9D00221C  0062102A   SLT V0, V1, V0
9D002220  1440FFCB   BNE V0, ZERO, 0x9D002150
9D002224  00000000   NOP
1684:                        {
1685:                            x = GetX();
9D002150  978281B0   LHU V0, -32336(GP)
9D002154  A7C2001A   SH V0, 26(S8)
1686:                            mask = 0;
9D002158  A3C0001F   SB ZERO, 31(S8)
1687:                            for(xCnt = 0; xCnt < chWidth; xCnt++)
9D00215C  A7C00016   SH ZERO, 22(S8)
9D002160  0B40087A   J 0x9D0021E8
9D002164  00000000   NOP
9D0021DC  97C20016   LHU V0, 22(S8)
9D0021E0  24420001   ADDIU V0, V0, 1
9D0021E4  A7C20016   SH V0, 22(S8)
9D0021E8  87C30016   LH V1, 22(S8)
9D0021EC  87C20014   LH V0, 20(S8)
9D0021F0  0062102A   SLT V0, V1, V0
9D0021F4  1440FFDC   BNE V0, ZERO, 0x9D002168
9D0021F8  00000000   NOP
1688:                            {
1689:                                if(mask == 0)
9D002168  93C2001F   LBU V0, 31(S8)
9D00216C  14400009   BNE V0, ZERO, 0x9D002194
9D002170  00000000   NOP
1690:                                {
1691:                                    temp = *pChImage++;
9D002174  8FC20010   LW V0, 16(S8)
9D002178  90420000   LBU V0, 0(V0)
9D00217C  A3C2001E   SB V0, 30(S8)
9D002180  8FC20010   LW V0, 16(S8)
9D002184  24420001   ADDIU V0, V0, 1
9D002188  AFC20010   SW V0, 16(S8)
1692:                                    mask = 0x01;
9D00218C  24020001   ADDIU V0, ZERO, 1
9D002190  A3C2001F   SB V0, 31(S8)
1693:                                }
1694:                
1695:                                if(temp & mask)
9D002194  93C3001E   LBU V1, 30(S8)
9D002198  93C2001F   LBU V0, 31(S8)
9D00219C  00621024   AND V0, V1, V0
9D0021A0  304200FF   ANDI V0, V0, 255
9D0021A4  10400007   BEQ V0, ZERO, 0x9D0021C4
9D0021A8  00000000   NOP
1696:                                {
1697:                                    PutPixel(x, y);
9D0021AC  87C3001A   LH V1, 26(S8)
9D0021B0  87C2001C   LH V0, 28(S8)
9D0021B4  00602021   ADDU A0, V1, ZERO
9D0021B8  00402821   ADDU A1, V0, ZERO
9D0021BC  0F400B3A   JAL PutPixel
9D0021C0  00000000   NOP
1698:                                }
1699:                
1700:                                x++;
9D0021C4  97C2001A   LHU V0, 26(S8)
9D0021C8  24420001   ADDIU V0, V0, 1
9D0021CC  A7C2001A   SH V0, 26(S8)
1701:                                mask <<= 1;
9D0021D0  93C2001F   LBU V0, 31(S8)
9D0021D4  00021040   SLL V0, V0, 1
9D0021D8  A3C2001F   SB V0, 31(S8)
1702:                            }
1703:                
1704:                            y++;
9D0021FC  97C2001C   LHU V0, 28(S8)
9D002200  24420001   ADDIU V0, V0, 1
9D002204  A7C2001C   SH V0, 28(S8)
1705:                        }
1706:                
1707:                        // move cursor
1708:                        _cursorX = x;
9D002228  97C2001A   LHU V0, 26(S8)
9D00222C  A78281B0   SH V0, -32336(GP)
9D002230  0B4008CB   J 0x9D00232C
9D002234  00000000   NOP
1709:                    }
1710:                    else
1711:                    {
1712:                        y = GetX();
9D002238  978281B0   LHU V0, -32336(GP)
9D00223C  A7C2001C   SH V0, 28(S8)
1713:                        for(yCnt = 0; yCnt < _fontHeight; yCnt++)
9D002240  A7C00018   SH ZERO, 24(S8)
9D002244  0B4008C4   J 0x9D002310
9D002248  00000000   NOP
9D002304  97C20018   LHU V0, 24(S8)
9D002308  24420001   ADDIU V0, V0, 1
9D00230C  A7C20018   SH V0, 24(S8)
9D002310  878281A8   LH V0, -32344(GP)
9D002314  87C30018   LH V1, 24(S8)
9D002318  0062102A   SLT V0, V1, V0
9D00231C  1440FFCB   BNE V0, ZERO, 0x9D00224C
9D002320  00000000   NOP
1714:                        {
1715:                            x = GetY();
9D00224C  978281A6   LHU V0, -32346(GP)
9D002250  A7C2001A   SH V0, 26(S8)
1716:                            mask = 0; 
9D002254  A3C0001F   SB ZERO, 31(S8)
1717:                            for(xCnt = 0; xCnt < chWidth; xCnt++)
9D002258  A7C00016   SH ZERO, 22(S8)
9D00225C  0B4008B9   J 0x9D0022E4
9D002260  00000000   NOP
9D0022D8  97C20016   LHU V0, 22(S8)
9D0022DC  24420001   ADDIU V0, V0, 1
9D0022E0  A7C20016   SH V0, 22(S8)
9D0022E4  87C30016   LH V1, 22(S8)
9D0022E8  87C20014   LH V0, 20(S8)
9D0022EC  0062102A   SLT V0, V1, V0
9D0022F0  1440FFDC   BNE V0, ZERO, 0x9D002264
9D0022F4  00000000   NOP
1718:                            {
1719:                                if(mask == 0)
9D002264  93C2001F   LBU V0, 31(S8)
9D002268  14400009   BNE V0, ZERO, 0x9D002290
9D00226C  00000000   NOP
1720:                                {
1721:                                    temp = *pChImage++;
9D002270  8FC20010   LW V0, 16(S8)
9D002274  90420000   LBU V0, 0(V0)
9D002278  A3C2001E   SB V0, 30(S8)
9D00227C  8FC20010   LW V0, 16(S8)
9D002280  24420001   ADDIU V0, V0, 1
9D002284  AFC20010   SW V0, 16(S8)
1722:                                    mask = 0x01; 
9D002288  24020001   ADDIU V0, ZERO, 1
9D00228C  A3C2001F   SB V0, 31(S8)
1723:                                }
1724:                
1725:                                if(temp & mask)
9D002290  93C3001E   LBU V1, 30(S8)
9D002294  93C2001F   LBU V0, 31(S8)
9D002298  00621024   AND V0, V1, V0
9D00229C  304200FF   ANDI V0, V0, 255
9D0022A0  10400007   BEQ V0, ZERO, 0x9D0022C0
9D0022A4  00000000   NOP
1726:                                {
1727:                                    PutPixel(y, x);
9D0022A8  87C3001C   LH V1, 28(S8)
9D0022AC  87C2001A   LH V0, 26(S8)
9D0022B0  00602021   ADDU A0, V1, ZERO
9D0022B4  00402821   ADDU A1, V0, ZERO
9D0022B8  0F400B3A   JAL PutPixel
9D0022BC  00000000   NOP
1728:                                }
1729:                
1730:                                x--;
9D0022C0  97C2001A   LHU V0, 26(S8)
9D0022C4  2442FFFF   ADDIU V0, V0, -1
9D0022C8  A7C2001A   SH V0, 26(S8)
1731:                                mask <<= 1;
9D0022CC  93C2001F   LBU V0, 31(S8)
9D0022D0  00021040   SLL V0, V0, 1
9D0022D4  A3C2001F   SB V0, 31(S8)
1732:                            }
1733:                
1734:                            y++;
9D0022F8  97C2001C   LHU V0, 28(S8)
9D0022FC  24420001   ADDIU V0, V0, 1
9D002300  A7C2001C   SH V0, 28(S8)
1735:                        }
1736:                
1737:                        // move cursor
1738:                        _cursorY = x;
9D002324  97C2001A   LHU V0, 26(S8)
9D002328  A78281A6   SH V0, -32346(GP)
1739:                    }
1740:                
1741:                    return (1);
9D00232C  24020001   ADDIU V0, ZERO, 1
1742:                }
9D002330  03C0E821   ADDU SP, S8, ZERO
9D002334  8FBF002C   LW RA, 44(SP)
9D002338  8FBE0028   LW S8, 40(SP)
9D00233C  27BD0030   ADDIU SP, SP, 48
9D002340  03E00008   JR RA
9D002344  00000000   NOP
1743:                
1744:                #endif
1745:                
1746:                /*********************************************************************
1747:                * Function: SHORT GetTextWidth(XCHAR* textString, void* font)
1748:                *
1749:                * PreCondition: none
1750:                *
1751:                * Input: textString - pointer to the text string,
1752:                *        font - pointer to the font
1753:                *
1754:                * Output: text width in pixels
1755:                *
1756:                * Side Effects: none
1757:                *
1758:                * Overview: returns text width for the font
1759:                *
1760:                * Note: none
1761:                *
1762:                ********************************************************************/
1763:                SHORT GetTextWidth(XCHAR *textString, void *font)
1764:                {
9D002348  27BDFFE0   ADDIU SP, SP, -32
9D00234C  AFBE001C   SW S8, 28(SP)
9D002350  03A0F021   ADDU S8, SP, ZERO
9D002354  AFC40020   SW A0, 32(S8)
9D002358  AFC50024   SW A1, 36(S8)
1765:                    GLYPH_ENTRY *pChTable;
1766:                    FONT_HEADER *pHeader;
1767:                        #ifdef USE_FONT_EXTERNAL
1768:                    GLYPH_ENTRY chTable;
1769:                    FONT_HEADER header;
1770:                        #endif
1771:                    SHORT       textWidth;
1772:                
1773:                    //SHORT        temp;
1774:                    XCHAR       ch;
1775:                    XCHAR       fontFirstChar;
1776:                    XCHAR       fontLastChar;
1777:                
1778:                    switch(*((SHORT *)font))
9D00235C  8FC20024   LW V0, 36(S8)
9D002360  84420000   LH V0, 0(V0)
9D002364  1440003C   BNE V0, ZERO, 0x9D002458
9D002368  00000000   NOP
1779:                    {
1780:                                #ifdef USE_FONT_RAM
1781:                
1782:                        case RAM:
1783:                            pHeader = (FONT_HEADER *) ((FONT_RAM *)font)->address;
1784:                            fontFirstChar = pHeader->firstChar;
1785:                            fontLastChar = pHeader->lastChar;
1786:                            pChTable = (GLYPH_ENTRY *) (pHeader + 1);
1787:                            textWidth = 0;
1788:                            while((unsigned XCHAR)15 < (unsigned XCHAR)(ch = *textString++))
1789:                            {
1790:                                if((unsigned XCHAR)ch < (unsigned XCHAR)fontFirstChar)
1791:                                    continue;
1792:                                if((unsigned XCHAR)ch > (unsigned XCHAR)fontLastChar)
1793:                                    continue;
1794:                                textWidth += (pChTable + ((unsigned XCHAR)ch - (unsigned XCHAR)fontFirstChar))->width;
1795:                            }
1796:                
1797:                            return (textWidth);
1798:                                #endif
1799:                                	    
1800:                                #ifdef USE_FONT_FLASH
1801:                
1802:                        case FLASH:
1803:                            pHeader = (FONT_HEADER *) ((FONT_FLASH *)font)->address;
9D00236C  8FC20024   LW V0, 36(S8)
9D002370  8C420004   LW V0, 4(V0)
9D002374  AFC20004   SW V0, 4(S8)
1804:                            fontFirstChar = pHeader->firstChar;
9D002378  8FC20004   LW V0, 4(S8)
9D00237C  94420002   LHU V0, 2(V0)
9D002380  A3C20008   SB V0, 8(S8)
1805:                            fontLastChar = pHeader->lastChar;
9D002384  8FC20004   LW V0, 4(S8)
9D002388  94420004   LHU V0, 4(V0)
9D00238C  A3C20009   SB V0, 9(S8)
1806:                            pChTable = (GLYPH_ENTRY *) (pHeader + 1);
9D002390  8FC20004   LW V0, 4(S8)
9D002394  24420008   ADDIU V0, V0, 8
9D002398  AFC2000C   SW V0, 12(S8)
1807:                            textWidth = 0;
9D00239C  A7C00000   SH ZERO, 0(S8)
1808:                            while((unsigned XCHAR)15 < (unsigned XCHAR)(ch = *textString++))
9D0023A0  0B400907   J 0x9D00241C
9D0023A4  00000000   NOP
9D00241C  8FC20020   LW V0, 32(S8)
9D002420  90420000   LBU V0, 0(V0)
9D002424  A3C20010   SB V0, 16(S8)
9D002428  93C20010   LBU V0, 16(S8)
9D00242C  2C420010   SLTIU V0, V0, 16
9D002430  38420001   XORI V0, V0, 1
9D002434  304200FF   ANDI V0, V0, 255
9D002438  8FC30020   LW V1, 32(S8)
9D00243C  24630001   ADDIU V1, V1, 1
9D002440  AFC30020   SW V1, 32(S8)
9D002444  1440FFD8   BNE V0, ZERO, 0x9D0023A8
9D002448  00000000   NOP
1809:                            {
1810:                                if((unsigned XCHAR)ch < (unsigned XCHAR)fontFirstChar)
9D0023A8  93C30010   LBU V1, 16(S8)
9D0023AC  93C20008   LBU V0, 8(S8)
9D0023B0  0062102B   SLTU V0, V1, V0
9D0023B4  14400015   BNE V0, ZERO, 0x9D00240C
9D0023B8  00000000   NOP
1811:                                    continue;
9D00240C  00000000   NOP
9D002410  0B400907   J 0x9D00241C
9D002414  00000000   NOP
1812:                                if((unsigned XCHAR)ch > (unsigned XCHAR)fontLastChar)
9D0023BC  93C30010   LBU V1, 16(S8)
9D0023C0  93C20009   LBU V0, 9(S8)
9D0023C4  0043102B   SLTU V0, V0, V1
9D0023C8  14400013   BNE V0, ZERO, 0x9D002418
9D0023CC  00000000   NOP
1813:                                    continue;
9D002418  00000000   NOP
1814:                                textWidth += (pChTable + ((unsigned XCHAR)ch - (unsigned XCHAR)fontFirstChar))->width;
9D0023D0  93C20010   LBU V0, 16(S8)
9D0023D4  00401821   ADDU V1, V0, ZERO
9D0023D8  93C20008   LBU V0, 8(S8)
9D0023DC  00621023   SUBU V0, V1, V0
9D0023E0  00021080   SLL V0, V0, 2
9D0023E4  8FC3000C   LW V1, 12(S8)
9D0023E8  00621021   ADDU V0, V1, V0
9D0023EC  90420000   LBU V0, 0(V0)
9D0023F0  00401821   ADDU V1, V0, ZERO
9D0023F4  97C20000   LHU V0, 0(S8)
9D0023F8  00621021   ADDU V0, V1, V0
9D0023FC  3042FFFF   ANDI V0, V0, -1
9D002400  A7C20000   SH V0, 0(S8)
9D002404  0B400907   J 0x9D00241C
9D002408  00000000   NOP
1815:                            }
1816:                
1817:                            return (textWidth);
9D00244C  87C20000   LH V0, 0(S8)
9D002450  0B400917   J 0x9D00245C
9D002454  00000000   NOP
1818:                                #endif
1819:                                #ifdef USE_FONT_EXTERNAL
1820:                
1821:                        case EXTERNAL:
1822:                            ExternalMemoryCallback(font, 0, sizeof(FONT_HEADER), &header);
1823:                            fontFirstChar = header.firstChar;
1824:                            fontLastChar = header.lastChar;
1825:                            textWidth = 0;
1826:                            while((unsigned XCHAR)15 < (unsigned XCHAR)(ch = *textString++))
1827:                            {
1828:                                if((unsigned XCHAR)ch < (unsigned XCHAR)fontFirstChar)
1829:                                    continue;
1830:                                if((unsigned XCHAR)ch > (unsigned XCHAR)fontLastChar)
1831:                                    continue;
1832:                                ExternalMemoryCallback
1833:                                (
1834:                                    font,
1835:                                    sizeof(FONT_HEADER) + sizeof(GLYPH_ENTRY) * ((unsigned XCHAR)ch - (unsigned XCHAR)fontFirstChar),
1836:                                    sizeof(GLYPH_ENTRY),
1837:                                    &chTable
1838:                                );
1839:                                textWidth += chTable.width;
1840:                            }
1841:                
1842:                            return (textWidth);
1843:                                #endif
1844:                
1845:                        default:
1846:                            return (0);
9D002458  00001021   ADDU V0, ZERO, ZERO
1847:                    }
1848:                }
9D00245C  03C0E821   ADDU SP, S8, ZERO
9D002460  8FBE001C   LW S8, 28(SP)
9D002464  27BD0020   ADDIU SP, SP, 32
9D002468  03E00008   JR RA
9D00246C  00000000   NOP
1849:                
1850:                /*********************************************************************
1851:                * Function: SHORT GetTextHeight(void* font)
1852:                *
1853:                * PreCondition: none
1854:                *
1855:                * Input: pointer to the font
1856:                *
1857:                * Output: character height in pixels
1858:                *
1859:                * Side Effects: none
1860:                *
1861:                * Overview: returns characters height for the font
1862:                *
1863:                * Note: none
1864:                *
1865:                ********************************************************************/
1866:                SHORT GetTextHeight(void *font)
1867:                {
9D002470  27BDFFF8   ADDIU SP, SP, -8
9D002474  AFBE0004   SW S8, 4(SP)
9D002478  03A0F021   ADDU S8, SP, ZERO
9D00247C  AFC40008   SW A0, 8(S8)
1868:                        #ifdef USE_FONT_EXTERNAL
1869:                
1870:                    char    height;
1871:                        #endif
1872:                    switch(*((SHORT *)font))
9D002480  8FC20008   LW V0, 8(S8)
9D002484  84420000   LH V0, 0(V0)
9D002488  14400007   BNE V0, ZERO, 0x9D0024A8
9D00248C  00000000   NOP
1873:                    {
1874:                                #ifdef USE_FONT_RAM
1875:                        case RAM:
1876:                            return ((FONT_HEADER *) ((FONT_RAM *)font)->address)->height;
1877:                                #endif
1878:                                
1879:                                #ifdef USE_FONT_FLASH
1880:                        case FLASH:
1881:                            return ((FONT_HEADER *) ((FONT_FLASH *)font)->address)->height;
9D002490  8FC20008   LW V0, 8(S8)
9D002494  8C420004   LW V0, 4(V0)
9D002498  90420006   LBU V0, 6(V0)
9D00249C  7C021620   SEH V0, V0
9D0024A0  0B40092B   J 0x9D0024AC
9D0024A4  00000000   NOP
1882:                                #endif
1883:                                
1884:                                #ifdef USE_FONT_EXTERNAL
1885:                        case EXTERNAL:
1886:                            ExternalMemoryCallback(font, sizeof(FONT_HEADER) - 1, 1, &height);
1887:                            return (height);
1888:                                #endif
1889:                
1890:                        default:
1891:                            return (0);
9D0024A8  00001021   ADDU V0, ZERO, ZERO
1892:                    }
1893:                }
9D0024AC  03C0E821   ADDU SP, S8, ZERO
9D0024B0  8FBE0004   LW S8, 4(SP)
9D0024B4  27BD0008   ADDIU SP, SP, 8
9D0024B8  03E00008   JR RA
9D0024BC  00000000   NOP
1894:                
1895:                /*********************************************************************
1896:                * Function: SHORT GetImageWidth(void* bitmap)
1897:                *
1898:                * PreCondition: none
1899:                *
1900:                * Input: bitmap - image pointer
1901:                *
1902:                * Output: none
1903:                *
1904:                * Side Effects: none
1905:                *
1906:                * Overview: returns image width
1907:                *
1908:                * Note: none
1909:                *
1910:                ********************************************************************/
1911:                SHORT GetImageWidth(void *bitmap)
1912:                {
9D0024C0  27BDFFF8   ADDIU SP, SP, -8
9D0024C4  AFBE0004   SW S8, 4(SP)
9D0024C8  03A0F021   ADDU S8, SP, ZERO
9D0024CC  AFC40008   SW A0, 8(S8)
1913:                    #ifdef USE_BITMAP_EXTERNAL
1914:                
1915:                    SHORT   width;
1916:                    #endif
1917:                    switch(*((SHORT *)bitmap))
9D0024D0  8FC20008   LW V0, 8(S8)
9D0024D4  84420000   LH V0, 0(V0)
9D0024D8  14400008   BNE V0, ZERO, 0x9D0024FC
9D0024DC  00000000   NOP
1918:                    {
1919:                            #ifdef USE_BITMAP_FLASH
1920:                
1921:                        case FLASH:
1922:                            return (*((FLASH_WORD *) ((BITMAP_FLASH *)bitmap)->address + 2));
9D0024E0  8FC20008   LW V0, 8(S8)
9D0024E4  8C420004   LW V0, 4(V0)
9D0024E8  24420004   ADDIU V0, V0, 4
9D0024EC  94420000   LHU V0, 0(V0)
9D0024F0  7C021620   SEH V0, V0
9D0024F4  0B400940   J 0x9D002500
9D0024F8  00000000   NOP
1923:                            #endif
1924:                            #ifdef USE_BITMAP_EXTERNAL
1925:                
1926:                        case EXTERNAL:
1927:                            ExternalMemoryCallback(bitmap, 4, 2, &width);
1928:                            return (width);
1929:                            #endif
1930:                
1931:                        default:
1932:                            return (0);
9D0024FC  00001021   ADDU V0, ZERO, ZERO
1933:                    }
1934:                }
9D002500  03C0E821   ADDU SP, S8, ZERO
9D002504  8FBE0004   LW S8, 4(SP)
9D002508  27BD0008   ADDIU SP, SP, 8
9D00250C  03E00008   JR RA
9D002510  00000000   NOP
1935:                
1936:                /*********************************************************************
1937:                * Function: SHORT GetImageHeight(void* bitmap)
1938:                *
1939:                * PreCondition: none
1940:                *
1941:                * Input: bitmap - image pointer
1942:                *
1943:                * Output: none
1944:                *
1945:                * Side Effects: none
1946:                *
1947:                * Overview: returns image height
1948:                *
1949:                * Note: none
1950:                *
1951:                ********************************************************************/
1952:                SHORT GetImageHeight(void *bitmap)
1953:                {
9D002514  27BDFFF8   ADDIU SP, SP, -8
9D002518  AFBE0004   SW S8, 4(SP)
9D00251C  03A0F021   ADDU S8, SP, ZERO
9D002520  AFC40008   SW A0, 8(S8)
1954:                    #ifdef USE_BITMAP_EXTERNAL
1955:                
1956:                    SHORT   height;
1957:                    #endif
1958:                    switch(*((SHORT *)bitmap))
9D002524  8FC20008   LW V0, 8(S8)
9D002528  84420000   LH V0, 0(V0)
9D00252C  14400008   BNE V0, ZERO, 0x9D002550
9D002530  00000000   NOP
1959:                    {
1960:                            #ifdef USE_BITMAP_FLASH
1961:                
1962:                        case FLASH:
1963:                            return (*((FLASH_WORD *) ((BITMAP_FLASH *)bitmap)->address + 1));
9D002534  8FC20008   LW V0, 8(S8)
9D002538  8C420004   LW V0, 4(V0)
9D00253C  24420002   ADDIU V0, V0, 2
9D002540  94420000   LHU V0, 0(V0)
9D002544  7C021620   SEH V0, V0
9D002548  0B400955   J 0x9D002554
9D00254C  00000000   NOP
1964:                            #endif
1965:                            #ifdef USE_BITMAP_EXTERNAL
1966:                
1967:                        case EXTERNAL:
1968:                            ExternalMemoryCallback(bitmap, 2, 2, &height);
1969:                            return (height);
1970:                            #endif
1971:                
1972:                        default:
1973:                            return (0);
9D002550  00001021   ADDU V0, ZERO, ZERO
1974:                    }
1975:                }
9D002554  03C0E821   ADDU SP, S8, ZERO
9D002558  8FBE0004   LW S8, 4(SP)
9D00255C  27BD0008   ADDIU SP, SP, 8
9D002560  03E00008   JR RA
9D002564  00000000   NOP
1976:                
1977:                #ifndef USE_DRV_PUTIMAGE
1978:                
1979:                /*********************************************************************
1980:                * Function: WORD PutImage(SHORT left, SHORT top, void* bitmap, BYTE stretch)
1981:                *
1982:                * PreCondition: none
1983:                *
1984:                * Input: left,top - left top image corner,
1985:                *        bitmap - image pointer,
1986:                *        stretch - image stretch factor
1987:                *
1988:                * Output: For NON-Blocking configuration:
1989:                *         - Returns 0 when device is busy and the image is not yet completely drawn.
1990:                *         - Returns 1 when the image is completely drawn.
1991:                *         For Blocking configuration:
1992:                *         - Always return 1.
1993:                *
1994:                * Side Effects: none
1995:                *
1996:                * Overview: outputs image starting from left,top coordinates
1997:                *
1998:                * Note: image must be located in flash
1999:                *
2000:                ********************************************************************/
2001:                WORD PutImage(SHORT left, SHORT top, void *bitmap, BYTE stretch)
2002:                {
2003:                    FLASH_BYTE  *flashAddress;
2004:                    BYTE        colorDepth;
2005:                    WORD        colorTemp;
2006:                
2007:                        #ifndef USE_NONBLOCKING_CONFIG
2008:                    while(IsDeviceBusy() != 0) Nop();
2009:                
2010:                    /* Ready */
2011:                        #else
2012:                    if(IsDeviceBusy() != 0)
2013:                        return (0);
2014:                        #endif
2015:                
2016:                    // Save current color
2017:                    colorTemp = GetColor();
2018:                
2019:                    switch(*((SHORT *)bitmap))
2020:                    {
2021:                                #ifdef USE_BITMAP_FLASH
2022:                
2023:                        case FLASH:
2024:                
2025:                            // Image address
2026:                            flashAddress = ((BITMAP_FLASH *)bitmap)->address;
2027:                
2028:                            // Read color depth
2029:                            colorDepth = *(flashAddress + 1);
2030:                
2031:                            // Draw picture
2032:                            switch(colorDepth)
2033:                            {
2034:                                case 1:     PutImage1BPP(left, top, flashAddress, stretch); break; 
2035:                                
2036:                                    #if (COLOR_DEPTH >= 4)
2037:                                case 4:     PutImage4BPP(left, top, flashAddress, stretch); break; 
2038:                                    #endif
2039:                                    
2040:                                    #if (COLOR_DEPTH >= 8)
2041:                                case 8:     PutImage8BPP(left, top, flashAddress, stretch); break;
2042:                                    #endif
2043:                                    
2044:                                    #if (COLOR_DEPTH == 16)
2045:                                case 16:    PutImage16BPP(left, top, flashAddress, stretch); break;
2046:                                    #endif
2047:                                    
2048:                                default:    break;
2049:                            }
2050:                
2051:                            break;
2052:                                #endif
2053:                                
2054:                                #ifdef USE_BITMAP_EXTERNAL
2055:                
2056:                        case EXTERNAL:
2057:                
2058:                            // Get color depth
2059:                            ExternalMemoryCallback(bitmap, 1, 1, &colorDepth);
2060:                
2061:                            // Draw picture
2062:                            switch(colorDepth)
2063:                            {
2064:                                case 1:     PutImage1BPPExt(left, top, bitmap, stretch); break;
2065:                                
2066:                                    #if (COLOR_DEPTH >= 4)
2067:                                case 4:     PutImage4BPPExt(left, top, bitmap, stretch); break;
2068:                                    #endif
2069:                                    
2070:                                    #if (COLOR_DEPTH >= 8)
2071:                                case 8:     PutImage8BPPExt(left, top, bitmap, stretch); break;
2072:                                    #endif
2073:                                    
2074:                                    #if (COLOR_DEPTH == 16)
2075:                                case 16:    PutImage16BPPExt(left, top, bitmap, stretch); break;
2076:                                    #endif
2077:                                    
2078:                                default:    break;
2079:                            }
2080:                
2081:                            break;
2082:                                #endif
2083:                
2084:                        default:
2085:                            break;
2086:                    }
2087:                
2088:                    // Restore current color
2089:                    SetColor(colorTemp);
2090:                    return (1);
2091:                }
2092:                
2093:                    #ifdef USE_BITMAP_FLASH
2094:                
2095:                /*********************************************************************
2096:                * Function: void PutImage1BPP(SHORT left, SHORT top, FLASH_BYTE* bitmap, BYTE stretch)
2097:                *
2098:                * PreCondition: none
2099:                *
2100:                * Input: left,top - left top image corner,
2101:                *        bitmap - image pointer,
2102:                *        stretch - image stretch factor
2103:                *
2104:                * Output: none
2105:                *
2106:                * Side Effects: none
2107:                *
2108:                * Overview: outputs monochrome image starting from left,top coordinates
2109:                *
2110:                * Note: image must be located in flash
2111:                *
2112:                ********************************************************************/
2113:                void PutImage1BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch)
2114:                {
2115:                    register FLASH_BYTE *flashAddress;
2116:                    register FLASH_BYTE *tempFlashAddress;
2117:                    BYTE                temp = 0;
2118:                    WORD                sizeX, sizeY;
2119:                    WORD                x, y;
2120:                    WORD                xc, yc;
2121:                    BYTE                stretchX, stretchY;
2122:                    WORD                pallete[2];
2123:                    BYTE                mask;
2124:                
2125:                    // Move pointer to size information
2126:                    flashAddress = bitmap + 2;
2127:                
2128:                    // Read image size
2129:                    sizeY = *((FLASH_WORD *)flashAddress);
2130:                    flashAddress += 2;
2131:                    sizeX = *((FLASH_WORD *)flashAddress);
2132:                    flashAddress += 2;
2133:                    pallete[0] = *((FLASH_WORD *)flashAddress);
2134:                    flashAddress += 2;
2135:                    pallete[1] = *((FLASH_WORD *)flashAddress);
2136:                    flashAddress += 2;
2137:                
2138:                    yc = top;
2139:                    for(y = 0; y < sizeY; y++)
2140:                    {
2141:                        tempFlashAddress = flashAddress;
2142:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2143:                        {
2144:                            flashAddress = tempFlashAddress;
2145:                            mask = 0;
2146:                            xc = left;
2147:                            for(x = 0; x < sizeX; x++)
2148:                            {
2149:                
2150:                                // Read 8 pixels from flash
2151:                                if(mask == 0)
2152:                                {
2153:                                    temp = *flashAddress;
2154:                                    flashAddress++;
2155:                                    mask = 0x80;
2156:                                }
2157:                
2158:                                // Set color
2159:                                if(mask & temp)
2160:                                {
2161:                                    SetColor(pallete[1]);
2162:                                }
2163:                                else
2164:                                {
2165:                                    SetColor(pallete[0]);
2166:                                }
2167:                
2168:                                // Write pixel to screen
2169:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2170:                                {
2171:                                    PutPixel(xc++, yc);
2172:                                }
2173:                
2174:                                // Shift to the next pixel
2175:                                mask >>= 1;
2176:                            }
2177:                
2178:                            yc++;
2179:                        }
2180:                    }
2181:                }
2182:                
2183:                /*********************************************************************
2184:                * Function: void PutImage4BPP(SHORT left, SHORT top, FLASH_BYTE* bitmap, BYTE stretch)
2185:                *
2186:                * PreCondition: none
2187:                *
2188:                * Input: left,top - left top image corner, bitmap - image pointer,
2189:                *        stretch - image stretch factor
2190:                *
2191:                * Output: none
2192:                *
2193:                * Side Effects: none
2194:                *
2195:                * Overview: outputs 16 color image starting from left,top coordinates
2196:                *
2197:                * Note: image must be located in flash
2198:                *
2199:                ********************************************************************/
2200:                        #if (COLOR_DEPTH >= 4)
2201:                
2202:                /* */
2203:                void PutImage4BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch)
2204:                {
2205:                    register FLASH_BYTE *flashAddress;
2206:                    register FLASH_BYTE *tempFlashAddress;
2207:                    WORD                sizeX, sizeY;
2208:                    register WORD       x, y;
2209:                    WORD                xc, yc;
2210:                    BYTE                temp = 0;
2211:                    register BYTE       stretchX, stretchY;
2212:                    WORD                pallete[16];
2213:                    WORD                counter;
2214:                
2215:                    // Move pointer to size information
2216:                    flashAddress = bitmap + 2;
2217:                
2218:                    // Read image size
2219:                    sizeY = *((FLASH_WORD *)flashAddress);
2220:                    flashAddress += 2;
2221:                    sizeX = *((FLASH_WORD *)flashAddress);
2222:                    flashAddress += 2;
2223:                
2224:                    // Read pallete
2225:                    for(counter = 0; counter < 16; counter++)
2226:                    {
2227:                        pallete[counter] = *((FLASH_WORD *)flashAddress);
2228:                        flashAddress += 2;
2229:                    }
2230:                
2231:                    yc = top;
2232:                    for(y = 0; y < sizeY; y++)
2233:                    {
2234:                        tempFlashAddress = flashAddress;
2235:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2236:                        {
2237:                            flashAddress = tempFlashAddress;
2238:                            xc = left;
2239:                            for(x = 0; x < sizeX; x++)
2240:                            {
2241:                
2242:                                // Read 2 pixels from flash
2243:                                if(x & 0x0001)
2244:                                {
2245:                
2246:                                    // second pixel in byte
2247:                                    SetColor(pallete[temp >> 4]);
2248:                                }
2249:                                else
2250:                                {
2251:                                    temp = *flashAddress;
2252:                                    flashAddress++;
2253:                
2254:                                    // first pixel in byte
2255:                                    SetColor(pallete[temp & 0x0f]);
2256:                                }
2257:                
2258:                                // Write pixel to screen
2259:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2260:                                {
2261:                                    PutPixel(xc++, yc);
2262:                                }
2263:                            }
2264:                
2265:                            yc++;
2266:                        }
2267:                    }
2268:                }
2269:                
2270:                        #endif
2271:                
2272:                /*********************************************************************
2273:                * Function: void PutImage8BPP(SHORT left, SHORT top, FLASH_BYTE* bitmap, BYTE stretch)
2274:                *
2275:                * PreCondition: none
2276:                *
2277:                * Input: left,top - left top image corner, bitmap - image pointer,
2278:                *        stretch - image stretch factor
2279:                *
2280:                * Output: none
2281:                *
2282:                * Side Effects: none
2283:                *
2284:                * Overview: outputs 256 color image starting from left,top coordinates
2285:                *
2286:                * Note: image must be located in flash
2287:                *
2288:                ********************************************************************/
2289:                        #if (COLOR_DEPTH >= 8)
2290:                
2291:                /* */
2292:                void PutImage8BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch)
2293:                {
2294:                    register FLASH_BYTE *flashAddress;
2295:                    register FLASH_BYTE *tempFlashAddress;
2296:                    WORD                sizeX, sizeY;
2297:                    WORD                x, y;
2298:                    WORD                xc, yc;
2299:                    BYTE                temp;
2300:                    BYTE                stretchX, stretchY;
2301:                    WORD                pallete[256];
2302:                    WORD                counter;
2303:                
2304:                    // Move pointer to size information
2305:                    flashAddress = bitmap + 2;
2306:                
2307:                    // Read image size
2308:                    sizeY = *((FLASH_WORD *)flashAddress);
2309:                    flashAddress += 2;
2310:                    sizeX = *((FLASH_WORD *)flashAddress);
2311:                    flashAddress += 2;
2312:                
2313:                    // Read pallete
2314:                    for(counter = 0; counter < 256; counter++)
2315:                    {
2316:                        pallete[counter] = *((FLASH_WORD *)flashAddress);
2317:                        flashAddress += 2;
2318:                    }
2319:                
2320:                    yc = top;
2321:                    for(y = 0; y < sizeY; y++)
2322:                    {
2323:                        tempFlashAddress = flashAddress;
2324:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2325:                        {
2326:                            flashAddress = tempFlashAddress;
2327:                            xc = left;
2328:                            for(x = 0; x < sizeX; x++)
2329:                            {
2330:                
2331:                                // Read pixels from flash
2332:                                temp = *flashAddress;
2333:                                flashAddress++;
2334:                
2335:                                // Set color
2336:                                SetColor(pallete[temp]);
2337:                
2338:                                // Write pixel to screen
2339:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2340:                                {
2341:                                    PutPixel(xc++, yc);
2342:                                }
2343:                            }
2344:                
2345:                            yc++;
2346:                        }
2347:                    }
2348:                }
2349:                
2350:                        #endif
2351:                
2352:                /*********************************************************************
2353:                * Function: void PutImage16BPP(SHORT left, SHORT top, FLASH_BYTE* bitmap, BYTE stretch)
2354:                *
2355:                * PreCondition: none
2356:                *
2357:                * Input: left,top - left top image corner, bitmap - image pointer,
2358:                *        stretch - image stretch factor
2359:                *
2360:                * Output: none
2361:                *
2362:                * Side Effects: none
2363:                *
2364:                * Overview: outputs hicolor image starting from left,top coordinates
2365:                *
2366:                * Note: image must be located in flash
2367:                *
2368:                ********************************************************************/
2369:                        #if (COLOR_DEPTH == 16)
2370:                
2371:                /* */
2372:                void PutImage16BPP(SHORT left, SHORT top, FLASH_BYTE *bitmap, BYTE stretch)
2373:                {
2374:                    register FLASH_WORD *flashAddress;
2375:                    register FLASH_WORD *tempFlashAddress;
2376:                    WORD                sizeX, sizeY;
2377:                    register WORD       x, y;
2378:                    WORD                xc, yc;
2379:                    WORD                temp;
2380:                    register BYTE       stretchX, stretchY;
2381:                
2382:                    // Move pointer to size information
2383:                    flashAddress = (FLASH_WORD *)bitmap + 1;
2384:                
2385:                    // Read image size
2386:                    sizeY = *flashAddress;
2387:                    flashAddress++;
2388:                    sizeX = *flashAddress;
2389:                    flashAddress++;
2390:                
2391:                    yc = top;
2392:                    for(y = 0; y < sizeY; y++)
2393:                    {
2394:                        tempFlashAddress = flashAddress;
2395:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2396:                        {
2397:                            flashAddress = tempFlashAddress;
2398:                            xc = left;
2399:                            for(x = 0; x < sizeX; x++)
2400:                            {
2401:                
2402:                                // Read pixels from flash
2403:                                temp = *flashAddress;
2404:                                flashAddress++;
2405:                
2406:                                // Set color
2407:                                SetColor(temp);
2408:                
2409:                                // Write pixel to screen
2410:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2411:                                {
2412:                                    PutPixel(xc++, yc);
2413:                                }
2414:                            }
2415:                
2416:                            yc++;
2417:                        }
2418:                    }
2419:                }
2420:                
2421:                        #endif
2422:                    #endif
2423:                    #ifdef USE_BITMAP_EXTERNAL
2424:                
2425:                /*********************************************************************
2426:                * Function: void PutImage1BPPExt(SHORT left, SHORT top, void* bitmap, BYTE stretch)
2427:                *
2428:                * PreCondition: none
2429:                *
2430:                * Input: left,top - left top image corner, bitmap - image pointer,
2431:                *        stretch - image stretch factor
2432:                *
2433:                * Output: none
2434:                *
2435:                * Side Effects: none
2436:                *
2437:                * Overview: outputs monochrome image starting from left,top coordinates
2438:                *
2439:                * Note: image must be located in external memory
2440:                *
2441:                ********************************************************************/
2442:                void PutImage1BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch)
2443:                {
2444:                    register DWORD  memOffset;
2445:                    BITMAP_HEADER   bmp;
2446:                    WORD            pallete[2];
2447:                    BYTE            lineBuffer[((GetMaxX() + 1) / 8) + 1];
2448:                    BYTE            *pData;
2449:                    SHORT           byteWidth;
2450:                
2451:                    BYTE            temp;
2452:                    BYTE            mask;
2453:                    WORD            sizeX, sizeY;
2454:                    WORD            x, y;
2455:                    WORD            xc, yc;
2456:                    BYTE            stretchX, stretchY;
2457:                
2458:                    // Get bitmap header
2459:                    ExternalMemoryCallback(bitmap, 0, sizeof(BITMAP_HEADER), &bmp);
2460:                
2461:                    // Get pallete (2 entries)
2462:                    ExternalMemoryCallback(bitmap, sizeof(BITMAP_HEADER), 2 * sizeof(WORD), pallete);
2463:                
2464:                    // Set offset to the image data
2465:                    memOffset = sizeof(BITMAP_HEADER) + 2 * sizeof(WORD);
2466:                
2467:                    // Line width in bytes
2468:                    byteWidth = bmp.width >> 3;
2469:                    if(bmp.width & 0x0007)
2470:                        byteWidth++;
2471:                
2472:                    // Get size
2473:                    sizeX = bmp.width;
2474:                    sizeY = bmp.height;
2475:                
2476:                    yc = top;
2477:                    for(y = 0; y < sizeY; y++)
2478:                    {
2479:                
2480:                        // Get line
2481:                        ExternalMemoryCallback(bitmap, memOffset, byteWidth, lineBuffer);
2482:                        memOffset += byteWidth;
2483:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2484:                        {
2485:                            pData = lineBuffer;
2486:                            mask = 0;
2487:                            xc = left;
2488:                            for(x = 0; x < sizeX; x++)
2489:                            {
2490:                
2491:                                // Read 8 pixels from flash
2492:                                if(mask == 0)
2493:                                {
2494:                                    temp = *pData++;
2495:                                    mask = 0x80;
2496:                                }
2497:                
2498:                                // Set color
2499:                                if(mask & temp)
2500:                                {
2501:                                    SetColor(pallete[1]);
2502:                                }
2503:                                else
2504:                                {
2505:                                    SetColor(pallete[0]);
2506:                                }
2507:                
2508:                                // Write pixel to screen
2509:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2510:                                {
2511:                                    PutPixel(xc++, yc);
2512:                                }
2513:                
2514:                                // Shift to the next pixel
2515:                                mask >>= 1;
2516:                            }
2517:                
2518:                            yc++;
2519:                        }
2520:                    }
2521:                }
2522:                
2523:                /*********************************************************************
2524:                * Function: void PutImage4BPPExt(SHORT left, SHORT top, void* bitmap, BYTE stretch)
2525:                *
2526:                * PreCondition: none
2527:                *
2528:                * Input: left,top - left top image corner, bitmap - image pointer,
2529:                *        stretch - image stretch factor
2530:                *
2531:                * Output: none
2532:                *
2533:                * Side Effects: none
2534:                *
2535:                * Overview: outputs monochrome image starting from left,top coordinates
2536:                *
2537:                * Note: image must be located in external memory
2538:                *
2539:                ********************************************************************/
2540:                        #if (COLOR_DEPTH >= 4)
2541:                
2542:                /* */
2543:                void PutImage4BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch)
2544:                {
2545:                    register DWORD  memOffset;
2546:                    BITMAP_HEADER   bmp;
2547:                    WORD            pallete[16];
2548:                    BYTE            lineBuffer[((GetMaxX() + 1) / 2) + 1];
2549:                    BYTE            *pData;
2550:                    SHORT           byteWidth;
2551:                
2552:                    BYTE            temp = 0;
2553:                    WORD            sizeX, sizeY;
2554:                    WORD            x, y;
2555:                    WORD            xc, yc;
2556:                    BYTE            stretchX, stretchY;
2557:                
2558:                    // Get bitmap header
2559:                    ExternalMemoryCallback(bitmap, 0, sizeof(BITMAP_HEADER), &bmp);
2560:                
2561:                    // Get pallete (16 entries)
2562:                    ExternalMemoryCallback(bitmap, sizeof(BITMAP_HEADER), 16 * sizeof(WORD), pallete);
2563:                
2564:                    // Set offset to the image data
2565:                    memOffset = sizeof(BITMAP_HEADER) + 16 * sizeof(WORD);
2566:                
2567:                    // Line width in bytes
2568:                    byteWidth = bmp.width >> 1;
2569:                    if(bmp.width & 0x0001)
2570:                        byteWidth++;
2571:                
2572:                    // Get size
2573:                    sizeX = bmp.width;
2574:                    sizeY = bmp.height;
2575:                
2576:                    yc = top;
2577:                    for(y = 0; y < sizeY; y++)
2578:                    {
2579:                
2580:                        // Get line
2581:                        ExternalMemoryCallback(bitmap, memOffset, byteWidth, lineBuffer);
2582:                        memOffset += byteWidth;
2583:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2584:                        {
2585:                            pData = lineBuffer;
2586:                            xc = left;
2587:                            for(x = 0; x < sizeX; x++)
2588:                            {
2589:                
2590:                                // Read 2 pixels from flash
2591:                                if(x & 0x0001)
2592:                                {
2593:                
2594:                                    // second pixel in byte
2595:                                    SetColor(pallete[temp >> 4]);
2596:                                }
2597:                                else
2598:                                {
2599:                                    temp = *pData++;
2600:                
2601:                                    // first pixel in byte
2602:                                    SetColor(pallete[temp & 0x0f]);
2603:                                }
2604:                
2605:                                // Write pixel to screen
2606:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2607:                                {
2608:                                    PutPixel(xc++, yc);
2609:                                }
2610:                            }
2611:                
2612:                            yc++;
2613:                        }
2614:                    }
2615:                }
2616:                
2617:                        #endif
2618:                
2619:                /*********************************************************************
2620:                * Function: void PutImage8BPPExt(SHORT left, SHORT top, void* bitmap, BYTE stretch)
2621:                *
2622:                * PreCondition: none
2623:                *
2624:                * Input: left,top - left top image corner, bitmap - image pointer,
2625:                *        stretch - image stretch factor
2626:                *
2627:                * Output: none
2628:                *
2629:                * Side Effects: none
2630:                *
2631:                * Overview: outputs monochrome image starting from left,top coordinates
2632:                *
2633:                * Note: image must be located in external memory
2634:                *
2635:                ********************************************************************/
2636:                        #if (COLOR_DEPTH >= 8)
2637:                
2638:                /* */
2639:                void PutImage8BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch)
2640:                {
2641:                    register DWORD  memOffset;
2642:                    BITMAP_HEADER   bmp;
2643:                    WORD            pallete[256];
2644:                    BYTE            lineBuffer[(GetMaxX() + 1)];
2645:                    BYTE            *pData;
2646:                
2647:                    BYTE            temp;
2648:                    WORD            sizeX, sizeY;
2649:                    WORD            x, y;
2650:                    WORD            xc, yc;
2651:                    BYTE            stretchX, stretchY;
2652:                
2653:                    // Get bitmap header
2654:                    ExternalMemoryCallback(bitmap, 0, sizeof(BITMAP_HEADER), &bmp);
2655:                
2656:                    // Get pallete (256 entries)
2657:                    ExternalMemoryCallback(bitmap, sizeof(BITMAP_HEADER), 256 * sizeof(WORD), pallete);
2658:                
2659:                    // Set offset to the image data
2660:                    memOffset = sizeof(BITMAP_HEADER) + 256 * sizeof(WORD);
2661:                
2662:                    // Get size
2663:                    sizeX = bmp.width;
2664:                    sizeY = bmp.height;
2665:                
2666:                    yc = top;
2667:                    for(y = 0; y < sizeY; y++)
2668:                    {
2669:                
2670:                        // Get line
2671:                        ExternalMemoryCallback(bitmap, memOffset, sizeX, lineBuffer);
2672:                        memOffset += sizeX;
2673:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2674:                        {
2675:                            pData = lineBuffer;
2676:                            xc = left;
2677:                            for(x = 0; x < sizeX; x++)
2678:                            {
2679:                                temp = *pData++;
2680:                                SetColor(pallete[temp]);
2681:                
2682:                                // Write pixel to screen
2683:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2684:                                {
2685:                                    PutPixel(xc++, yc);
2686:                                }
2687:                            }
2688:                
2689:                            yc++;
2690:                        }
2691:                    }
2692:                }
2693:                
2694:                        #endif
2695:                
2696:                /*********************************************************************
2697:                * Function: void PutImage16BPPExt(SHORT left, SHORT top, void* bitmap, BYTE stretch)
2698:                *
2699:                * PreCondition: none
2700:                *
2701:                * Input: left,top - left top image corner, bitmap - image pointer,
2702:                *        stretch - image stretch factor
2703:                *
2704:                * Output: none
2705:                *
2706:                * Side Effects: none
2707:                *
2708:                * Overview: outputs monochrome image starting from left,top coordinates
2709:                *
2710:                * Note: image must be located in external memory
2711:                *
2712:                ********************************************************************/
2713:                        #if (COLOR_DEPTH == 16)
2714:                
2715:                /* */
2716:                void PutImage16BPPExt(SHORT left, SHORT top, void *bitmap, BYTE stretch)
2717:                {
2718:                    register DWORD  memOffset;
2719:                    BITMAP_HEADER   bmp;
2720:                    WORD            lineBuffer[(GetMaxX() + 1)];
2721:                    WORD            *pData;
2722:                    WORD            byteWidth;
2723:                
2724:                    WORD            temp;
2725:                    WORD            sizeX, sizeY;
2726:                    WORD            x, y;
2727:                    WORD            xc, yc;
2728:                    BYTE            stretchX, stretchY;
2729:                
2730:                    // Get bitmap header
2731:                    ExternalMemoryCallback(bitmap, 0, sizeof(BITMAP_HEADER), &bmp);
2732:                
2733:                    // Set offset to the image data
2734:                    memOffset = sizeof(BITMAP_HEADER);
2735:                
2736:                    // Get size
2737:                    sizeX = bmp.width;
2738:                    sizeY = bmp.height;
2739:                
2740:                    byteWidth = sizeX << 1;
2741:                
2742:                    yc = top;
2743:                    for(y = 0; y < sizeY; y++)
2744:                    {
2745:                
2746:                        // Get line
2747:                        ExternalMemoryCallback(bitmap, memOffset, byteWidth, lineBuffer);
2748:                        memOffset += byteWidth;
2749:                        for(stretchY = 0; stretchY < stretch; stretchY++)
2750:                        {
2751:                            pData = lineBuffer;
2752:                
2753:                            xc = left;
2754:                            for(x = 0; x < sizeX; x++)
2755:                            {
2756:                                temp = *pData++;
2757:                                SetColor(temp);
2758:                
2759:                                // Write pixel to screen
2760:                                for(stretchX = 0; stretchX < stretch; stretchX++)
2761:                                {
2762:                                    PutPixel(xc++, yc);
2763:                                }
2764:                            }
2765:                
2766:                            yc++;
2767:                        }
2768:                    }
2769:                }
2770:                
2771:                        #endif
2772:                    #endif
2773:                #endif // USE_DRV_PUTIMAGE
---  C:/MC_XProjects/MMB/SerialEEPROM.c  ----------------------------------------------------------------
1:                   /*****************************************************************************
2:                    *
3:                    * Basic access to I2C EEPROM 24LC01 located on MikroE PIC32MX4 MMB
4:                    *
5:                    * API is compatible with MCHP PICTail GFX2/3 serial EEPROM support
6:                    *****************************************************************************
7:                    * FileName:        SerialEEPROM.h
8:                    * Dependencies:    Graphics.h
9:                    * Processor:       PIC32
10:                   * Compiler:       	MPLAB C32
11:                   * Linker:          MPLAB LINK32
12:                   * Company:         Microchip Technology Incorporated
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * Copyright © 2008 Microchip Technology Inc.  All rights reserved.
17:                   * Microchip licenses to you the right to use, modify, copy and distribute
18:                   * Software only when embedded on a Microchip microcontroller or digital
19:                   * signal controller, which is integrated into your product or third party
20:                   * product (pursuant to the sublicense terms in the accompanying license
21:                   * agreement).  
22:                   *
23:                   * You should refer to the license agreement accompanying this Software
24:                   * for additional information regarding your rights and obligations.
25:                   *
26:                   * SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY
27:                   * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
28:                   * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
29:                   * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
30:                   * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
31:                   * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
32:                   * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
33:                   * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
34:                   * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
35:                   * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
36:                   * OR OTHER SIMILAR COSTS.
37:                   *
38:                   * Author               Date        Comment
39:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
40:                   * Lucio Di Jasio       12/08/09	
41:                   *****************************************************************************/
42:                  
43:                  #include <plib.h>
44:                  #include "SerialEEPROM.h"
45:                  
46:                  
47:                  #define PAGESIZE    8               // page size for 24LC01 
48:                  #define PAGEMASK    (PAGESIZE-1)
49:                  #define BUSFRQ      100000ul          // 100kHz
50:                  /************************************************************************
51:                  * Function: EEPROMInit()
52:                  *                                                                       
53:                  * Overview: this function setups the I2C2 interface 
54:                  *                                                                       
55:                  * Input: none
56:                  *                                                                       
57:                  * Output: none  
58:                  *                                                                       
59:                  ************************************************************************/
60:                  void EEPROMInit()
61:                  {  // Configure I2C for 7 bit address mode 
9D00F304  27BDFFE0   ADDIU SP, SP, -32
9D00F308  AFBF001C   SW RA, 28(SP)
9D00F30C  AFBE0018   SW S8, 24(SP)
9D00F310  03A0F021   ADDU S8, SP, ZERO
62:                      int delay;
63:                      
64:                      CloseI2C2();
9D00F314  3C02BF80   LUI V0, -16512
9D00F318  34038000   ORI V1, ZERO, -32768
9D00F31C  AC435404   SW V1, 21508(V0)
9D00F320  3C02BF88   LUI V0, -16504
9D00F324  24031000   ADDIU V1, ZERO, 4096
9D00F328  AC431074   SW V1, 4212(V0)
9D00F32C  3C02BF88   LUI V0, -16504
9D00F330  AC401078   SW ZERO, 4216(V0)
9D00F334  3C02BF88   LUI V0, -16504
9D00F338  24032000   ADDIU V1, ZERO, 8192
9D00F33C  AC431074   SW V1, 4212(V0)
9D00F340  3C02BF88   LUI V0, -16504
9D00F344  AC401078   SW ZERO, 4216(V0)
9D00F348  3C02BF88   LUI V0, -16504
9D00F34C  24030800   ADDIU V1, ZERO, 2048
9D00F350  AC431074   SW V1, 4212(V0)
9D00F354  3C02BF88   LUI V0, -16504
9D00F358  AC401078   SW ZERO, 4216(V0)
65:                      OpenI2C2( I2C_ON | I2C_IDLE_CON | I2C_7BIT_ADD | I2C_STR_EN, 
9D00F35C  3C02BF80   LUI V0, -16512
9D00F360  34038040   ORI V1, ZERO, -32704
9D00F364  AC435400   SW V1, 21504(V0)
9D00F368  3C02BF81   LUI V0, -16511
9D00F36C  8C42F000   LW V0, -4096(V0)
9D00F370  7C420CC0   EXT V0, V0, 19, 2
9D00F374  304200FF   ANDI V0, V0, 255
9D00F378  3C0304C4   LUI V1, 1220
9D00F37C  3463B400   ORI V1, V1, -19456
9D00F380  00431006   SRLV V0, V1, V0
9D00F384  00021982   SRL V1, V0, 6
9D00F388  3C02053E   LUI V0, 1342
9D00F38C  34422D63   ORI V0, V0, 11619
9D00F390  00620019   MULTU V1, V0
9D00F394  00001012   MFLO V0
9D00F398  00001810   MFHI V1
9D00F39C  00031182   SRL V0, V1, 6
9D00F3A0  2443FFFF   ADDIU V1, V0, -1
9D00F3A4  3C02BF80   LUI V0, -16512
9D00F3A8  AC435440   SW V1, 21568(V0)
66:                              (GetPeripheralClock()/(2*BUSFRQ))-1);
67:                  
68:                      IdleI2C2();
9D00F3AC  0F4061C4   JAL IdleI2C2
9D00F3B0  00000000   NOP
69:                      
70:                      // approx 1ms delay
71:                      for( delay = 0; delay < (GetPeripheralClock()/5/80000ul); delay++);
9D00F3B4  AFC00010   SW ZERO, 16(S8)
9D00F3B8  0B403CF3   J 0x9D00F3CC
9D00F3BC  00000000   NOP
9D00F3C0  8FC20010   LW V0, 16(S8)
9D00F3C4  24420001   ADDIU V0, V0, 1
9D00F3C8  AFC20010   SW V0, 16(S8)
9D00F3CC  8FC30010   LW V1, 16(S8)
9D00F3D0  3C02BF81   LUI V0, -16511
9D00F3D4  8C42F000   LW V0, -4096(V0)
9D00F3D8  7C420CC0   EXT V0, V0, 19, 2
9D00F3DC  304200FF   ANDI V0, V0, 255
9D00F3E0  3C0404C4   LUI A0, 1220
9D00F3E4  3484B400   ORI A0, A0, -19456
9D00F3E8  00441006   SRLV V0, A0, V0
9D00F3EC  000221C2   SRL A0, V0, 7
9D00F3F0  3C02014F   LUI V0, 335
9D00F3F4  34428B59   ORI V0, V0, -29863
9D00F3F8  00820019   MULTU A0, V0
9D00F3FC  00002012   MFLO A0
9D00F400  00002810   MFHI A1
9D00F404  00051102   SRL V0, A1, 4
9D00F408  0062102B   SLTU V0, V1, V0
9D00F40C  1440FFEC   BNE V0, ZERO, 0x9D00F3C0
9D00F410  00000000   NOP
72:                          
73:                  } // EEPROMInit
9D00F414  03C0E821   ADDU SP, S8, ZERO
9D00F418  8FBF001C   LW RA, 28(SP)
9D00F41C  8FBE0018   LW S8, 24(SP)
9D00F420  27BD0020   ADDIU SP, SP, 32
9D00F424  03E00008   JR RA
9D00F428  00000000   NOP
74:                   
75:                   
76:                  int addressSEE( long add)
77:                  // send the address selection command
78:                  // repeat if SEE busy 
79:                  {
9D00F42C  27BDFFE0   ADDIU SP, SP, -32
9D00F430  AFBF001C   SW RA, 28(SP)
9D00F434  AFBE0018   SW S8, 24(SP)
9D00F438  03A0F021   ADDU S8, SP, ZERO
9D00F43C  AFC40020   SW A0, 32(S8)
80:                      long cmd;
81:                    
82:                      // 1. form block address and SEE read command
83:                      cmd = (add>>16) & 1;        // extract A16
9D00F440  8FC20020   LW V0, 32(S8)
9D00F444  00021403   SRA V0, V0, 16
9D00F448  30420001   ANDI V0, V0, 1
9D00F44C  AFC20010   SW V0, 16(S8)
84:                      cmd <<= 2;                  // move it to b0 position
9D00F450  8FC20010   LW V0, 16(S8)
9D00F454  00021080   SLL V0, V0, 2
9D00F458  AFC20010   SW V0, 16(S8)
85:                      cmd |= 0x50;                // select SEE device
9D00F45C  8FC20010   LW V0, 16(S8)
9D00F460  34420050   ORI V0, V0, 80
9D00F464  AFC20010   SW V0, 16(S8)
86:                      cmd <<= 1;                  // make room for READ bit
9D00F468  8FC20010   LW V0, 16(S8)
9D00F46C  00021040   SLL V0, V0, 1
9D00F470  AFC20010   SW V0, 16(S8)
87:                          
88:                      // 2. WRITE(!) the Address msb
89:                      // try send command and repeat until ACK is received
90:                      while( 1)
91:                      { 
92:                          StartI2C2(); 
9D00F474  3C02BF80   LUI V0, -16512
9D00F478  24030001   ADDIU V1, ZERO, 1
9D00F47C  AC435408   SW V1, 21512(V0)
93:                          IdleI2C2();
9D00F480  0F4061C4   JAL IdleI2C2
9D00F484  00000000   NOP
94:                          
95:                          // send command and address msb(3)
96:                          MasterWriteI2C2( cmd+WRITE_CMD); 
9D00F488  8FC20010   LW V0, 16(S8)
9D00F48C  304200FF   ANDI V0, V0, 255
9D00F490  00402021   ADDU A0, V0, ZERO
9D00F494  0F406265   JAL MasterWriteI2C2
9D00F498  00000000   NOP
97:                          IdleI2C2();
9D00F49C  0F4061C4   JAL IdleI2C2
9D00F4A0  00000000   NOP
98:                          
99:                          if (I2C2STATbits.ACKSTAT==0)
9D00F4A4  3C02BF80   LUI V0, -16512
9D00F4A8  8C425410   LW V0, 21520(V0)
9D00F4AC  30428000   ANDI V0, V0, -32768
9D00F4B0  1440000F   BNE V0, ZERO, 0x9D00F4F0
9D00F4B4  00000000   NOP
100:                             break;
101:                             
102:                         StopI2C2();
9D00F4F0  3C02BF80   LUI V0, -16512
9D00F4F4  24030004   ADDIU V1, ZERO, 4
9D00F4F8  AC435408   SW V1, 21512(V0)
103:                         IdleI2C2();
9D00F4FC  0F4061C4   JAL IdleI2C2
9D00F500  00000000   NOP
104:                     } // while waiting for ACK
9D00F504  0B403D1D   J 0x9D00F474
9D00F508  00000000   NOP
105:                 
106:                 #ifdef USE_LONG_ADDRESS
107:                     // 3. send address MSB, bit 8-15
108:                     MasterWriteI2C2( add>>8); 
109:                     IdleI2C2();
110:                 #endif
111:                 
112:                     // 3. send address LSB, bit 0-7
113:                     MasterWriteI2C2( add); 
9D00F4B8  8FC20020   LW V0, 32(S8)
9D00F4BC  304200FF   ANDI V0, V0, 255
9D00F4C0  00402021   ADDU A0, V0, ZERO
9D00F4C4  0F406265   JAL MasterWriteI2C2
9D00F4C8  00000000   NOP
114:                     IdleI2C2();
9D00F4CC  0F4061C4   JAL IdleI2C2
9D00F4D0  00000000   NOP
115:                 
116:                     // 4. exit returning the cmd byte
117:                     return cmd;
9D00F4D4  8FC20010   LW V0, 16(S8)
118:                 } // addressSEE
9D00F4D8  03C0E821   ADDU SP, S8, ZERO
9D00F4DC  8FBF001C   LW RA, 28(SP)
9D00F4E0  8FBE0018   LW S8, 24(SP)
9D00F4E4  27BD0020   ADDIU SP, SP, 32
9D00F4E8  03E00008   JR RA
9D00F4EC  00000000   NOP
119:                     
120:                 /************************************************************************
121:                 * Function: void EEPROMWriteByte()                                           
122:                 *                                                                       
123:                 * Overview: this function writes a byte to the address specified
124:                 *                                                                       
125:                 * Input: byte to be written and address
126:                 *                                                                       
127:                 * Output: none
128:                 *                                                                       
129:                 ************************************************************************/
130:                 void EEPROMWriteByte(BYTE data, WORD address)
131:                 {
9D00F50C  27BDFFE0   ADDIU SP, SP, -32
9D00F510  AFBF001C   SW RA, 28(SP)
9D00F514  AFBE0018   SW S8, 24(SP)
9D00F518  03A0F021   ADDU S8, SP, ZERO
9D00F51C  00801821   ADDU V1, A0, ZERO
9D00F520  00A01021   ADDU V0, A1, ZERO
9D00F524  A3C30020   SB V1, 32(S8)
9D00F528  A7C20024   SH V0, 36(S8)
132:                     int cmd; 
133:                     
134:                     // 1. select address
135:                     cmd = addressSEE( address);
9D00F52C  97C20024   LHU V0, 36(S8)
9D00F530  00402021   ADDU A0, V0, ZERO
9D00F534  0F403D0B   JAL addressSEE
9D00F538  00000000   NOP
9D00F53C  AFC20010   SW V0, 16(S8)
136:                          
137:                     // 2. stream data out 
138:                     MasterWriteI2C2( data & 0xFF);  
9D00F540  93C20020   LBU V0, 32(S8)
9D00F544  00402021   ADDU A0, V0, ZERO
9D00F548  0F406265   JAL MasterWriteI2C2
9D00F54C  00000000   NOP
139:                     IdleI2C2();  
9D00F550  0F4061C4   JAL IdleI2C2
9D00F554  00000000   NOP
140:                 
141:                 
142:                     // 3. terminate the command sequence
143:                     StopI2C2(); 
9D00F558  3C02BF80   LUI V0, -16512
9D00F55C  24030004   ADDIU V1, ZERO, 4
9D00F560  AC435408   SW V1, 21512(V0)
144:                     IdleI2C2();
9D00F564  0F4061C4   JAL IdleI2C2
9D00F568  00000000   NOP
145:                     
146:                 } // EEPROMWriteByte   
9D00F56C  03C0E821   ADDU SP, S8, ZERO
9D00F570  8FBF001C   LW RA, 28(SP)
9D00F574  8FBE0018   LW S8, 24(SP)
9D00F578  27BD0020   ADDIU SP, SP, 32
9D00F57C  03E00008   JR RA
9D00F580  00000000   NOP
147:                   
148:                   
149:                     
150:                 /************************************************************************
151:                 * Function: BYTE EEPROMReadByte(WORD address)       
152:                 *                                                                       
153:                 * Overview: this function reads a byte from the address specified
154:                 *                                                                       
155:                 * Input: address          
156:                 *                                                                       
157:                 * Output: data read
158:                 *                                                                       
159:                 ************************************************************************/
160:                 BYTE EEPROMReadByte(WORD address)
161:                 {
9D00F584  27BDFFE0   ADDIU SP, SP, -32
9D00F588  AFBF001C   SW RA, 28(SP)
9D00F58C  AFBE0018   SW S8, 24(SP)
9D00F590  03A0F021   ADDU S8, SP, ZERO
9D00F594  00801021   ADDU V0, A0, ZERO
9D00F598  A7C20020   SH V0, 32(S8)
162:                     int cmd, r; 
163:                    
164:                     // 1. select address
165:                     cmd = addressSEE( address);
9D00F59C  97C20020   LHU V0, 32(S8)
9D00F5A0  00402021   ADDU A0, V0, ZERO
9D00F5A4  0F403D0B   JAL addressSEE
9D00F5A8  00000000   NOP
9D00F5AC  AFC20010   SW V0, 16(S8)
166:                     
167:                     StopI2C2();
9D00F5B0  3C02BF80   LUI V0, -16512
9D00F5B4  24030004   ADDIU V1, ZERO, 4
9D00F5B8  AC435408   SW V1, 21512(V0)
168:                     IdleI2C2();
9D00F5BC  0F4061C4   JAL IdleI2C2
9D00F5C0  00000000   NOP
169:                       
170:                     // 2. read command
171:                     StartI2C2(); IdleI2C2();
9D00F5C4  3C02BF80   LUI V0, -16512
9D00F5C8  24030001   ADDIU V1, ZERO, 1
9D00F5CC  AC435408   SW V1, 21512(V0)
9D00F5D0  0F4061C4   JAL IdleI2C2
9D00F5D4  00000000   NOP
172:                     MasterWriteI2C2( cmd+READ_CMD);
9D00F5D8  8FC20010   LW V0, 16(S8)
9D00F5DC  304200FF   ANDI V0, V0, 255
9D00F5E0  24420001   ADDIU V0, V0, 1
9D00F5E4  304200FF   ANDI V0, V0, 255
9D00F5E8  00402021   ADDU A0, V0, ZERO
9D00F5EC  0F406265   JAL MasterWriteI2C2
9D00F5F0  00000000   NOP
173:                     IdleI2C2();
9D00F5F4  0F4061C4   JAL IdleI2C2
9D00F5F8  00000000   NOP
174:                 
175:                     // 3. stream data in (will continue until NACK is sent)
176:                     r = MasterReadI2C2( );
9D00F5FC  0F4063CD   JAL MasterReadI2C2
9D00F600  00000000   NOP
9D00F604  AFC20014   SW V0, 20(S8)
177:                     
178:                     // 4. terminate read sequence (send NACK then STOP)
179:                     NotAckI2C2(); IdleI2C2();
9D00F608  3C02BF80   LUI V0, -16512
9D00F60C  24030020   ADDIU V1, ZERO, 32
9D00F610  AC435408   SW V1, 21512(V0)
9D00F614  3C02BF80   LUI V0, -16512
9D00F618  24030010   ADDIU V1, ZERO, 16
9D00F61C  AC435408   SW V1, 21512(V0)
9D00F620  0F4061C4   JAL IdleI2C2
9D00F624  00000000   NOP
180:                     StopI2C2(); IdleI2C2();
9D00F628  3C02BF80   LUI V0, -16512
9D00F62C  24030004   ADDIU V1, ZERO, 4
9D00F630  AC435408   SW V1, 21512(V0)
9D00F634  0F4061C4   JAL IdleI2C2
9D00F638  00000000   NOP
181:                     
182:                     return r;
9D00F63C  8FC20014   LW V0, 20(S8)
9D00F640  304200FF   ANDI V0, V0, 255
183:                 } // EEPROMReadByte 
9D00F644  03C0E821   ADDU SP, S8, ZERO
9D00F648  8FBF001C   LW RA, 28(SP)
9D00F64C  8FBE0018   LW S8, 24(SP)
9D00F650  27BD0020   ADDIU SP, SP, 32
9D00F654  03E00008   JR RA
9D00F658  00000000   NOP
184:                 
185:                 
186:                 /************************************************************************
187:                 * Function: void EEPROMWriteWord(WODR data, WORD address)                                           
188:                 *                                                                       
189:                 * Overview: this function writes a 16-bit word to the address specified
190:                 *                                                                       
191:                 * Input: data to be written and address
192:                 *                                                                       
193:                 * Output: none                                                         
194:                 *                                                                       
195:                 ************************************************************************/
196:                 void EEPROMWriteWord(WORD data, WORD address)
197:                 {
9D00F65C  27BDFFE0   ADDIU SP, SP, -32
9D00F660  AFBF001C   SW RA, 28(SP)
9D00F664  AFBE0018   SW S8, 24(SP)
9D00F668  03A0F021   ADDU S8, SP, ZERO
9D00F66C  00801821   ADDU V1, A0, ZERO
9D00F670  00A01021   ADDU V0, A1, ZERO
9D00F674  A7C30020   SH V1, 32(S8)
9D00F678  A7C20024   SH V0, 36(S8)
198:                     int cmd; 
199:                     
200:                     // 1. select address
201:                     cmd = addressSEE( address);
9D00F67C  97C20024   LHU V0, 36(S8)
9D00F680  00402021   ADDU A0, V0, ZERO
9D00F684  0F403D0B   JAL addressSEE
9D00F688  00000000   NOP
9D00F68C  AFC20010   SW V0, 16(S8)
202:                          
203:                     // 2. stream data out 
204:                     MasterWriteI2C2( data & 0xFF);    //LSB
9D00F690  97C20020   LHU V0, 32(S8)
9D00F694  304200FF   ANDI V0, V0, 255
9D00F698  00402021   ADDU A0, V0, ZERO
9D00F69C  0F406265   JAL MasterWriteI2C2
9D00F6A0  00000000   NOP
205:                     IdleI2C2();  
9D00F6A4  0F4061C4   JAL IdleI2C2
9D00F6A8  00000000   NOP
206:                 
207:                     MasterWriteI2C2( data >> 8);      // MSB
9D00F6AC  97C20020   LHU V0, 32(S8)
9D00F6B0  00021202   SRL V0, V0, 8
9D00F6B4  3042FFFF   ANDI V0, V0, -1
9D00F6B8  304200FF   ANDI V0, V0, 255
9D00F6BC  00402021   ADDU A0, V0, ZERO
9D00F6C0  0F406265   JAL MasterWriteI2C2
9D00F6C4  00000000   NOP
208:                     IdleI2C2();  
9D00F6C8  0F4061C4   JAL IdleI2C2
9D00F6CC  00000000   NOP
209:                 
210:                     // 3. terminate the command sequence
211:                     StopI2C2(); 
9D00F6D0  3C02BF80   LUI V0, -16512
9D00F6D4  24030004   ADDIU V1, ZERO, 4
9D00F6D8  AC435408   SW V1, 21512(V0)
212:                     IdleI2C2();
9D00F6DC  0F4061C4   JAL IdleI2C2
9D00F6E0  00000000   NOP
213:                     
214:                 } // EEPROMWriteWord
9D00F6E4  03C0E821   ADDU SP, S8, ZERO
9D00F6E8  8FBF001C   LW RA, 28(SP)
9D00F6EC  8FBE0018   LW S8, 24(SP)
9D00F6F0  27BD0020   ADDIU SP, SP, 32
9D00F6F4  03E00008   JR RA
9D00F6F8  00000000   NOP
215:                  
216:                   
217:                 /************************************************************************
218:                 * Function: WORD EEPROMReadWord(WORD address)             
219:                 *                                                                       
220:                 * Overview: this function reads a 16-bit word from the address specified         
221:                 *                                                                       
222:                 * Input: address                                                     
223:                 *                                                                       
224:                 * Output: data read
225:                 *                                                                       
226:                 ************************************************************************/
227:                 WORD EEPROMReadWord(WORD address)
228:                 {
9D00F6FC  27BDFFE0   ADDIU SP, SP, -32
9D00F700  AFBF001C   SW RA, 28(SP)
9D00F704  AFBE0018   SW S8, 24(SP)
9D00F708  03A0F021   ADDU S8, SP, ZERO
9D00F70C  00801021   ADDU V0, A0, ZERO
9D00F710  A7C20020   SH V0, 32(S8)
229:                     int cmd, r; 
230:                    
231:                     // 1. select address
232:                     cmd = addressSEE( address);
9D00F714  97C20020   LHU V0, 32(S8)
9D00F718  00402021   ADDU A0, V0, ZERO
9D00F71C  0F403D0B   JAL addressSEE
9D00F720  00000000   NOP
9D00F724  AFC20010   SW V0, 16(S8)
233:                     
234:                     StopI2C2();
9D00F728  3C02BF80   LUI V0, -16512
9D00F72C  24030004   ADDIU V1, ZERO, 4
9D00F730  AC435408   SW V1, 21512(V0)
235:                     IdleI2C2();
9D00F734  0F4061C4   JAL IdleI2C2
9D00F738  00000000   NOP
236:                       
237:                     // 2. read command
238:                     StartI2C2(); IdleI2C2();
9D00F73C  3C02BF80   LUI V0, -16512
9D00F740  24030001   ADDIU V1, ZERO, 1
9D00F744  AC435408   SW V1, 21512(V0)
9D00F748  0F4061C4   JAL IdleI2C2
9D00F74C  00000000   NOP
239:                     MasterWriteI2C2( cmd+READ_CMD);
9D00F750  8FC20010   LW V0, 16(S8)
9D00F754  304200FF   ANDI V0, V0, 255
9D00F758  24420001   ADDIU V0, V0, 1
9D00F75C  304200FF   ANDI V0, V0, 255
9D00F760  00402021   ADDU A0, V0, ZERO
9D00F764  0F406265   JAL MasterWriteI2C2
9D00F768  00000000   NOP
240:                     IdleI2C2();
9D00F76C  0F4061C4   JAL IdleI2C2
9D00F770  00000000   NOP
241:                 
242:                     // 3. stream data in (will continue until NACK is sent)
243:                     r= MasterReadI2C2( );
9D00F774  0F4063CD   JAL MasterReadI2C2
9D00F778  00000000   NOP
9D00F77C  AFC20014   SW V0, 20(S8)
244:                     
245:                     AckI2C2(); IdleI2C2();      
9D00F780  3C02BF80   LUI V0, -16512
9D00F784  24030020   ADDIU V1, ZERO, 32
9D00F788  AC435404   SW V1, 21508(V0)
9D00F78C  3C02BF80   LUI V0, -16512
9D00F790  24030010   ADDIU V1, ZERO, 16
9D00F794  AC435408   SW V1, 21512(V0)
9D00F798  0F4061C4   JAL IdleI2C2
9D00F79C  00000000   NOP
246:                     r |= (MasterReadI2C2()<<8);
9D00F7A0  0F4063CD   JAL MasterReadI2C2
9D00F7A4  00000000   NOP
9D00F7A8  00021200   SLL V0, V0, 8
9D00F7AC  8FC30014   LW V1, 20(S8)
9D00F7B0  00621025   OR V0, V1, V0
9D00F7B4  AFC20014   SW V0, 20(S8)
247:                 
248:                     // 4. terminate read sequence (send NACK then STOP)
249:                     NotAckI2C2(); IdleI2C2();
9D00F7B8  3C02BF80   LUI V0, -16512
9D00F7BC  24030020   ADDIU V1, ZERO, 32
9D00F7C0  AC435408   SW V1, 21512(V0)
9D00F7C4  3C02BF80   LUI V0, -16512
9D00F7C8  24030010   ADDIU V1, ZERO, 16
9D00F7CC  AC435408   SW V1, 21512(V0)
9D00F7D0  0F4061C4   JAL IdleI2C2
9D00F7D4  00000000   NOP
250:                     StopI2C2(); IdleI2C2();
9D00F7D8  3C02BF80   LUI V0, -16512
9D00F7DC  24030004   ADDIU V1, ZERO, 4
9D00F7E0  AC435408   SW V1, 21512(V0)
9D00F7E4  0F4061C4   JAL IdleI2C2
9D00F7E8  00000000   NOP
251:                     
252:                     return r;
9D00F7EC  8FC20014   LW V0, 20(S8)
9D00F7F0  3042FFFF   ANDI V0, V0, -1
253:                 } // EEPROMReadWord 
9D00F7F4  03C0E821   ADDU SP, S8, ZERO
9D00F7F8  8FBF001C   LW RA, 28(SP)
9D00F7FC  8FBE0018   LW S8, 24(SP)
9D00F800  27BD0020   ADDIU SP, SP, 32
9D00F804  03E00008   JR RA
9D00F808  00000000   NOP
254:                  
255:                  
256:                 /************************************************************************
257:                 * Function: EEPROMWriteEnable()                                       
258:                 *
259:                 * Overview: this function allows writing into EEPROM. Must be called
260:                 *           before every write/erase command
261:                 *
262:                 * Input: none
263:                 *            
264:                 * Output: none
265:                 *
266:                 ************************************************************************/
267:                 void EEPROMWriteEnable() 
268:                 { // empty, there is no WriteEnable/Disable sequence on 24LC01 memories
9D00F80C  27BDFFF8   ADDIU SP, SP, -8
9D00F810  AFBE0004   SW S8, 4(SP)
9D00F814  03A0F021   ADDU S8, SP, ZERO
269:                 }    
9D00F818  03C0E821   ADDU SP, S8, ZERO
9D00F81C  8FBE0004   LW S8, 4(SP)
9D00F820  27BD0008   ADDIU SP, SP, 8
9D00F824  03E00008   JR RA
9D00F828  00000000   NOP
270:                 
271:                 
272:                 /************************************************************************
273:                 * Function: BYTE EEPROMWriteArray(DWORD address, BYTE* pData, nCount)
274:                 *                                                                       
275:                 * Overview: this function writes data array at the address specified
276:                 *                                                                       
277:                 * Input: flash memory address, pointer to the data array, data number
278:                 *                                                                       
279:                 * Output: return 1 if the operation was successfull
280:                 *                                                                     
281:                 ************************************************************************/
282:                 BYTE EEPROMWriteArray(DWORD address, BYTE* pData, WORD nCount)
283:                 {
9D00F82C  27BDFFE0   ADDIU SP, SP, -32
9D00F830  AFBF001C   SW RA, 28(SP)
9D00F834  AFBE0018   SW S8, 24(SP)
9D00F838  03A0F021   ADDU S8, SP, ZERO
9D00F83C  AFC40020   SW A0, 32(S8)
9D00F840  AFC50024   SW A1, 36(S8)
9D00F844  00C01021   ADDU V0, A2, ZERO
9D00F848  A7C20028   SH V0, 40(S8)
284:                     int cmd, i; 
285:                     
286:                     //  0. repeat in pages
287:                     while ( nCount > 0)
9D00F84C  0B403E36   J 0x9D00F8D8
9D00F850  00000000   NOP
9D00F8D8  97C20028   LHU V0, 40(S8)
9D00F8DC  1440FFDD   BNE V0, ZERO, 0x9D00F854
9D00F8E0  00000000   NOP
288:                     {
289:                         // 1. select address
290:                         cmd = addressSEE( address);
9D00F854  8FC20020   LW V0, 32(S8)
9D00F858  00402021   ADDU A0, V0, ZERO
9D00F85C  0F403D0B   JAL addressSEE
9D00F860  00000000   NOP
9D00F864  AFC20010   SW V0, 16(S8)
291:                               
292:                         // 2. (partial) page write 
293:                         do {
294:                             MasterWriteI2C2( *pData++ );       
9D00F868  8FC20024   LW V0, 36(S8)
9D00F86C  90420000   LBU V0, 0(V0)
9D00F870  8FC30024   LW V1, 36(S8)
9D00F874  24630001   ADDIU V1, V1, 1
9D00F878  AFC30024   SW V1, 36(S8)
9D00F87C  00402021   ADDU A0, V0, ZERO
9D00F880  0F406265   JAL MasterWriteI2C2
9D00F884  00000000   NOP
295:                             IdleI2C2();  
9D00F888  0F4061C4   JAL IdleI2C2
9D00F88C  00000000   NOP
296:                             nCount--;
9D00F890  97C20028   LHU V0, 40(S8)
9D00F894  2442FFFF   ADDIU V0, V0, -1
9D00F898  A7C20028   SH V0, 40(S8)
297:                             address++;
9D00F89C  8FC20020   LW V0, 32(S8)
9D00F8A0  24420001   ADDIU V0, V0, 1
9D00F8A4  AFC20020   SW V0, 32(S8)
298:                         } while ((( address & PAGEMASK) !=0) && (nCount > 0));
9D00F8A8  8FC20020   LW V0, 32(S8)
9D00F8AC  30420007   ANDI V0, V0, 7
9D00F8B0  10400004   BEQ V0, ZERO, 0x9D00F8C4
9D00F8B4  00000000   NOP
9D00F8B8  97C20028   LHU V0, 40(S8)
9D00F8BC  1440FFEA   BNE V0, ZERO, 0x9D00F868
9D00F8C0  00000000   NOP
299:                         
300:                         // 3. terminate the command sequence
301:                         StopI2C2(); 
9D00F8C4  3C02BF80   LUI V0, -16512
9D00F8C8  24030004   ADDIU V1, ZERO, 4
9D00F8CC  AC435408   SW V1, 21512(V0)
302:                         IdleI2C2();
9D00F8D0  0F4061C4   JAL IdleI2C2
9D00F8D4  00000000   NOP
303:                     } // page repeat
304:                         
305:                     // verify 
306:                     /// TBD
307:                     
308:                     return 1;   // success
9D00F8E4  24020001   ADDIU V0, ZERO, 1
309:                 } // EEPROMWriteArray
9D00F8E8  03C0E821   ADDU SP, S8, ZERO
9D00F8EC  8FBF001C   LW RA, 28(SP)
9D00F8F0  8FBE0018   LW S8, 24(SP)
9D00F8F4  27BD0020   ADDIU SP, SP, 32
9D00F8F8  03E00008   JR RA
9D00F8FC  00000000   NOP
310:                 
311:                 
312:                 /************************************************************************
313:                 * Function: void EEPROMReadArray(WORD address, BYTE* pData, nCount)
314:                 *                                                                       
315:                 * Overview: this function reads  data into buffer specified
316:                 *                                                                       
317:                 * Input: flash memory address, pointer to the buffer, data number
318:                 *                                                                       
319:                 ************************************************************************/
320:                 void EEPROMReadArray(WORD address, BYTE* pData, WORD nCount)
321:                 {
9D00F900  27BDFFE0   ADDIU SP, SP, -32
9D00F904  AFBF001C   SW RA, 28(SP)
9D00F908  AFBE0018   SW S8, 24(SP)
9D00F90C  03A0F021   ADDU S8, SP, ZERO
9D00F910  00801821   ADDU V1, A0, ZERO
9D00F914  AFC50024   SW A1, 36(S8)
9D00F918  00C01021   ADDU V0, A2, ZERO
9D00F91C  A7C30020   SH V1, 32(S8)
9D00F920  A7C20028   SH V0, 40(S8)
322:                     int cmd, r; 
323:                    
324:                     // 1. select address
325:                     cmd = addressSEE( address);
9D00F924  97C20020   LHU V0, 32(S8)
9D00F928  00402021   ADDU A0, V0, ZERO
9D00F92C  0F403D0B   JAL addressSEE
9D00F930  00000000   NOP
9D00F934  AFC20010   SW V0, 16(S8)
326:                     
327:                     StopI2C2();
9D00F938  3C02BF80   LUI V0, -16512
9D00F93C  24030004   ADDIU V1, ZERO, 4
9D00F940  AC435408   SW V1, 21512(V0)
328:                     IdleI2C2();
9D00F944  0F4061C4   JAL IdleI2C2
9D00F948  00000000   NOP
329:                       
330:                     // 2. read command
331:                     StartI2C2(); IdleI2C2();
9D00F94C  3C02BF80   LUI V0, -16512
9D00F950  24030001   ADDIU V1, ZERO, 1
9D00F954  AC435408   SW V1, 21512(V0)
9D00F958  0F4061C4   JAL IdleI2C2
9D00F95C  00000000   NOP
332:                     MasterWriteI2C2( cmd+READ_CMD);
9D00F960  8FC20010   LW V0, 16(S8)
9D00F964  304200FF   ANDI V0, V0, 255
9D00F968  24420001   ADDIU V0, V0, 1
9D00F96C  304200FF   ANDI V0, V0, 255
9D00F970  00402021   ADDU A0, V0, ZERO
9D00F974  0F406265   JAL MasterWriteI2C2
9D00F978  00000000   NOP
333:                     IdleI2C2();
9D00F97C  0F4061C4   JAL IdleI2C2
9D00F980  00000000   NOP
334:                     
335:                     *pData++ = MasterReadI2C2( );    
9D00F984  0F4063CD   JAL MasterReadI2C2
9D00F988  00000000   NOP
9D00F98C  00401821   ADDU V1, V0, ZERO
9D00F990  8FC20024   LW V0, 36(S8)
9D00F994  A0430000   SB V1, 0(V0)
9D00F998  8FC20024   LW V0, 36(S8)
9D00F99C  24420001   ADDIU V0, V0, 1
9D00F9A0  AFC20024   SW V0, 36(S8)
336:                     nCount--;
9D00F9A4  97C20028   LHU V0, 40(S8)
9D00F9A8  2442FFFF   ADDIU V0, V0, -1
9D00F9AC  A7C20028   SH V0, 40(S8)
337:                     
338:                     // 3. stream data in (will continue until NACK is sent)
339:                     while ( nCount > 0)
9D00F9B0  0B403E81   J 0x9D00FA04
9D00F9B4  00000000   NOP
9D00FA04  97C20028   LHU V0, 40(S8)
9D00FA08  1440FFEB   BNE V0, ZERO, 0x9D00F9B8
9D00FA0C  00000000   NOP
340:                     {
341:                         AckI2C2(); IdleI2C2();      
9D00F9B8  3C02BF80   LUI V0, -16512
9D00F9BC  24030020   ADDIU V1, ZERO, 32
9D00F9C0  AC435404   SW V1, 21508(V0)
9D00F9C4  3C02BF80   LUI V0, -16512
9D00F9C8  24030010   ADDIU V1, ZERO, 16
9D00F9CC  AC435408   SW V1, 21512(V0)
9D00F9D0  0F4061C4   JAL IdleI2C2
9D00F9D4  00000000   NOP
342:                         *pData++ = MasterReadI2C2( );    
9D00F9D8  0F4063CD   JAL MasterReadI2C2
9D00F9DC  00000000   NOP
9D00F9E0  00401821   ADDU V1, V0, ZERO
9D00F9E4  8FC20024   LW V0, 36(S8)
9D00F9E8  A0430000   SB V1, 0(V0)
9D00F9EC  8FC20024   LW V0, 36(S8)
9D00F9F0  24420001   ADDIU V0, V0, 1
9D00F9F4  AFC20024   SW V0, 36(S8)
343:                         nCount--;
9D00F9F8  97C20028   LHU V0, 40(S8)
9D00F9FC  2442FFFF   ADDIU V0, V0, -1
9D00FA00  A7C20028   SH V0, 40(S8)
344:                     }
345:                     
346:                     // 4. terminate read sequence (send NACK then STOP)
347:                     NotAckI2C2(); IdleI2C2();
9D00FA10  3C02BF80   LUI V0, -16512
9D00FA14  24030020   ADDIU V1, ZERO, 32
9D00FA18  AC435408   SW V1, 21512(V0)
9D00FA1C  3C02BF80   LUI V0, -16512
9D00FA20  24030010   ADDIU V1, ZERO, 16
9D00FA24  AC435408   SW V1, 21512(V0)
9D00FA28  0F4061C4   JAL IdleI2C2
9D00FA2C  00000000   NOP
348:                     StopI2C2(); IdleI2C2();
9D00FA30  3C02BF80   LUI V0, -16512
9D00FA34  24030004   ADDIU V1, ZERO, 4
9D00FA38  AC435408   SW V1, 21512(V0)
9D00FA3C  0F4061C4   JAL IdleI2C2
9D00FA40  00000000   NOP
349:                     
350:                 } // EEPROMReadArray
9D00FA44  03C0E821   ADDU SP, S8, ZERO
9D00FA48  8FBF001C   LW RA, 28(SP)
9D00FA4C  8FBE0018   LW S8, 24(SP)
9D00FA50  27BD0020   ADDIU SP, SP, 32
9D00FA54  03E00008   JR RA
9D00FA58  00000000   NOP
351:                 
---  C:/MC_XProjects/MMB/MMB.C  -------------------------------------------------------------------------
1:                   /*
2:                   ** MMB.c 
3:                   ** 
4:                   ** MikroE MMB - Support library for configuration and basic peripherals access
5:                   **
6:                   ** Author   	    Date        Rev    Comments
7:                   ** Lucio Di Jasio	08-Dec-2009	1.0		Updated for GFX lib v2.0
8:                   ** Lucio Di Jasio   12-Feb-2010 1.1     Added exit() handler
9:                   ** John Kovach 		11/6/12 Re-Wrote MMBGetKey();
10:                  **
11:                  */
12:                  #include <stdio.h>
13:                  #include "../MMB/MMB.h"
14:                  #include "../Microhip/Include/Graphics/Primitive.h"
15:                  
16:                  /*JK Remmed out becauce of:
17:                   * /Volumes/build/xc32/xc32-XC32-release-1.11/XCpp-libs/source/exit.c:(.text.exit+0x0): multiple definition of `exit'
18:                  void exit( int e)
19:                  { 
20:                      while(1);
21:                  }
22:                  
23:                  // redefine the exception handler for debugging purposes
24:                  void _general_exception_handler( unsigned c, unsigned s)
25:                  {
26:                      while (1);
27:                  } // exception handler
28:                  */
29:                  
30:                  void MMBInit( void)
31:                  {
9D007E9C  27BDFFE8   ADDIU SP, SP, -24
9D007EA0  AFBF0014   SW RA, 20(SP)
9D007EA4  AFBE0010   SW S8, 16(SP)
9D007EA8  03A0F021   ADDU S8, SP, ZERO
32:                      // 1. disable the JTAG port  
33:                      mJTAGPortEnable( 0);
9D007EAC  3C03BF81   LUI V1, -16511
9D007EB0  8C62F200   LW V0, -3584(V1)
9D007EB4  7C0218C4   INS V0, ZERO, 3, 1
9D007EB8  AC62F200   SW V0, -3584(V1)
34:                      
35:                      // 2. Config system for max performance
36:                      //JK SYSTEMConfig( GetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
37:                     
38:                      // 3. allow vectored interrupts
39:                      INTEnableSystemMultiVectoredInt();   // Interrupt vectoring
9D007EBC  0F406436   JAL INTEnableSystemMultiVectoredInt
9D007EC0  00000000   NOP
40:                      
41:                      // 4. enable joystick input
42:                  	AD1PCFG |= 0x000F;   // all PORTB inputs digital
9D007EC4  3C02BF81   LUI V0, -16511
9D007EC8  8C429060   LW V0, -28576(V0)
9D007ECC  3443000F   ORI V1, V0, 15
9D007ED0  3C02BF81   LUI V0, -16511
9D007ED4  AC439060   SW V1, -28576(V0)
43:                      
44:                      // 5. init LEDs 	
45:                  	LD0 = LED_OFF;  // turn all LED off
9D007ED8  3C03BF88   LUI V1, -16504
9D007EDC  8C626020   LW V0, 24608(V1)
9D007EE0  24040001   ADDIU A0, ZERO, 1
9D007EE4  7C820004   INS V0, A0, 0, 1
9D007EE8  AC626020   SW V0, 24608(V1)
46:                  	LD1 = LED_OFF;  
9D007EEC  3C03BF88   LUI V1, -16504
9D007EF0  8C626020   LW V0, 24608(V1)
9D007EF4  24040001   ADDIU A0, ZERO, 1
9D007EF8  7C820844   INS V0, A0, 1, 1
9D007EFC  AC626020   SW V0, 24608(V1)
47:                  	LD2 = LED_OFF;
9D007F00  3C03BF88   LUI V1, -16504
9D007F04  8C6260E0   LW V0, 24800(V1)
9D007F08  24040001   ADDIU A0, ZERO, 1
9D007F0C  7C824A44   INS V0, A0, 9, 1
9D007F10  AC6260E0   SW V0, 24800(V1)
48:                  	LD4 = LED_OFF;
9D007F14  3C03BF88   LUI V1, -16504
9D007F18  8C626020   LW V0, 24608(V1)
9D007F1C  24040001   ADDIU A0, ZERO, 1
9D007F20  7C824A44   INS V0, A0, 9, 1
9D007F24  AC626020   SW V0, 24608(V1)
49:                  	LD0_TRIS = 0;     // make LED outputs
9D007F28  3C03BF88   LUI V1, -16504
9D007F2C  8C626000   LW V0, 24576(V1)
9D007F30  7C020004   INS V0, ZERO, 0, 1
9D007F34  AC626000   SW V0, 24576(V1)
50:                  	LD1_TRIS = 0;     // make LED outputs
9D007F38  3C03BF88   LUI V1, -16504
9D007F3C  8C626000   LW V0, 24576(V1)
9D007F40  7C020844   INS V0, ZERO, 1, 1
9D007F44  AC626000   SW V0, 24576(V1)
51:                  	LD2_TRIS = 0;     // make LED outputs
9D007F48  3C03BF88   LUI V1, -16504
9D007F4C  8C6260C0   LW V0, 24768(V1)
9D007F50  7C024A44   INS V0, ZERO, 9, 1
9D007F54  AC6260C0   SW V0, 24768(V1)
52:                  	LD4_TRIS = 0;     // make LED outputs
9D007F58  3C03BF88   LUI V1, -16504
9D007F5C  8C626000   LW V0, 24576(V1)
9D007F60  7C024A44   INS V0, ZERO, 9, 1
9D007F64  AC626000   SW V0, 24576(V1)
53:                  	
54:                      // 6. Display backlight off 
55:                      BL_TRIS_BIT = 0;  // OUTPUT     
9D007F68  3C03BF88   LUI V1, -16504
9D007F6C  8C6260C0   LW V0, 24768(V1)
9D007F70  7C021084   INS V0, ZERO, 2, 1
9D007F74  AC6260C0   SW V0, 24768(V1)
56:                      //JK BacklightOff();
57:                  
58:                  } // init MikroEMMB
9D007F78  03C0E821   ADDU SP, S8, ZERO
9D007F7C  8FBF0014   LW RA, 20(SP)
9D007F80  8FBE0010   LW S8, 16(SP)
9D007F84  27BD0018   ADDIU SP, SP, 24
9D007F88  03E00008   JR RA
9D007F8C  00000000   NOP
59:                  
60:                  
61:                  /* 
62:                  ** Update all analog inputs
63:                  */
64:                  int MMBReadT( void)
65:                  {    
9D007F90  27BDFFF8   ADDIU SP, SP, -8
9D007F94  AFBE0004   SW S8, 4(SP)
9D007F98  03A0F021   ADDU S8, SP, ZERO
66:                      AD1CON1 = 0x00E0;   // auto convert after end of sampling 
9D007F9C  3C02BF81   LUI V0, -16511
9D007FA0  240300E0   ADDIU V1, ZERO, 224
9D007FA4  AC439000   SW V1, -28672(V0)
67:                      AD1CSSL = 0;        // no scanning required 
9D007FA8  3C02BF81   LUI V0, -16511
9D007FAC  AC409050   SW ZERO, -28592(V0)
68:                      AD1CON2 = 0;        // use MUXA, AVss/AVdd used as Vref+/-
9D007FB0  3C02BF81   LUI V0, -16511
9D007FB4  AC409010   SW ZERO, -28656(V0)
69:                      AD1CON3 = 0x1F0F;   // sample time = 31xTad, Tad = 2xTsys
9D007FB8  3C02BF81   LUI V0, -16511
9D007FBC  24031F0F   ADDIU V1, ZERO, 7951
9D007FC0  AC439020   SW V1, -28640(V0)
70:                      AD1CON1SET = 0x8000;// turn on the ADC
9D007FC4  3C02BF81   LUI V0, -16511
9D007FC8  34038000   ORI V1, ZERO, -32768
9D007FCC  AC439008   SW V1, -28664(V0)
71:                      AD1CHSbits.CH0SA = 8;      // select TEMP input channel
9D007FD0  3C03BF81   LUI V1, -16511
9D007FD4  8C629040   LW V0, -28608(V1)
9D007FD8  24040008   ADDIU A0, ZERO, 8
9D007FDC  7C829C04   INS V0, A0, 16, 4
9D007FE0  AC629040   SW V0, -28608(V1)
72:                      AD1CON1bits.SAMP = 1;       // start sampling
9D007FE4  3C03BF81   LUI V1, -16511
9D007FE8  8C629000   LW V0, -28672(V1)
9D007FEC  24040001   ADDIU A0, ZERO, 1
9D007FF0  7C820844   INS V0, A0, 1, 1
9D007FF4  AC629000   SW V0, -28672(V1)
73:                      while (!AD1CON1bits.DONE);  // wait to complete conversion
9D007FF8  00000000   NOP
9D007FFC  3C02BF81   LUI V0, -16511
9D008000  8C429000   LW V0, -28672(V0)
9D008004  30420001   ANDI V0, V0, 1
9D008008  1040FFFC   BEQ V0, ZERO, 0x9D007FFC
9D00800C  00000000   NOP
74:                     return ADC1BUF0;            
9D008010  3C02BF81   LUI V0, -16511
9D008014  8C429070   LW V0, -28560(V0)
75:                  
76:                  } // ReadTemperature
9D008018  03C0E821   ADDU SP, S8, ZERO
9D00801C  8FBE0004   LW S8, 4(SP)
9D008020  27BD0008   ADDIU SP, SP, 8
9D008024  03E00008   JR RA
9D008028  00000000   NOP
77:                  
78:                  
79:                  // define the stopwatch function
80:                  void MMBStartStopwatch( void)
81:                  {   // resets the core timer count
9D00802C  27BDFFE8   ADDIU SP, SP, -24
9D008030  AFBF0014   SW RA, 20(SP)
9D008034  AFBE0010   SW S8, 16(SP)
9D008038  03A0F021   ADDU S8, SP, ZERO
82:                      WriteCoreTimer( 0);
9D00803C  00002021   ADDU A0, ZERO, ZERO
9D008040  0F4065D6   JAL WriteCoreTimer
9D008044  00000000   NOP
83:                  } // start_timer
9D008048  03C0E821   ADDU SP, S8, ZERO
9D00804C  8FBF0014   LW RA, 20(SP)
9D008050  8FBE0010   LW S8, 16(SP)
9D008054  27BD0018   ADDIU SP, SP, 24
9D008058  03E00008   JR RA
9D00805C  00000000   NOP
84:                  
85:                  // returns time lapsed in milliseconds 
86:                  // maximum measurable interval 107s (worst case @80MHz)
87:                  double MMBReadStopwatch( void)
88:                  {
9D008060  27BDFFE0   ADDIU SP, SP, -32
9D008064  AFBF001C   SW RA, 28(SP)
9D008068  AFBE0018   SW S8, 24(SP)
9D00806C  03A0F021   ADDU S8, SP, ZERO
89:                      unsigned int ui;
90:                      
91:                      // get the core timer count
92:                      ui = ReadCoreTimer();
9D008070  0F4065D4   JAL ReadCoreTimer
9D008074  00000000   NOP
9D008078  AFC20010   SW V0, 16(S8)
93:                      
94:                      // convert in milliseconds (1 core tick = 2 SYS cycles)
95:                      return ( ui * 2000.0 /GetSystemClock());     
9D00807C  8FC40010   LW A0, 16(S8)
9D008080  0F406350   JAL __floatunsisf
9D008084  00000000   NOP
9D008088  00401821   ADDU V1, V0, ZERO
9D00808C  3C029D02   LUI V0, -25342
9D008090  00602021   ADDU A0, V1, ZERO
9D008094  8C4596DC   LW A1, -26916(V0)
9D008098  0F4038FB   JAL fpmul
9D00809C  00000000   NOP
9D0080A0  00401821   ADDU V1, V0, ZERO
9D0080A4  3C029D02   LUI V0, -25342
9D0080A8  00602021   ADDU A0, V1, ZERO
9D0080AC  8C4596E0   LW A1, -26912(V0)
9D0080B0  0F403969   JAL __divsf3
9D0080B4  00000000   NOP
96:                  } // read_timer
9D0080B8  03C0E821   ADDU SP, S8, ZERO
9D0080BC  8FBF001C   LW RA, 28(SP)
9D0080C0  8FBE0018   LW S8, 24(SP)
9D0080C4  27BD0020   ADDIU SP, SP, 32
9D0080C8  03E00008   JR RA
9D0080CC  00000000   NOP
97:                      
98:                  void MMBUARTInit( int baudrate)
99:                  {   // initialize UART1 for default stdout redirection
9D0080D0  27BDFFC8   ADDIU SP, SP, -56
9D0080D4  AFBF0034   SW RA, 52(SP)
9D0080D8  AFBE0030   SW S8, 48(SP)
9D0080DC  AFB1002C   SW S1, 44(SP)
9D0080E0  AFB00028   SW S0, 40(SP)
9D0080E4  03A0F021   ADDU S8, SP, ZERO
9D0080E8  AFC40038   SW A0, 56(S8)
100:                     // optimize baudrate divider for best approximation
101:                     int fpb = GetPeripheralClock();
9D0080EC  3C02BF81   LUI V0, -16511
9D0080F0  8C42F000   LW V0, -4096(V0)
9D0080F4  7C420CC0   EXT V0, V0, 19, 2
9D0080F8  304200FF   ANDI V0, V0, 255
9D0080FC  3C0304C4   LUI V1, 1220
9D008100  3463B400   ORI V1, V1, -19456
9D008104  00431006   SRLV V0, V1, V0
9D008108  AFC20018   SW V0, 24(S8)
102:                     int c1 = UART_EN;
9D00810C  34028000   ORI V0, ZERO, -32768
9D008110  AFC20010   SW V0, 16(S8)
103:                     int c2 = UART_TX_ENABLE | UART_RX_ENABLE | UART_EN_CTS_RTS;
9D008114  24021600   ADDIU V0, ZERO, 5632
9D008118  AFC2001C   SW V0, 28(S8)
104:                     int c3 = fpb/16/baudrate;
9D00811C  8FC20018   LW V0, 24(S8)
9D008120  2443000F   ADDIU V1, V0, 15
9D008124  28440000   SLTI A0, V0, 0
9D008128  0064100B   MOVN V0, V1, A0
9D00812C  00021103   SRA V0, V0, 4
9D008130  00401821   ADDU V1, V0, ZERO
9D008134  8FC20038   LW V0, 56(S8)
9D008138  0062001A   DIV V1, V0
9D00813C  004001F4   TEQ V0, ZERO
9D008140  00001810   MFHI V1
9D008144  00001012   MFLO V0
9D008148  AFC20014   SW V0, 20(S8)
105:                     int c4 = fpb/4/baudrate;
9D00814C  8FC20018   LW V0, 24(S8)
9D008150  24430003   ADDIU V1, V0, 3
9D008154  28440000   SLTI A0, V0, 0
9D008158  0064100B   MOVN V0, V1, A0
9D00815C  00021083   SRA V0, V0, 2
9D008160  00401821   ADDU V1, V0, ZERO
9D008164  8FC20038   LW V0, 56(S8)
9D008168  0062001A   DIV V1, V0
9D00816C  004001F4   TEQ V0, ZERO
9D008170  00001810   MFHI V1
9D008174  00001012   MFLO V0
9D008178  AFC20020   SW V0, 32(S8)
106:                     
107:                     // check if /4 gives a better approx
108:                     if ( ( fpb / 16.0 / c3) > ( fpb / 4.0 / c4))
9D00817C  8FC40018   LW A0, 24(S8)
9D008180  0F4039F4   JAL litofp
9D008184  00000000   NOP
9D008188  00401821   ADDU V1, V0, ZERO
9D00818C  3C029D02   LUI V0, -25342
9D008190  00602021   ADDU A0, V1, ZERO
9D008194  8C4596E4   LW A1, -26908(V0)
9D008198  0F403969   JAL __divsf3
9D00819C  00000000   NOP
9D0081A0  00408021   ADDU S0, V0, ZERO
9D0081A4  8FC40014   LW A0, 20(S8)
9D0081A8  0F4039F4   JAL litofp
9D0081AC  00000000   NOP
9D0081B0  02002021   ADDU A0, S0, ZERO
9D0081B4  00402821   ADDU A1, V0, ZERO
9D0081B8  0F403969   JAL __divsf3
9D0081BC  00000000   NOP
9D0081C0  00408821   ADDU S1, V0, ZERO
9D0081C4  8FC40018   LW A0, 24(S8)
9D0081C8  0F4039F4   JAL litofp
9D0081CC  00000000   NOP
9D0081D0  00401821   ADDU V1, V0, ZERO
9D0081D4  3C029D02   LUI V0, -25342
9D0081D8  00602021   ADDU A0, V1, ZERO
9D0081DC  8C4596E8   LW A1, -26904(V0)
9D0081E0  0F403969   JAL __divsf3
9D0081E4  00000000   NOP
9D0081E8  00408021   ADDU S0, V0, ZERO
9D0081EC  8FC40020   LW A0, 32(S8)
9D0081F0  0F4039F4   JAL litofp
9D0081F4  00000000   NOP
9D0081F8  02002021   ADDU A0, S0, ZERO
9D0081FC  00402821   ADDU A1, V0, ZERO
9D008200  0F403969   JAL __divsf3
9D008204  00000000   NOP
9D008208  24100001   ADDIU S0, ZERO, 1
9D00820C  00402021   ADDU A0, V0, ZERO
9D008210  02202821   ADDU A1, S1, ZERO
9D008214  0F403A59   JAL __gesf2
9D008218  00000000   NOP
9D00821C  04400002   BLTZ V0, 0x9D008228
9D008220  00000000   NOP
9D008224  00008021   ADDU S0, ZERO, ZERO
9D008228  320200FF   ANDI V0, S0, 255
9D00822C  10400006   BEQ V0, ZERO, 0x9D008248
9D008230  00000000   NOP
109:                     {   // use the /4 factor
110:                         c3=c4;  
9D008234  8FC20020   LW V0, 32(S8)
9D008238  AFC20014   SW V0, 20(S8)
111:                         // select BREGH =1
112:                         c1 |= UART_BRGH_FOUR;
9D00823C  8FC20010   LW V0, 16(S8)
9D008240  34420008   ORI V0, V0, 8
9D008244  AFC20010   SW V0, 16(S8)
113:                     }
114:                         
115:                 	// enable UART1 (RS232) TX 
116:                 	OpenUART1( c1, c2, c3-1);	
9D008248  8FC20014   LW V0, 20(S8)
9D00824C  2442FFFF   ADDIU V0, V0, -1
9D008250  00401821   ADDU V1, V0, ZERO
9D008254  3C02BF80   LUI V0, -16512
9D008258  AC436040   SW V1, 24640(V0)
9D00825C  8FC30010   LW V1, 16(S8)
9D008260  3C02BF80   LUI V0, -16512
9D008264  AC436000   SW V1, 24576(V0)
9D008268  8FC3001C   LW V1, 28(S8)
9D00826C  3C02BF80   LUI V0, -16512
9D008270  AC436010   SW V1, 24592(V0)
117:                     //setbuf( stdout, NULL);
118:                     
119:                 } // init_UART
9D008274  03C0E821   ADDU SP, S8, ZERO
9D008278  8FBF0034   LW RA, 52(SP)
9D00827C  8FBE0030   LW S8, 48(SP)
9D008280  8FB1002C   LW S1, 44(SP)
9D008284  8FB00028   LW S0, 40(SP)
9D008288  27BD0038   ADDIU SP, SP, 56
9D00828C  03E00008   JR RA
9D008290  00000000   NOP
120:                   
121:                 /*
122:                 **
123:                 **	Buttons read and debounce
124:                 */
125:                 
126:                 int ReadJoyStick( void)
127:                 {   // returns 0..F if keys pressed, 0 = none
9D008294  27BDFFF0   ADDIU SP, SP, -16
9D008298  AFBE000C   SW S8, 12(SP)
9D00829C  03A0F021   ADDU S8, SP, ZERO
128:                     int c = 0;
9D0082A0  AFC00000   SW ZERO, 0(S8)
129:                 
130:                     if ( !_RA10) // Select
9D0082A4  3C02BF88   LUI V0, -16504
9D0082A8  8C426010   LW V0, 24592(V0)
9D0082AC  30420400   ANDI V0, V0, 1024
9D0082B0  14400004   BNE V0, ZERO, 0x9D0082C4
9D0082B4  00000000   NOP
131:                         c |= 16;
9D0082B8  8FC20000   LW V0, 0(S8)
9D0082BC  34420010   ORI V0, V0, 16
9D0082C0  AFC20000   SW V0, 0(S8)
132:                     if ( !BTN_A) 
9D0082C4  3C02BF88   LUI V0, -16504
9D0082C8  8C426050   LW V0, 24656(V0)
9D0082CC  30420001   ANDI V0, V0, 1
9D0082D0  14400004   BNE V0, ZERO, 0x9D0082E4
9D0082D4  00000000   NOP
133:                         c |= 8;
9D0082D8  8FC20000   LW V0, 0(S8)
9D0082DC  34420008   ORI V0, V0, 8
9D0082E0  AFC20000   SW V0, 0(S8)
134:                     if ( !BTN_B) 
9D0082E4  3C02BF88   LUI V0, -16504
9D0082E8  8C426050   LW V0, 24656(V0)
9D0082EC  30420002   ANDI V0, V0, 2
9D0082F0  14400004   BNE V0, ZERO, 0x9D008304
9D0082F4  00000000   NOP
135:                         c |= 4;
9D0082F8  8FC20000   LW V0, 0(S8)
9D0082FC  34420004   ORI V0, V0, 4
9D008300  AFC20000   SW V0, 0(S8)
136:                     if ( !BTN_C) 
9D008304  3C02BF88   LUI V0, -16504
9D008308  8C426050   LW V0, 24656(V0)
9D00830C  30420004   ANDI V0, V0, 4
9D008310  14400004   BNE V0, ZERO, 0x9D008324
9D008314  00000000   NOP
137:                         c |= 2;
9D008318  8FC20000   LW V0, 0(S8)
9D00831C  34420002   ORI V0, V0, 2
9D008320  AFC20000   SW V0, 0(S8)
138:                     if ( !BTN_D) 
9D008324  3C02BF88   LUI V0, -16504
9D008328  8C426050   LW V0, 24656(V0)
9D00832C  30420008   ANDI V0, V0, 8
9D008330  14400004   BNE V0, ZERO, 0x9D008344
9D008334  00000000   NOP
139:                         c |= 1;
9D008338  8FC20000   LW V0, 0(S8)
9D00833C  34420001   ORI V0, V0, 1
9D008340  AFC20000   SW V0, 0(S8)
140:                 
141:                     return c;
9D008344  8FC20000   LW V0, 0(S8)
142:                 } // readKEY
9D008348  03C0E821   ADDU SP, S8, ZERO
9D00834C  8FBE000C   LW S8, 12(SP)
9D008350  27BD0010   ADDIU SP, SP, 16
9D008354  03E00008   JR RA
9D008358  00000000   NOP
143:                 
144:                 
145:                 int GetJoyStick( void)
146:                 {   // wait for a key pressed and debounce
9D00835C  27BDFFD8   ADDIU SP, SP, -40
9D008360  AFBF0024   SW RA, 36(SP)
9D008364  AFBE0020   SW S8, 32(SP)
9D008368  03A0F021   ADDU S8, SP, ZERO
147:                     int i=0, r=0, j=0;
9D00836C  AFC00010   SW ZERO, 16(S8)
9D008370  AFC00014   SW ZERO, 20(S8)
9D008374  AFC00018   SW ZERO, 24(S8)
148:                     int c;
149:                 
150:                     // 1. wait for a key pressed for at least .1sec
151:                     while(r == 0)
9D008378  0B4020E6   J 0x9D008398
9D00837C  00000000   NOP
9D008398  8FC20014   LW V0, 20(S8)
9D00839C  1040FFF8   BEQ V0, ZERO, 0x9D008380
9D0083A0  00000000   NOP
152:                     {
153:                 	    r = ReadJoyStick();
9D008380  0F4020A5   JAL ReadJoyStick
9D008384  00000000   NOP
9D008388  AFC20014   SW V0, 20(S8)
154:                 	    DelayMs( 10);
9D00838C  2404000A   ADDIU A0, ZERO, 10
9D008390  0F40095A   JAL DelayMs
9D008394  00000000   NOP
155:                 	}
156:                     do{
157:                 		c = ReadJoyStick();
9D0083A4  0F4020A5   JAL ReadJoyStick
9D0083A8  00000000   NOP
9D0083AC  AFC2001C   SW V0, 28(S8)
158:                         DelayMs( 10);
9D0083B0  2404000A   ADDIU A0, ZERO, 10
9D0083B4  0F40095A   JAL DelayMs
9D0083B8  00000000   NOP
159:                         
160:                         if (c > 0) //Another key has been pressed
9D0083BC  8FC2001C   LW V0, 28(S8)
9D0083C0  1840000A   BLEZ V0, 0x9D0083EC
9D0083C4  00000000   NOP
161:                         {
162:                             if ( c != r)       // if more than one button pressed
9D0083C8  8FC3001C   LW V1, 28(S8)
9D0083CC  8FC20014   LW V0, 20(S8)
9D0083D0  10620003   BEQ V1, V0, 0x9D0083E0
9D0083D4  00000000   NOP
163:                             r = c;      // take the new code
9D0083D8  8FC2001C   LW V0, 28(S8)
9D0083DC  AFC20014   SW V0, 20(S8)
164:                             i = 0;    
9D0083E0  AFC00010   SW ZERO, 16(S8)
9D0083E4  0B4020FE   J 0x9D0083F8
9D0083E8  00000000   NOP
165:                         }
166:                         else 
167:                             i++;
9D0083EC  8FC20010   LW V0, 16(S8)
9D0083F0  24420001   ADDIU V0, V0, 1
9D0083F4  AFC20010   SW V0, 16(S8)
168:                     } while ( i < 5);
9D0083F8  8FC20010   LW V0, 16(S8)
9D0083FC  28420005   SLTI V0, V0, 5
9D008400  1440FFE8   BNE V0, ZERO, 0x9D0083A4
9D008404  00000000   NOP
169:                         
170:                     return r;
9D008408  8FC20014   LW V0, 20(S8)
171:                 } // getKEY
9D00840C  03C0E821   ADDU SP, S8, ZERO
9D008410  8FBF0024   LW RA, 36(SP)
9D008414  8FBE0020   LW S8, 32(SP)
9D008418  27BD0028   ADDIU SP, SP, 40
9D00841C  03E00008   JR RA
9D008420  00000000   NOP
172:                 
173:                 // 
174:                 // Accelerometer 
175:                 // 
176:                 int MMBAccInit( void)
177:                 {
9D008424  27BDFFE0   ADDIU SP, SP, -32
9D008428  AFBF001C   SW RA, 28(SP)
9D00842C  AFBE0018   SW S8, 24(SP)
9D008430  03A0F021   ADDU S8, SP, ZERO
178:                     int w;
179:                     
180:                     // configure SPI port for accelerometer access	
181:                 	CloseSPI1();
9D008434  3C02BF80   LUI V0, -16512
9D008438  34038000   ORI V1, ZERO, -32768
9D00843C  AC435E04   SW V1, 24068(V0)
9D008440  3C02BF88   LUI V0, -16504
9D008444  3C030380   LUI V1, 896
9D008448  AC431064   SW V1, 4196(V0)
9D00844C  3C02BF88   LUI V0, -16504
9D008450  3C030380   LUI V1, 896
9D008454  AC431034   SW V1, 4148(V0)
182:                 	OpenSPI1( PRI_PRESCAL_64_1 | SEC_PRESCAL_8_1 | MASTER_ENABLE_ON | CLK_POL_ACTIVE_LOW | SPI_SMP_ON , 
9D008458  24040260   ADDIU A0, ZERO, 608
9D00845C  34058000   ORI A1, ZERO, -32768
9D008460  0F40624D   JAL OpenSPI1
9D008464  00000000   NOP
183:                 	        SPI_ENABLE);
184:                     SPI1BRG = GetPeripheralClock()/ 4000000 / 4;
9D008468  3C02BF81   LUI V0, -16511
9D00846C  8C42F000   LW V0, -4096(V0)
9D008470  7C420CC0   EXT V0, V0, 19, 2
9D008474  304200FF   ANDI V0, V0, 255
9D008478  3C0304C4   LUI V1, 1220
9D00847C  3463B400   ORI V1, V1, -19456
9D008480  00431806   SRLV V1, V1, V0
9D008484  3C02431B   LUI V0, 17179
9D008488  3442DE83   ORI V0, V0, -8573
9D00848C  00620019   MULTU V1, V0
9D008490  00001012   MFLO V0
9D008494  00001810   MFHI V1
9D008498  00031D82   SRL V1, V1, 22
9D00849C  3C02BF80   LUI V0, -16512
9D0084A0  AC435E30   SW V1, 24112(V0)
185:                     	      
186:                     // enable Accelerometer
187:                     CS_ACC_LAT_BIT = 1;    	      
9D0084A4  3C03BF88   LUI V1, -16504
9D0084A8  8C6260A0   LW V0, 24736(V1)
9D0084AC  24040001   ADDIU A0, ZERO, 1
9D0084B0  7C8218C4   INS V0, A0, 3, 1
9D0084B4  AC6260A0   SW V0, 24736(V1)
188:                     CS_ACC_TRIS_BIT = 0;
9D0084B8  3C03BF88   LUI V1, -16504
9D0084BC  8C626080   LW V0, 24704(V1)
9D0084C0  7C0218C4   INS V0, ZERO, 3, 1
9D0084C4  AC626080   SW V0, 24704(V1)
189:                     DelayMs( 10);
9D0084C8  2404000A   ADDIU A0, ZERO, 10
9D0084CC  0F40095A   JAL DelayMs
9D0084D0  00000000   NOP
190:                     w = ReadSPI1();             // dummy
9D0084D4  3C02BF80   LUI V0, -16512
9D0084D8  8C425E20   LW V0, 24096(V0)
9D0084DC  AFC20010   SW V0, 16(S8)
191:                 
192:                     // Read DEVID register (test)
193:                     CS_ACC_LAT_BIT = 0; 
9D0084E0  3C03BF88   LUI V1, -16504
9D0084E4  8C6260A0   LW V0, 24736(V1)
9D0084E8  7C0218C4   INS V0, ZERO, 3, 1
9D0084EC  AC6260A0   SW V0, 24736(V1)
194:                     WriteSPI1( 0x80 | 0x00 );   // read DEVID register
9D0084F0  3C02BF80   LUI V0, -16512
9D0084F4  24030080   ADDIU V1, ZERO, 128
9D0084F8  AC435E20   SW V1, 24096(V0)
195:                     while( !DataRdySPI1());
9D0084FC  00000000   NOP
9D008500  3C02BF80   LUI V0, -16512
9D008504  8C425E10   LW V0, 24080(V0)
9D008508  30420001   ANDI V0, V0, 1
9D00850C  1040FFFC   BEQ V0, ZERO, 0x9D008500
9D008510  00000000   NOP
196:                     w = ReadSPI1();             // dummy
9D008514  3C02BF80   LUI V0, -16512
9D008518  8C425E20   LW V0, 24096(V0)
9D00851C  AFC20010   SW V0, 16(S8)
197:                 
198:                     WriteSPI1( 0);              // dummy
9D008520  3C02BF80   LUI V0, -16512
9D008524  AC405E20   SW ZERO, 24096(V0)
199:                     while( !DataRdySPI1());
9D008528  00000000   NOP
9D00852C  3C02BF80   LUI V0, -16512
9D008530  8C425E10   LW V0, 24080(V0)
9D008534  30420001   ANDI V0, V0, 1
9D008538  1040FFFC   BEQ V0, ZERO, 0x9D00852C
9D00853C  00000000   NOP
200:                     w = ReadSPI1();             // read DEVID
9D008540  3C02BF80   LUI V0, -16512
9D008544  8C425E20   LW V0, 24096(V0)
9D008548  AFC20010   SW V0, 16(S8)
201:                     CS_ACC_LAT_BIT = 1;
9D00854C  3C03BF88   LUI V1, -16504
9D008550  8C6260A0   LW V0, 24736(V1)
9D008554  24040001   ADDIU A0, ZERO, 1
9D008558  7C8218C4   INS V0, A0, 3, 1
9D00855C  AC6260A0   SW V0, 24736(V1)
202:                     if ( w != 0xE5) 
9D008560  8FC30010   LW V1, 16(S8)
9D008564  240200E5   ADDIU V0, ZERO, 229
9D008568  10620004   BEQ V1, V0, 0x9D00857C
9D00856C  00000000   NOP
203:                         return 0;               // Failed 
9D008570  00001021   ADDU V0, ZERO, ZERO
9D008574  0B402181   J 0x9D008604
9D008578  00000000   NOP
204:                 
205:                     // enable measurement
206:                     CS_ACC_LAT_BIT = 0; 
9D00857C  3C03BF88   LUI V1, -16504
9D008580  8C6260A0   LW V0, 24736(V1)
9D008584  7C0218C4   INS V0, ZERO, 3, 1
9D008588  AC6260A0   SW V0, 24736(V1)
207:                     WriteSPI1( 0x00 | 0x2D );   // write to POWER_CTL register
9D00858C  3C02BF80   LUI V0, -16512
9D008590  2403002D   ADDIU V1, ZERO, 45
9D008594  AC435E20   SW V1, 24096(V0)
208:                     while( !DataRdySPI1());
9D008598  00000000   NOP
9D00859C  3C02BF80   LUI V0, -16512
9D0085A0  8C425E10   LW V0, 24080(V0)
9D0085A4  30420001   ANDI V0, V0, 1
9D0085A8  1040FFFC   BEQ V0, ZERO, 0x9D00859C
9D0085AC  00000000   NOP
209:                     w = ReadSPI1();             // dummy
9D0085B0  3C02BF80   LUI V0, -16512
9D0085B4  8C425E20   LW V0, 24096(V0)
9D0085B8  AFC20010   SW V0, 16(S8)
210:                     
211:                     WriteSPI1( 0x08);           // set Measure bit ON
9D0085BC  3C02BF80   LUI V0, -16512
9D0085C0  24030008   ADDIU V1, ZERO, 8
9D0085C4  AC435E20   SW V1, 24096(V0)
212:                     while( !DataRdySPI1());
9D0085C8  00000000   NOP
9D0085CC  3C02BF80   LUI V0, -16512
9D0085D0  8C425E10   LW V0, 24080(V0)
9D0085D4  30420001   ANDI V0, V0, 1
9D0085D8  1040FFFC   BEQ V0, ZERO, 0x9D0085CC
9D0085DC  00000000   NOP
213:                     w = ReadSPI1();             // dummy
9D0085E0  3C02BF80   LUI V0, -16512
9D0085E4  8C425E20   LW V0, 24096(V0)
9D0085E8  AFC20010   SW V0, 16(S8)
214:                     CS_ACC_LAT_BIT = 1;
9D0085EC  3C03BF88   LUI V1, -16504
9D0085F0  8C6260A0   LW V0, 24736(V1)
9D0085F4  24040001   ADDIU A0, ZERO, 1
9D0085F8  7C8218C4   INS V0, A0, 3, 1
9D0085FC  AC6260A0   SW V0, 24736(V1)
215:                     
216:                     return 1;                   // Success 
9D008600  24020001   ADDIU V0, ZERO, 1
217:                 } // MMBAccInit
9D008604  03C0E821   ADDU SP, S8, ZERO
9D008608  8FBF001C   LW RA, 28(SP)
9D00860C  8FBE0018   LW S8, 24(SP)
9D008610  27BD0020   ADDIU SP, SP, 32
9D008614  03E00008   JR RA
9D008618  00000000   NOP
218:                 
219:                 
220:                 void MMBAccRead( int* x, int* y, int*z)
221:                 {
9D00861C  27BDFFF0   ADDIU SP, SP, -16
9D008620  AFBE000C   SW S8, 12(SP)
9D008624  03A0F021   ADDU S8, SP, ZERO
9D008628  AFC40010   SW A0, 16(S8)
9D00862C  AFC50014   SW A1, 20(S8)
9D008630  AFC60018   SW A2, 24(S8)
222:                     int w;
223:                     
224:                     // read acceleration values
225:                     CS_ACC_LAT_BIT = 0; 
9D008634  3C03BF88   LUI V1, -16504
9D008638  8C6260A0   LW V0, 24736(V1)
9D00863C  7C0218C4   INS V0, ZERO, 3, 1
9D008640  AC6260A0   SW V0, 24736(V1)
226:                     WriteSPI1(0xC0 | 0x32 ); // read DataX0/X1/Y0/Y1/Z0/Z1
9D008644  3C02BF80   LUI V0, -16512
9D008648  240300F2   ADDIU V1, ZERO, 242
9D00864C  AC435E20   SW V1, 24096(V0)
227:                     while( !DataRdySPI1());
9D008650  00000000   NOP
9D008654  3C02BF80   LUI V0, -16512
9D008658  8C425E10   LW V0, 24080(V0)
9D00865C  30420001   ANDI V0, V0, 1
9D008660  1040FFFC   BEQ V0, ZERO, 0x9D008654
9D008664  00000000   NOP
228:                     w = ReadSPI1();          // dummy
9D008668  3C02BF80   LUI V0, -16512
9D00866C  8C425E20   LW V0, 24096(V0)
9D008670  AFC20000   SW V0, 0(S8)
229:                 
230:                     WriteSPI1(0x00);
9D008674  3C02BF80   LUI V0, -16512
9D008678  AC405E20   SW ZERO, 24096(V0)
231:                     while( !DataRdySPI1());
9D00867C  00000000   NOP
9D008680  3C02BF80   LUI V0, -16512
9D008684  8C425E10   LW V0, 24080(V0)
9D008688  30420001   ANDI V0, V0, 1
9D00868C  1040FFFC   BEQ V0, ZERO, 0x9D008680
9D008690  00000000   NOP
232:                     *x = ReadSPI1();         // read lsb
9D008694  3C02BF80   LUI V0, -16512
9D008698  8C425E20   LW V0, 24096(V0)
9D00869C  00401821   ADDU V1, V0, ZERO
9D0086A0  8FC20010   LW V0, 16(S8)
9D0086A4  AC430000   SW V1, 0(V0)
233:                     WriteSPI1(0x00);
9D0086A8  3C02BF80   LUI V0, -16512
9D0086AC  AC405E20   SW ZERO, 24096(V0)
234:                     while( !DataRdySPI1());
9D0086B0  00000000   NOP
9D0086B4  3C02BF80   LUI V0, -16512
9D0086B8  8C425E10   LW V0, 24080(V0)
9D0086BC  30420001   ANDI V0, V0, 1
9D0086C0  1040FFFC   BEQ V0, ZERO, 0x9D0086B4
9D0086C4  00000000   NOP
235:                     *x |= ReadSPI1()<<8;     // read msb
9D0086C8  8FC20010   LW V0, 16(S8)
9D0086CC  8C420000   LW V0, 0(V0)
9D0086D0  00401821   ADDU V1, V0, ZERO
9D0086D4  3C02BF80   LUI V0, -16512
9D0086D8  8C425E20   LW V0, 24096(V0)
9D0086DC  00021200   SLL V0, V0, 8
9D0086E0  00621025   OR V0, V1, V0
9D0086E4  00401821   ADDU V1, V0, ZERO
9D0086E8  8FC20010   LW V0, 16(S8)
9D0086EC  AC430000   SW V1, 0(V0)
236:                     if (*x >32767) *x-=65536;
9D0086F0  8FC20010   LW V0, 16(S8)
9D0086F4  8C430000   LW V1, 0(V0)
9D0086F8  34028000   ORI V0, ZERO, -32768
9D0086FC  0062102A   SLT V0, V1, V0
9D008700  14400007   BNE V0, ZERO, 0x9D008720
9D008704  00000000   NOP
9D008708  8FC20010   LW V0, 16(S8)
9D00870C  8C430000   LW V1, 0(V0)
9D008710  3C02FFFF   LUI V0, -1
9D008714  00621821   ADDU V1, V1, V0
9D008718  8FC20010   LW V0, 16(S8)
9D00871C  AC430000   SW V1, 0(V0)
237:                 
238:                     WriteSPI1(0x00);
9D008720  3C02BF80   LUI V0, -16512
9D008724  AC405E20   SW ZERO, 24096(V0)
239:                     while( !DataRdySPI1());
9D008728  00000000   NOP
9D00872C  3C02BF80   LUI V0, -16512
9D008730  8C425E10   LW V0, 24080(V0)
9D008734  30420001   ANDI V0, V0, 1
9D008738  1040FFFC   BEQ V0, ZERO, 0x9D00872C
9D00873C  00000000   NOP
240:                     *y = ReadSPI1();         // read lsb
9D008740  3C02BF80   LUI V0, -16512
9D008744  8C425E20   LW V0, 24096(V0)
9D008748  00401821   ADDU V1, V0, ZERO
9D00874C  8FC20014   LW V0, 20(S8)
9D008750  AC430000   SW V1, 0(V0)
241:                     WriteSPI1(0x00);
9D008754  3C02BF80   LUI V0, -16512
9D008758  AC405E20   SW ZERO, 24096(V0)
242:                     while( !DataRdySPI1());
9D00875C  00000000   NOP
9D008760  3C02BF80   LUI V0, -16512
9D008764  8C425E10   LW V0, 24080(V0)
9D008768  30420001   ANDI V0, V0, 1
9D00876C  1040FFFC   BEQ V0, ZERO, 0x9D008760
9D008770  00000000   NOP
243:                     *y |= ReadSPI1()<<8;     // read msb
9D008774  8FC20014   LW V0, 20(S8)
9D008778  8C420000   LW V0, 0(V0)
9D00877C  00401821   ADDU V1, V0, ZERO
9D008780  3C02BF80   LUI V0, -16512
9D008784  8C425E20   LW V0, 24096(V0)
9D008788  00021200   SLL V0, V0, 8
9D00878C  00621025   OR V0, V1, V0
9D008790  00401821   ADDU V1, V0, ZERO
9D008794  8FC20014   LW V0, 20(S8)
9D008798  AC430000   SW V1, 0(V0)
244:                     if (*y >32767) *y-=65536;
9D00879C  8FC20014   LW V0, 20(S8)
9D0087A0  8C430000   LW V1, 0(V0)
9D0087A4  34028000   ORI V0, ZERO, -32768
9D0087A8  0062102A   SLT V0, V1, V0
9D0087AC  14400007   BNE V0, ZERO, 0x9D0087CC
9D0087B0  00000000   NOP
9D0087B4  8FC20014   LW V0, 20(S8)
9D0087B8  8C430000   LW V1, 0(V0)
9D0087BC  3C02FFFF   LUI V0, -1
9D0087C0  00621821   ADDU V1, V1, V0
9D0087C4  8FC20014   LW V0, 20(S8)
9D0087C8  AC430000   SW V1, 0(V0)
245:                 
246:                     WriteSPI1(0x00);
9D0087CC  3C02BF80   LUI V0, -16512
9D0087D0  AC405E20   SW ZERO, 24096(V0)
247:                     while( !DataRdySPI1());
9D0087D4  00000000   NOP
9D0087D8  3C02BF80   LUI V0, -16512
9D0087DC  8C425E10   LW V0, 24080(V0)
9D0087E0  30420001   ANDI V0, V0, 1
9D0087E4  1040FFFC   BEQ V0, ZERO, 0x9D0087D8
9D0087E8  00000000   NOP
248:                     *z = ReadSPI1();         // read lsb
9D0087EC  3C02BF80   LUI V0, -16512
9D0087F0  8C425E20   LW V0, 24096(V0)
9D0087F4  00401821   ADDU V1, V0, ZERO
9D0087F8  8FC20018   LW V0, 24(S8)
9D0087FC  AC430000   SW V1, 0(V0)
249:                     WriteSPI1(0x00);
9D008800  3C02BF80   LUI V0, -16512
9D008804  AC405E20   SW ZERO, 24096(V0)
250:                     while( !DataRdySPI1());
9D008808  00000000   NOP
9D00880C  3C02BF80   LUI V0, -16512
9D008810  8C425E10   LW V0, 24080(V0)
9D008814  30420001   ANDI V0, V0, 1
9D008818  1040FFFC   BEQ V0, ZERO, 0x9D00880C
9D00881C  00000000   NOP
251:                     *z |= ReadSPI1()<<8;     //read msb
9D008820  8FC20018   LW V0, 24(S8)
9D008824  8C420000   LW V0, 0(V0)
9D008828  00401821   ADDU V1, V0, ZERO
9D00882C  3C02BF80   LUI V0, -16512
9D008830  8C425E20   LW V0, 24096(V0)
9D008834  00021200   SLL V0, V0, 8
9D008838  00621025   OR V0, V1, V0
9D00883C  00401821   ADDU V1, V0, ZERO
9D008840  8FC20018   LW V0, 24(S8)
9D008844  AC430000   SW V1, 0(V0)
252:                     if (*z >32767) *z-=65536;
9D008848  8FC20018   LW V0, 24(S8)
9D00884C  8C430000   LW V1, 0(V0)
9D008850  34028000   ORI V0, ZERO, -32768
9D008854  0062102A   SLT V0, V1, V0
9D008858  14400007   BNE V0, ZERO, 0x9D008878
9D00885C  00000000   NOP
9D008860  8FC20018   LW V0, 24(S8)
9D008864  8C430000   LW V1, 0(V0)
9D008868  3C02FFFF   LUI V0, -1
9D00886C  00621821   ADDU V1, V1, V0
9D008870  8FC20018   LW V0, 24(S8)
9D008874  AC430000   SW V1, 0(V0)
253:                 
254:                     CS_ACC_LAT_BIT = 1;
9D008878  3C03BF88   LUI V1, -16504
9D00887C  8C6260A0   LW V0, 24736(V1)
9D008880  24040001   ADDIU A0, ZERO, 1
9D008884  7C8218C4   INS V0, A0, 3, 1
9D008888  AC6260A0   SW V0, 24736(V1)
255:                 } // MMBAccRead
9D00888C  03C0E821   ADDU SP, S8, ZERO
9D008890  8FBE000C   LW S8, 12(SP)
9D008894  27BD0010   ADDIU SP, SP, 16
9D008898  03E00008   JR RA
9D00889C  00000000   NOP
256:                 
257:                 
258:                 void MMBFadeIn( int msTime)
259:                 {    // time = total duration of fade-in effect
9D0088A0  27BDFFE0   ADDIU SP, SP, -32
9D0088A4  AFBF001C   SW RA, 28(SP)
9D0088A8  AFBE0018   SW S8, 24(SP)
9D0088AC  03A0F021   ADDU S8, SP, ZERO
9D0088B0  AFC40020   SW A0, 32(S8)
260:                     //  expressed in ms (100ms minimum)
261:                     int w;
262:                     
263:                     if (msTime<100) msTime = 100;
9D0088B4  8FC20020   LW V0, 32(S8)
9D0088B8  28420064   SLTI V0, V0, 100
9D0088BC  10400003   BEQ V0, ZERO, 0x9D0088CC
9D0088C0  00000000   NOP
9D0088C4  24020064   ADDIU V0, ZERO, 100
9D0088C8  AFC20020   SW V0, 32(S8)
264:                     OpenTimer2( T2_ON | T2_PS_1_1, 0 );
9D0088CC  3C02BF80   LUI V0, -16512
9D0088D0  AC400800   SW ZERO, 2048(V0)
9D0088D4  3C02BF80   LUI V0, -16512
9D0088D8  AC400810   SW ZERO, 2064(V0)
9D0088DC  3C02BF80   LUI V0, -16512
9D0088E0  AC400820   SW ZERO, 2080(V0)
9D0088E4  3C02BF80   LUI V0, -16512
9D0088E8  34038000   ORI V1, ZERO, -32768
9D0088EC  AC430808   SW V1, 2056(V0)
265:                 
266:                     // OC3 output is connected to the backlight control
267:                     OpenOC3( OC_ON | OC_PWM_FAULT_PIN_DISABLE | OC_TIMER2_SRC, 0, 0);
9D0088F0  3C02BF80   LUI V0, -16512
9D0088F4  AC403420   SW ZERO, 13344(V0)
9D0088F8  3C02BF80   LUI V0, -16512
9D0088FC  AC403410   SW ZERO, 13328(V0)
9D008900  3C02BF80   LUI V0, -16512
9D008904  34038006   ORI V1, ZERO, -32762
9D008908  AC433400   SW V1, 13312(V0)
268:                     for( w=0; w<65536; w+=65536/100)
9D00890C  AFC00010   SW ZERO, 16(S8)
9D008910  0B402256   J 0x9D008958
9D008914  00000000   NOP
9D00894C  8FC20010   LW V0, 16(S8)
9D008950  2442028F   ADDIU V0, V0, 655
9D008954  AFC20010   SW V0, 16(S8)
9D008958  8FC30010   LW V1, 16(S8)
9D00895C  3C020001   LUI V0, 1
9D008960  0062102A   SLT V0, V1, V0
9D008964  1440FFEC   BNE V0, ZERO, 0x9D008918
9D008968  00000000   NOP
269:                     {   // 100 steps
270:                         SetDCOC3PWM( w);
9D008918  8FC30010   LW V1, 16(S8)
9D00891C  3C02BF80   LUI V0, -16512
9D008920  AC433420   SW V1, 13344(V0)
271:                         DelayMs(msTime/100);
9D008924  8FC30020   LW V1, 32(S8)
9D008928  24020064   ADDIU V0, ZERO, 100
9D00892C  0062001A   DIV V1, V0
9D008930  004001F4   TEQ V0, ZERO
9D008934  00001810   MFHI V1
9D008938  00001012   MFLO V0
9D00893C  3042FFFF   ANDI V0, V0, -1
9D008940  00402021   ADDU A0, V0, ZERO
9D008944  0F40095A   JAL DelayMs
9D008948  00000000   NOP
272:                     }        
273:                     // Return display BL control to I/O
274:                     CloseOC3();
9D00896C  3C02BF88   LUI V0, -16504
9D008970  24034000   ADDIU V1, ZERO, 16384
9D008974  AC431064   SW V1, 4196(V0)
9D008978  3C02BF88   LUI V0, -16504
9D00897C  AC401068   SW ZERO, 4200(V0)
9D008980  3C02BF88   LUI V0, -16504
9D008984  24034000   ADDIU V1, ZERO, 16384
9D008988  AC431034   SW V1, 4148(V0)
9D00898C  3C02BF80   LUI V0, -16512
9D008990  34038000   ORI V1, ZERO, -32768
9D008994  AC433404   SW V1, 13316(V0)
275:                     CloseTimer2();
9D008998  3C02BF88   LUI V0, -16504
9D00899C  24030100   ADDIU V1, ZERO, 256
9D0089A0  AC431064   SW V1, 4196(V0)
9D0089A4  3C02BF88   LUI V0, -16504
9D0089A8  AC401068   SW ZERO, 4200(V0)
9D0089AC  3C02BF80   LUI V0, -16512
9D0089B0  AC400800   SW ZERO, 2048(V0)
276:                     // Full brightness
277:                     BacklightOn();
9D0089B4  3C03BF88   LUI V1, -16504
9D0089B8  8C6260E0   LW V0, 24800(V1)
9D0089BC  24040001   ADDIU A0, ZERO, 1
9D0089C0  7C821084   INS V0, A0, 2, 1
9D0089C4  AC6260E0   SW V0, 24800(V1)
278:                 
279:                 }   // MMBFadeIn
9D0089C8  03C0E821   ADDU SP, S8, ZERO
9D0089CC  8FBF001C   LW RA, 28(SP)
9D0089D0  8FBE0018   LW S8, 24(SP)
9D0089D4  27BD0020   ADDIU SP, SP, 32
9D0089D8  03E00008   JR RA
9D0089DC  00000000   NOP
280:                 
281:                 void MMBFadeOut( int msTime)
282:                 {    // time = total duration of fade-out effect
9D0089E0  27BDFFE0   ADDIU SP, SP, -32
9D0089E4  AFBF001C   SW RA, 28(SP)
9D0089E8  AFBE0018   SW S8, 24(SP)
9D0089EC  03A0F021   ADDU S8, SP, ZERO
9D0089F0  AFC40020   SW A0, 32(S8)
283:                     //  expressed in ms (100ms minimum)
284:                     int w;
285:                     
286:                     if (msTime<100) msTime = 100;
9D0089F4  8FC20020   LW V0, 32(S8)
9D0089F8  28420064   SLTI V0, V0, 100
9D0089FC  10400003   BEQ V0, ZERO, 0x9D008A0C
9D008A00  00000000   NOP
9D008A04  24020064   ADDIU V0, ZERO, 100
9D008A08  AFC20020   SW V0, 32(S8)
287:                     OpenTimer2( T2_ON | T2_PS_1_1, 0 );
9D008A0C  3C02BF80   LUI V0, -16512
9D008A10  AC400800   SW ZERO, 2048(V0)
9D008A14  3C02BF80   LUI V0, -16512
9D008A18  AC400810   SW ZERO, 2064(V0)
9D008A1C  3C02BF80   LUI V0, -16512
9D008A20  AC400820   SW ZERO, 2080(V0)
9D008A24  3C02BF80   LUI V0, -16512
9D008A28  34038000   ORI V1, ZERO, -32768
9D008A2C  AC430808   SW V1, 2056(V0)
288:                     
289:                     // OC3 output is connected to the backlight control
290:                     OpenOC3( OC_ON | OC_PWM_FAULT_PIN_DISABLE | OC_TIMER2_SRC, 0, 0);
9D008A30  3C02BF80   LUI V0, -16512
9D008A34  AC403420   SW ZERO, 13344(V0)
9D008A38  3C02BF80   LUI V0, -16512
9D008A3C  AC403410   SW ZERO, 13328(V0)
9D008A40  3C02BF80   LUI V0, -16512
9D008A44  34038006   ORI V1, ZERO, -32762
9D008A48  AC433400   SW V1, 13312(V0)
291:                     for( w=65535; w>0; w-=65536/100)
9D008A4C  3402FFFF   ORI V0, ZERO, -1
9D008A50  AFC20010   SW V0, 16(S8)
9D008A54  0B4022A7   J 0x9D008A9C
9D008A58  00000000   NOP
9D008A90  8FC20010   LW V0, 16(S8)
9D008A94  2442FD71   ADDIU V0, V0, -655
9D008A98  AFC20010   SW V0, 16(S8)
9D008A9C  8FC20010   LW V0, 16(S8)
9D008AA0  1C40FFEE   BGTZ V0, 0x9D008A5C
9D008AA4  00000000   NOP
292:                     {   // 100 steps
293:                         SetDCOC3PWM( w);
9D008A5C  8FC30010   LW V1, 16(S8)
9D008A60  3C02BF80   LUI V0, -16512
9D008A64  AC433420   SW V1, 13344(V0)
294:                         DelayMs(msTime/100);
9D008A68  8FC30020   LW V1, 32(S8)
9D008A6C  24020064   ADDIU V0, ZERO, 100
9D008A70  0062001A   DIV V1, V0
9D008A74  004001F4   TEQ V0, ZERO
9D008A78  00001810   MFHI V1
9D008A7C  00001012   MFLO V0
9D008A80  3042FFFF   ANDI V0, V0, -1
9D008A84  00402021   ADDU A0, V0, ZERO
9D008A88  0F40095A   JAL DelayMs
9D008A8C  00000000   NOP
295:                     }        
296:                     // Return display BL control to I/O
297:                     CloseOC3();
9D008AA8  3C02BF88   LUI V0, -16504
9D008AAC  24034000   ADDIU V1, ZERO, 16384
9D008AB0  AC431064   SW V1, 4196(V0)
9D008AB4  3C02BF88   LUI V0, -16504
9D008AB8  AC401068   SW ZERO, 4200(V0)
9D008ABC  3C02BF88   LUI V0, -16504
9D008AC0  24034000   ADDIU V1, ZERO, 16384
9D008AC4  AC431034   SW V1, 4148(V0)
9D008AC8  3C02BF80   LUI V0, -16512
9D008ACC  34038000   ORI V1, ZERO, -32768
9D008AD0  AC433404   SW V1, 13316(V0)
298:                     CloseTimer2();
9D008AD4  3C02BF88   LUI V0, -16504
9D008AD8  24030100   ADDIU V1, ZERO, 256
9D008ADC  AC431064   SW V1, 4196(V0)
9D008AE0  3C02BF88   LUI V0, -16504
9D008AE4  AC401068   SW ZERO, 4200(V0)
9D008AE8  3C02BF80   LUI V0, -16512
9D008AEC  AC400800   SW ZERO, 2048(V0)
299:                     // Display Backlight Off
300:                     BacklightOff();
9D008AF0  3C03BF88   LUI V1, -16504
9D008AF4  8C6260E0   LW V0, 24800(V1)
9D008AF8  7C021084   INS V0, ZERO, 2, 1
9D008AFC  AC6260E0   SW V0, 24800(V1)
301:                 }   // MMBFadeOut
9D008B00  03C0E821   ADDU SP, S8, ZERO
9D008B04  8FBF001C   LW RA, 28(SP)
9D008B08  8FBE0018   LW S8, 24(SP)
9D008B0C  27BD0020   ADDIU SP, SP, 32
9D008B10  03E00008   JR RA
9D008B14  00000000   NOP
302:                 
303:                 
304:                 void MMBCenterString( int p, char *s)
305:                 {  // p  integer offset (lines) above or below center
9D008B18  27BDFFD8   ADDIU SP, SP, -40
9D008B1C  AFBF0024   SW RA, 36(SP)
9D008B20  AFBE0020   SW S8, 32(SP)
9D008B24  03A0F021   ADDU S8, SP, ZERO
9D008B28  AFC40028   SW A0, 40(S8)
9D008B2C  AFC5002C   SW A1, 44(S8)
306:                    // s  string
307:                    // requires InitGraph(), SetFont() and SetColor() before use
308:                    // also MMBFadeIn() or BacklightOn() to appear
309:                     int height, x, y;
310:                 
311:                     // get string width & height
312:                     height = GetTextHeight( (void *)_font);
9D008B30  8F8281AC   LW V0, -32340(GP)
9D008B34  00402021   ADDU A0, V0, ZERO
9D008B38  0F40091C   JAL GetTextHeight
9D008B3C  00000000   NOP
9D008B40  AFC20010   SW V0, 16(S8)
313:                     y = GetMaxY()/2 - height/2 + height*p;
9D008B44  8FC20010   LW V0, 16(S8)
9D008B48  00021FC2   SRL V1, V0, 31
9D008B4C  00621021   ADDU V0, V1, V0
9D008B50  00021043   SRA V0, V0, 1
9D008B54  24030077   ADDIU V1, ZERO, 119
9D008B58  00621023   SUBU V0, V1, V0
9D008B5C  8FC40010   LW A0, 16(S8)
9D008B60  8FC30028   LW V1, 40(S8)
9D008B64  70831802   MUL V1, A0, V1
9D008B68  00431021   ADDU V0, V0, V1
9D008B6C  AFC20014   SW V0, 20(S8)
314:                     x = (GetMaxX() - GetTextWidth( (void *)s, (void *)_font))/2;
9D008B70  8F8281AC   LW V0, -32340(GP)
9D008B74  8FC4002C   LW A0, 44(S8)
9D008B78  00402821   ADDU A1, V0, ZERO
9D008B7C  0F4008D2   JAL GetTextWidth
9D008B80  00000000   NOP
9D008B84  2403013F   ADDIU V1, ZERO, 319
9D008B88  00621023   SUBU V0, V1, V0
9D008B8C  00021FC2   SRL V1, V0, 31
9D008B90  00621021   ADDU V0, V1, V0
9D008B94  00021043   SRA V0, V0, 1
9D008B98  AFC20018   SW V0, 24(S8)
315:                     OutTextXY(  x, y, s);
9D008B9C  8FC20018   LW V0, 24(S8)
9D008BA0  7C021620   SEH V0, V0
9D008BA4  00401821   ADDU V1, V0, ZERO
9D008BA8  8FC20014   LW V0, 20(S8)
9D008BAC  7C021620   SEH V0, V0
9D008BB0  00602021   ADDU A0, V1, ZERO
9D008BB4  00402821   ADDU A1, V0, ZERO
9D008BB8  8FC6002C   LW A2, 44(S8)
9D008BBC  0F4007F8   JAL OutTextXY
9D008BC0  00000000   NOP
316:                 } // CenterString
9D008BC4  03C0E821   ADDU SP, S8, ZERO
9D008BC8  8FBF0024   LW RA, 36(SP)
9D008BCC  8FBE0020   LW S8, 32(SP)
9D008BD0  27BD0028   ADDIU SP, SP, 40
9D008BD4  03E00008   JR RA
9D008BD8  00000000   NOP
317:                 
318:                  
---  C:/MC_XProjects/MMB/LCDTerminal.c  -----------------------------------------------------------------
1:                   /******************************************************************************
2:                    *
3:                    *   Terminal Emulation on MikroE PIC32MX4 MMB LCD display 
4:                    *
5:                    *   API compatible with Explorer16 2x16 LCD interface 
6:                    *******************************************************************************/
7:                   //DOM-IGNORE-BEGIN
8:                   /******************************************************************************
9:                   
10:                  * File Name:       LCDterminal.c
11:                  * Dependencies:    None
12:                  * Processor:       PIC32MX4
13:                  * Compiler:        C32 v1.04 or later
14:                  * Company:         Microchip Technology, Inc.
15:                  
16:                  Software License Agreement
17:                  
18:                  The software supplied herewith by Microchip Technology Incorporated
19:                  (the “Company”) for its PICmicro® Microcontroller is intended and
20:                  supplied to you, the Company’s customer, for use solely and
21:                  exclusively on Microchip PICmicro Microcontroller products. The
22:                  software is owned by the Company and/or its supplier, and is
23:                  protected under applicable copyright laws. All rights are reserved.
24:                  Any use in violation of the foregoing restrictions may subject the
25:                  user to criminal sanctions under applicable laws, as well as to
26:                  civil liability for the breach of the terms and conditions of this
27:                  license.
28:                  
29:                  THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES,
30:                  WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                  TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                  PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                  IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                  CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                  
36:                  Author          Date    Comments
37:                  --------------------------------------------------------------------------------
38:                  ADG         14-Apr-2008 First release
39:                  LDJ         18-Aug-2009 Modified for MikroE MMB 
40:                  LDJ         18-Nov-2009 Expanded for Testing MMB v5
41:                  *******************************************************************************/
42:                  
43:                  #include "GenericTypeDefs.h"
44:                  #include "../MMB/LCDTerminal.h"
45:                  
46:                  extern const FONT_FLASH TerminalFont;
47:                  
48:                  
49:                  static char page[ _MAX_Y][ _MAX_X+1];
50:                  static int _cx, _cy;    // cursor position
51:                  
52:                  
53:                  int LCDGetX()
54:                  { 
9D00C5A0  27BDFFF8   ADDIU SP, SP, -8
9D00C5A4  AFBE0004   SW S8, 4(SP)
9D00C5A8  03A0F021   ADDU S8, SP, ZERO
55:                      return _cx;
9D00C5AC  8F828094   LW V0, -32620(GP)
56:                  }
9D00C5B0  03C0E821   ADDU SP, S8, ZERO
9D00C5B4  8FBE0004   LW S8, 4(SP)
9D00C5B8  27BD0008   ADDIU SP, SP, 8
9D00C5BC  03E00008   JR RA
9D00C5C0  00000000   NOP
57:                  
58:                  int LCDGetY()
59:                  { 
9D00C5C4  27BDFFF8   ADDIU SP, SP, -8
9D00C5C8  AFBE0004   SW S8, 4(SP)
9D00C5CC  03A0F021   ADDU S8, SP, ZERO
60:                      return _cy;
9D00C5D0  8F828098   LW V0, -32616(GP)
61:                  }
9D00C5D4  03C0E821   ADDU SP, S8, ZERO
9D00C5D8  8FBE0004   LW S8, 4(SP)
9D00C5DC  27BD0008   ADDIU SP, SP, 8
9D00C5E0  03E00008   JR RA
9D00C5E4  00000000   NOP
62:                  
63:                  
64:                  void LCDHome(void)
65:                  {   // set cursor to home position
9D00C5E8  27BDFFF8   ADDIU SP, SP, -8
9D00C5EC  AFBE0004   SW S8, 4(SP)
9D00C5F0  03A0F021   ADDU S8, SP, ZERO
66:                      _cx = 0; 
9D00C5F4  AF808094   SW ZERO, -32620(GP)
67:                      _cy = 0;
9D00C5F8  AF808098   SW ZERO, -32616(GP)
68:                  }
9D00C5FC  03C0E821   ADDU SP, S8, ZERO
9D00C600  8FBE0004   LW S8, 4(SP)
9D00C604  27BD0008   ADDIU SP, SP, 8
9D00C608  03E00008   JR RA
9D00C60C  00000000   NOP
69:                  
70:                  
71:                  void LCDSetXY( int x, int y)
72:                  {
9D00C610  27BDFFF8   ADDIU SP, SP, -8
9D00C614  AFBE0004   SW S8, 4(SP)
9D00C618  03A0F021   ADDU S8, SP, ZERO
9D00C61C  AFC40008   SW A0, 8(S8)
9D00C620  AFC5000C   SW A1, 12(S8)
73:                      _cx = x; _cy = y;
9D00C624  8FC20008   LW V0, 8(S8)
9D00C628  AF828094   SW V0, -32620(GP)
9D00C62C  8FC2000C   LW V0, 12(S8)
9D00C630  AF828098   SW V0, -32616(GP)
74:                  }
9D00C634  03C0E821   ADDU SP, S8, ZERO
9D00C638  8FBE0004   LW S8, 4(SP)
9D00C63C  27BD0008   ADDIU SP, SP, 8
9D00C640  03E00008   JR RA
9D00C644  00000000   NOP
75:                  
76:                  
77:                  #define LCDL1Home   LCDHome
78:                  
79:                  void LCDL2Home(void)
80:                  {
9D00C648  27BDFFF8   ADDIU SP, SP, -8
9D00C64C  AFBE0004   SW S8, 4(SP)
9D00C650  03A0F021   ADDU S8, SP, ZERO
81:                      _cx = 0;
9D00C654  AF808094   SW ZERO, -32620(GP)
82:                      _cy = 1;
9D00C658  24020001   ADDIU V0, ZERO, 1
9D00C65C  AF828098   SW V0, -32616(GP)
83:                  }
9D00C660  03C0E821   ADDU SP, S8, ZERO
9D00C664  8FBE0004   LW S8, 4(SP)
9D00C668  27BD0008   ADDIU SP, SP, 8
9D00C66C  03E00008   JR RA
9D00C670  00000000   NOP
84:                  
85:                  void LCDLineHome(void)
86:                  {   
9D00C674  27BDFFF8   ADDIU SP, SP, -8
9D00C678  AFBE0004   SW S8, 4(SP)
9D00C67C  03A0F021   ADDU S8, SP, ZERO
87:                      _cx = 0;
9D00C680  AF808094   SW ZERO, -32620(GP)
88:                  }    
9D00C684  03C0E821   ADDU SP, S8, ZERO
9D00C688  8FBE0004   LW S8, 4(SP)
9D00C68C  27BD0008   ADDIU SP, SP, 8
9D00C690  03E00008   JR RA
9D00C694  00000000   NOP
89:                  
90:                  void LCDClearToEOL( void)
91:                  {
9D00C698  27BDFFE0   ADDIU SP, SP, -32
9D00C69C  AFBF001C   SW RA, 28(SP)
9D00C6A0  AFBE0018   SW S8, 24(SP)
9D00C6A4  03A0F021   ADDU S8, SP, ZERO
92:                      int t = _cx;
9D00C6A8  8F828094   LW V0, -32620(GP)
9D00C6AC  AFC20014   SW V0, 20(S8)
93:                      int i;
94:                      
95:                      // fill with spaces until the end of the line
96:                      for( i=_cx; i< _MAX_X; i++)
9D00C6B0  8F828094   LW V0, -32620(GP)
9D00C6B4  AFC20010   SW V0, 16(S8)
9D00C6B8  0B4031B6   J 0x9D00C6D8
9D00C6BC  00000000   NOP
9D00C6CC  8FC20010   LW V0, 16(S8)
9D00C6D0  24420001   ADDIU V0, V0, 1
9D00C6D4  AFC20010   SW V0, 16(S8)
9D00C6D8  8FC20010   LW V0, 16(S8)
9D00C6DC  2842001A   SLTI V0, V0, 26
9D00C6E0  1440FFF7   BNE V0, ZERO, 0x9D00C6C0
9D00C6E4  00000000   NOP
97:                          LCDPutChar( ' ');   
9D00C6C0  24040020   ADDIU A0, ZERO, 32
9D00C6C4  0F4032BF   JAL LCDPutChar
9D00C6C8  00000000   NOP
98:                          
99:                      // return to position
100:                     _cx = t;    
9D00C6E8  8FC20014   LW V0, 20(S8)
9D00C6EC  AF828094   SW V0, -32620(GP)
101:                 }
9D00C6F0  03C0E821   ADDU SP, S8, ZERO
9D00C6F4  8FBF001C   LW RA, 28(SP)
9D00C6F8  8FBE0018   LW S8, 24(SP)
9D00C6FC  27BD0020   ADDIU SP, SP, 32
9D00C700  03E00008   JR RA
9D00C704  00000000   NOP
102:                 void LCDClearLine(int Line)
103:                 {
9D00C708  27BDFFD8   ADDIU SP, SP, -40
9D00C70C  AFBF0024   SW RA, 36(SP)
9D00C710  AFBE0020   SW S8, 32(SP)
9D00C714  03A0F021   ADDU S8, SP, ZERO
9D00C718  AFC40028   SW A0, 40(S8)
104:                     int x, y,l;
105:                     _cx = 1;
9D00C71C  24020001   ADDIU V0, ZERO, 1
9D00C720  AF828094   SW V0, -32620(GP)
106:                     _cy = Line;
9D00C724  8FC20028   LW V0, 40(S8)
9D00C728  AF828098   SW V0, -32616(GP)
107:                     l = _cy;
9D00C72C  8F828098   LW V0, -32616(GP)
9D00C730  AFC20014   SW V0, 20(S8)
108:                     y = _MAX_X;
9D00C734  2402001A   ADDIU V0, ZERO, 26
9D00C738  AFC20018   SW V0, 24(S8)
109:                     for( x = 1; x < _MAX_X; x++)
9D00C73C  24020001   ADDIU V0, ZERO, 1
9D00C740  AFC20010   SW V0, 16(S8)
9D00C744  0B4031D9   J 0x9D00C764
9D00C748  00000000   NOP
9D00C758  8FC20010   LW V0, 16(S8)
9D00C75C  24420001   ADDIU V0, V0, 1
9D00C760  AFC20010   SW V0, 16(S8)
9D00C764  8FC20010   LW V0, 16(S8)
9D00C768  2842001A   SLTI V0, V0, 26
9D00C76C  1440FFF7   BNE V0, ZERO, 0x9D00C74C
9D00C770  00000000   NOP
110:                     {     
111:                         LCDPutChar(' ');
9D00C74C  24040020   ADDIU A0, ZERO, 32
9D00C750  0F4032BF   JAL LCDPutChar
9D00C754  00000000   NOP
112:                     }
113:                 }
9D00C774  03C0E821   ADDU SP, S8, ZERO
9D00C778  8FBF0024   LW RA, 36(SP)
9D00C77C  8FBE0020   LW S8, 32(SP)
9D00C780  27BD0028   ADDIU SP, SP, 40
9D00C784  03E00008   JR RA
9D00C788  00000000   NOP
114:                 void LCDClear(void)
115:                 {
9D00C78C  27BDFFE0   ADDIU SP, SP, -32
9D00C790  AFBF001C   SW RA, 28(SP)
9D00C794  AFBE0018   SW S8, 24(SP)
9D00C798  03A0F021   ADDU S8, SP, ZERO
116:                     int i,j;
117:                     for (i=0; i< _MAX_X; i++)
9D00C79C  AFC00010   SW ZERO, 16(S8)
9D00C7A0  0B403201   J 0x9D00C804
9D00C7A4  00000000   NOP
9D00C7F8  8FC20010   LW V0, 16(S8)
9D00C7FC  24420001   ADDIU V0, V0, 1
9D00C800  AFC20010   SW V0, 16(S8)
9D00C804  8FC20010   LW V0, 16(S8)
9D00C808  2842001A   SLTI V0, V0, 26
9D00C80C  1440FFE6   BNE V0, ZERO, 0x9D00C7A8
9D00C810  00000000   NOP
118:                         for( j=0; j<_MAX_Y; j++)
9D00C7A8  AFC00014   SW ZERO, 20(S8)
9D00C7AC  0B4031FA   J 0x9D00C7E8
9D00C7B0  00000000   NOP
9D00C7DC  8FC20014   LW V0, 20(S8)
9D00C7E0  24420001   ADDIU V0, V0, 1
9D00C7E4  AFC20014   SW V0, 20(S8)
9D00C7E8  8FC20014   LW V0, 20(S8)
9D00C7EC  2842000B   SLTI V0, V0, 11
9D00C7F0  1440FFF0   BNE V0, ZERO, 0x9D00C7B4
9D00C7F4  00000000   NOP
119:                             page[j][i] = ' ';
9D00C7B4  3C02A000   LUI V0, -24576
9D00C7B8  8FC40014   LW A0, 20(S8)
9D00C7BC  2403001B   ADDIU V1, ZERO, 27
9D00C7C0  70832002   MUL A0, A0, V1
9D00C7C4  8FC30010   LW V1, 16(S8)
9D00C7C8  00831821   ADDU V1, A0, V1
9D00C7CC  24420D74   ADDIU V0, V0, 3444
9D00C7D0  00621021   ADDU V0, V1, V0
9D00C7D4  24030020   ADDIU V1, ZERO, 32
9D00C7D8  A0430000   SB V1, 0(V0)
120:                             
121:                     SetColor( LCD_BACK); 
9D00C814  A7808198   SH ZERO, -32360(GP)
122:                     ClearDevice();
9D00C818  0F400CE5   JAL ClearDevice
9D00C81C  00000000   NOP
123:                     SetColor( LCD_FORE); 
9D00C820  2402FFFF   ADDIU V0, ZERO, -1
9D00C824  A7828198   SH V0, -32360(GP)
124:                     LCDHome();
9D00C828  0F40317A   JAL LCDHome
9D00C82C  00000000   NOP
125:                 }
9D00C830  03C0E821   ADDU SP, S8, ZERO
9D00C834  8FBF001C   LW RA, 28(SP)
9D00C838  8FBE0018   LW S8, 24(SP)
9D00C83C  27BD0020   ADDIU SP, SP, 32
9D00C840  03E00008   JR RA
9D00C844  00000000   NOP
126:                 
127:                 void LCDInit(void)
128:                 {
9D00C848  27BDFFE8   ADDIU SP, SP, -24
9D00C84C  AFBF0014   SW RA, 20(SP)
9D00C850  AFBE0010   SW S8, 16(SP)
9D00C854  03A0F021   ADDU S8, SP, ZERO
129:                     InitGraph();    // initialize graphics library
9D00C858  0F40001C   JAL InitGraph
9D00C85C  00000000   NOP
130:                     LCDClear();
9D00C860  0F4031E3   JAL LCDClear
9D00C864  00000000   NOP
131:                     SetFont( (void *)&TerminalFont);          // set font
9D00C868  3C029D00   LUI V0, -25344
9D00C86C  24446F8C   ADDIU A0, V0, 28556
9D00C870  0F4007B8   JAL SetFont
9D00C874  00000000   NOP
132:                 }
9D00C878  03C0E821   ADDU SP, S8, ZERO
9D00C87C  8FBF0014   LW RA, 20(SP)
9D00C880  8FBE0010   LW S8, 16(SP)
9D00C884  27BD0018   ADDIU SP, SP, 24
9D00C888  03E00008   JR RA
9D00C88C  00000000   NOP
133:                 
134:                 
135:                 void LCDShiftCursorLeft(void)
136:                 {
9D00C890  27BDFFF8   ADDIU SP, SP, -8
9D00C894  AFBE0004   SW S8, 4(SP)
9D00C898  03A0F021   ADDU S8, SP, ZERO
137:                     if (_cx>0) 
9D00C89C  8F828094   LW V0, -32620(GP)
9D00C8A0  18400004   BLEZ V0, 0x9D00C8B4
9D00C8A4  00000000   NOP
138:                         _cx--;
9D00C8A8  8F828094   LW V0, -32620(GP)
9D00C8AC  2442FFFF   ADDIU V0, V0, -1
9D00C8B0  AF828094   SW V0, -32620(GP)
139:                 }
9D00C8B4  03C0E821   ADDU SP, S8, ZERO
9D00C8B8  8FBE0004   LW S8, 4(SP)
9D00C8BC  27BD0008   ADDIU SP, SP, 8
9D00C8C0  03E00008   JR RA
9D00C8C4  00000000   NOP
140:                 
141:                 
142:                 void LCDShiftCursorUp(void)
143:                 {
9D00C8C8  27BDFFF8   ADDIU SP, SP, -8
9D00C8CC  AFBE0004   SW S8, 4(SP)
9D00C8D0  03A0F021   ADDU S8, SP, ZERO
144:                    if ( _cy>0) _cy--;
9D00C8D4  8F828098   LW V0, -32616(GP)
9D00C8D8  18400004   BLEZ V0, 0x9D00C8EC
9D00C8DC  00000000   NOP
9D00C8E0  8F828098   LW V0, -32616(GP)
9D00C8E4  2442FFFF   ADDIU V0, V0, -1
9D00C8E8  AF828098   SW V0, -32616(GP)
145:                 }
9D00C8EC  03C0E821   ADDU SP, S8, ZERO
9D00C8F0  8FBE0004   LW S8, 4(SP)
9D00C8F4  27BD0008   ADDIU SP, SP, 8
9D00C8F8  03E00008   JR RA
9D00C8FC  00000000   NOP
146:                 
147:                 void LCDShiftCursorDown(void)
148:                 {
9D00C900  27BDFFE0   ADDIU SP, SP, -32
9D00C904  AFBF001C   SW RA, 28(SP)
9D00C908  AFBE0018   SW S8, 24(SP)
9D00C90C  03A0F021   ADDU S8, SP, ZERO
149:                     int i,j;
150:                         _cy++;
9D00C910  8F828098   LW V0, -32616(GP)
9D00C914  24420001   ADDIU V0, V0, 1
9D00C918  AF828098   SW V0, -32616(GP)
151:                 #ifdef  LCD_SCROLL
152:                     if ( _cy >= _MAX_Y) 
9D00C91C  8F828098   LW V0, -32616(GP)
9D00C920  2842000B   SLTI V0, V0, 11
9D00C924  1440005B   BNE V0, ZERO, 0x9D00CA94
9D00C928  00000000   NOP
153:                     {   // scroll entire screen up
154:                         for( j=0; j<_MAX_Y-1; j++)
9D00C92C  AFC00014   SW ZERO, 20(S8)
9D00C930  0B40329F   J 0x9D00CA7C
9D00C934  00000000   NOP
9D00CA70  8FC20014   LW V0, 20(S8)
9D00CA74  24420001   ADDIU V0, V0, 1
9D00CA78  AFC20014   SW V0, 20(S8)
9D00CA7C  8FC20014   LW V0, 20(S8)
9D00CA80  2842000A   SLTI V0, V0, 10
9D00CA84  1440FFAC   BNE V0, ZERO, 0x9D00C938
9D00CA88  00000000   NOP
155:                         {   // for each line
156:                             // clear the line background (indipendent from LCD_OVERLAY)    
157:                             SetColor( LCD_BACK); 
9D00C938  A7808198   SH ZERO, -32360(GP)
158:                             Bar( 0, FONT_H*j, GetMaxX()-1, FONT_H*(j+1));
9D00C93C  8FC20014   LW V0, 20(S8)
9D00C940  3043FFFF   ANDI V1, V0, -1
9D00C944  24020014   ADDIU V0, ZERO, 20
9D00C948  70621002   MUL V0, V1, V0
9D00C94C  3042FFFF   ANDI V0, V0, -1
9D00C950  7C021620   SEH V0, V0
9D00C954  00401821   ADDU V1, V0, ZERO
9D00C958  8FC20014   LW V0, 20(S8)
9D00C95C  24420001   ADDIU V0, V0, 1
9D00C960  3044FFFF   ANDI A0, V0, -1
9D00C964  24020014   ADDIU V0, ZERO, 20
9D00C968  70821002   MUL V0, A0, V0
9D00C96C  3042FFFF   ANDI V0, V0, -1
9D00C970  7C021620   SEH V0, V0
9D00C974  00002021   ADDU A0, ZERO, ZERO
9D00C978  00602821   ADDU A1, V1, ZERO
9D00C97C  2406013E   ADDIU A2, ZERO, 318
9D00C980  00403821   ADDU A3, V0, ZERO
9D00C984  0F400C02   JAL Bar
9D00C988  00000000   NOP
159:                             SetColor( LCD_FORE); 
9D00C98C  2402FFFF   ADDIU V0, ZERO, -1
9D00C990  A7828198   SH V0, -32360(GP)
160:                             // copy from next line print the new line content
161:                             for( i=0;i<_MAX_X; i++)
9D00C994  AFC00010   SW ZERO, 16(S8)
9D00C998  0B403298   J 0x9D00CA60
9D00C99C  00000000   NOP
9D00CA54  8FC20010   LW V0, 16(S8)
9D00CA58  24420001   ADDIU V0, V0, 1
9D00CA5C  AFC20010   SW V0, 16(S8)
9D00CA60  8FC20010   LW V0, 16(S8)
9D00CA64  2842001A   SLTI V0, V0, 26
9D00CA68  1440FFCD   BNE V0, ZERO, 0x9D00C9A0
9D00CA6C  00000000   NOP
162:                             {
163:                                 page[j][i] = page[j+1][i];    
9D00C9A0  8FC20014   LW V0, 20(S8)
9D00C9A4  24440001   ADDIU A0, V0, 1
9D00C9A8  3C02A000   LUI V0, -24576
9D00C9AC  2403001B   ADDIU V1, ZERO, 27
9D00C9B0  70832002   MUL A0, A0, V1
9D00C9B4  8FC30010   LW V1, 16(S8)
9D00C9B8  00831821   ADDU V1, A0, V1
9D00C9BC  24420D74   ADDIU V0, V0, 3444
9D00C9C0  00621021   ADDU V0, V1, V0
9D00C9C4  80430000   LB V1, 0(V0)
9D00C9C8  3C02A000   LUI V0, -24576
9D00C9CC  8FC50014   LW A1, 20(S8)
9D00C9D0  2404001B   ADDIU A0, ZERO, 27
9D00C9D4  70A42802   MUL A1, A1, A0
9D00C9D8  8FC40010   LW A0, 16(S8)
9D00C9DC  00A42021   ADDU A0, A1, A0
9D00C9E0  24420D74   ADDIU V0, V0, 3444
9D00C9E4  00821021   ADDU V0, A0, V0
9D00C9E8  A0430000   SB V1, 0(V0)
164:                                 MoveTo( FONT_W*i, FONT_H*j); OutChar( page[j][i]);
9D00C9EC  8FC20010   LW V0, 16(S8)
9D00C9F0  3043FFFF   ANDI V1, V0, -1
9D00C9F4  2402000C   ADDIU V0, ZERO, 12
9D00C9F8  70621002   MUL V0, V1, V0
9D00C9FC  3042FFFF   ANDI V0, V0, -1
9D00CA00  7C021620   SEH V0, V0
9D00CA04  A78281B0   SH V0, -32336(GP)
9D00CA08  8FC20014   LW V0, 20(S8)
9D00CA0C  3043FFFF   ANDI V1, V0, -1
9D00CA10  24020014   ADDIU V0, ZERO, 20
9D00CA14  70621002   MUL V0, V1, V0
9D00CA18  3042FFFF   ANDI V0, V0, -1
9D00CA1C  7C021620   SEH V0, V0
9D00CA20  A78281A6   SH V0, -32346(GP)
9D00CA24  3C02A000   LUI V0, -24576
9D00CA28  8FC40014   LW A0, 20(S8)
9D00CA2C  2403001B   ADDIU V1, ZERO, 27
9D00CA30  70832002   MUL A0, A0, V1
9D00CA34  8FC30010   LW V1, 16(S8)
9D00CA38  00831821   ADDU V1, A0, V1
9D00CA3C  24420D74   ADDIU V0, V0, 3444
9D00CA40  00621021   ADDU V0, V1, V0
9D00CA44  80420000   LB V0, 0(V0)
9D00CA48  00402021   ADDU A0, V0, ZERO
9D00CA4C  0F40080F   JAL OutChar
9D00CA50  00000000   NOP
165:                             }    
166:                         }   
167:                         _cy = _MAX_Y-1; 
9D00CA8C  2402000A   ADDIU V0, ZERO, 10
9D00CA90  AF828098   SW V0, -32616(GP)
168:                     }
169:                 #else   // no scrolling option roll
170:                     if ( _cy >= _MAX_Y) 
171:                     {
172:                         _cy = 0;
173:                     }    
174:                 
175:                 #endif        
176:                 }
9D00CA94  03C0E821   ADDU SP, S8, ZERO
9D00CA98  8FBF001C   LW RA, 28(SP)
9D00CA9C  8FBE0018   LW S8, 24(SP)
9D00CAA0  27BD0020   ADDIU SP, SP, 32
9D00CAA4  03E00008   JR RA
9D00CAA8  00000000   NOP
177:                 
178:                 void LCDShiftCursorRight(void)
179:                 {
9D00CAAC  27BDFFE8   ADDIU SP, SP, -24
9D00CAB0  AFBF0014   SW RA, 20(SP)
9D00CAB4  AFBE0010   SW S8, 16(SP)
9D00CAB8  03A0F021   ADDU S8, SP, ZERO
180:                     _cx++;
9D00CABC  8F828094   LW V0, -32620(GP)
9D00CAC0  24420001   ADDIU V0, V0, 1
9D00CAC4  AF828094   SW V0, -32620(GP)
181:                 #ifdef LCD_WRAP
182:                     if ( _cx >= _MAX_X) 
9D00CAC8  8F828094   LW V0, -32620(GP)
9D00CACC  2842001A   SLTI V0, V0, 26
9D00CAD0  14400004   BNE V0, ZERO, 0x9D00CAE4
9D00CAD4  00000000   NOP
183:                     {   // wrap to a new line
184:                         _cx = 0;    
9D00CAD8  AF808094   SW ZERO, -32620(GP)
185:                         LCDShiftCursorDown();
9D00CADC  0F403240   JAL LCDShiftCursorDown
9D00CAE0  00000000   NOP
186:                     }    
187:                 #endif
188:                 }
9D00CAE4  03C0E821   ADDU SP, S8, ZERO
9D00CAE8  8FBF0014   LW RA, 20(SP)
9D00CAEC  8FBE0010   LW S8, 16(SP)
9D00CAF0  27BD0018   ADDIU SP, SP, 24
9D00CAF4  03E00008   JR RA
9D00CAF8  00000000   NOP
189:                 
190:                 void LCDPutChar(char A)
191:                 {
9D00CAFC  27BDFFE8   ADDIU SP, SP, -24
9D00CB00  AFBF0014   SW RA, 20(SP)
9D00CB04  AFBE0010   SW S8, 16(SP)
9D00CB08  03A0F021   ADDU S8, SP, ZERO
9D00CB0C  00801021   ADDU V0, A0, ZERO
9D00CB10  A3C20018   SB V0, 24(S8)
192:                         
193:                 #ifndef LCD_OVERLAY
194:                     // clear the background
195:                     SetColor( LCD_BACK); 
9D00CB14  A7808198   SH ZERO, -32360(GP)
196:                     Bar( _cx*FONT_W, _cy*FONT_H, (_cx+1)*FONT_W, (_cy+1)*FONT_H);
9D00CB18  8F828094   LW V0, -32620(GP)
9D00CB1C  3043FFFF   ANDI V1, V0, -1
9D00CB20  2402000C   ADDIU V0, ZERO, 12
9D00CB24  70621002   MUL V0, V1, V0
9D00CB28  3042FFFF   ANDI V0, V0, -1
9D00CB2C  7C021620   SEH V0, V0
9D00CB30  00402021   ADDU A0, V0, ZERO
9D00CB34  8F828098   LW V0, -32616(GP)
9D00CB38  3043FFFF   ANDI V1, V0, -1
9D00CB3C  24020014   ADDIU V0, ZERO, 20
9D00CB40  70621002   MUL V0, V1, V0
9D00CB44  3042FFFF   ANDI V0, V0, -1
9D00CB48  7C021620   SEH V0, V0
9D00CB4C  00402821   ADDU A1, V0, ZERO
9D00CB50  8F828094   LW V0, -32620(GP)
9D00CB54  24420001   ADDIU V0, V0, 1
9D00CB58  3043FFFF   ANDI V1, V0, -1
9D00CB5C  2402000C   ADDIU V0, ZERO, 12
9D00CB60  70621002   MUL V0, V1, V0
9D00CB64  3042FFFF   ANDI V0, V0, -1
9D00CB68  7C021620   SEH V0, V0
9D00CB6C  00401821   ADDU V1, V0, ZERO
9D00CB70  8F828098   LW V0, -32616(GP)
9D00CB74  24420001   ADDIU V0, V0, 1
9D00CB78  3046FFFF   ANDI A2, V0, -1
9D00CB7C  24020014   ADDIU V0, ZERO, 20
9D00CB80  70C21002   MUL V0, A2, V0
9D00CB84  3042FFFF   ANDI V0, V0, -1
9D00CB88  7C021620   SEH V0, V0
9D00CB8C  00603021   ADDU A2, V1, ZERO
9D00CB90  00403821   ADDU A3, V0, ZERO
9D00CB94  0F400C02   JAL Bar
9D00CB98  00000000   NOP
197:                     SetColor( LCD_FORE); 
9D00CB9C  2402FFFF   ADDIU V0, ZERO, -1
9D00CBA0  A7828198   SH V0, -32360(GP)
198:                 #endif
199:                 
200:                     if(( _cx<_MAX_X) && (_cy<_MAX_Y))   // clip
9D00CBA4  8F828094   LW V0, -32620(GP)
9D00CBA8  2842001A   SLTI V0, V0, 26
9D00CBAC  10400023   BEQ V0, ZERO, 0x9D00CC3C
9D00CBB0  00000000   NOP
9D00CBB4  8F828098   LW V0, -32616(GP)
9D00CBB8  2842000B   SLTI V0, V0, 11
9D00CBBC  1040001F   BEQ V0, ZERO, 0x9D00CC3C
9D00CBC0  00000000   NOP
201:                     { // print the new character
202:                         MoveTo( FONT_W * _cx, FONT_H*_cy);
9D00CBC4  8F828094   LW V0, -32620(GP)
9D00CBC8  3043FFFF   ANDI V1, V0, -1
9D00CBCC  2402000C   ADDIU V0, ZERO, 12
9D00CBD0  70621002   MUL V0, V1, V0
9D00CBD4  3042FFFF   ANDI V0, V0, -1
9D00CBD8  7C021620   SEH V0, V0
9D00CBDC  A78281B0   SH V0, -32336(GP)
9D00CBE0  8F828098   LW V0, -32616(GP)
9D00CBE4  3043FFFF   ANDI V1, V0, -1
9D00CBE8  24020014   ADDIU V0, ZERO, 20
9D00CBEC  70621002   MUL V0, V1, V0
9D00CBF0  3042FFFF   ANDI V0, V0, -1
9D00CBF4  7C021620   SEH V0, V0
9D00CBF8  A78281A6   SH V0, -32346(GP)
203:                         OutChar( A);
9D00CBFC  83C20018   LB V0, 24(S8)
9D00CC00  00402021   ADDU A0, V0, ZERO
9D00CC04  0F40080F   JAL OutChar
9D00CC08  00000000   NOP
204:                         page[ _cy][ _cx] = A;
9D00CC0C  8F858098   LW A1, -32616(GP)
9D00CC10  8F838094   LW V1, -32620(GP)
9D00CC14  3C02A000   LUI V0, -24576
9D00CC18  2404001B   ADDIU A0, ZERO, 27
9D00CC1C  70A42002   MUL A0, A1, A0
9D00CC20  00831821   ADDU V1, A0, V1
9D00CC24  24420D74   ADDIU V0, V0, 3444
9D00CC28  00621021   ADDU V0, V1, V0
9D00CC2C  93C30018   LBU V1, 24(S8)
9D00CC30  A0430000   SB V1, 0(V0)
205:                         LCDShiftCursorRight();
9D00CC34  0F4032AB   JAL LCDShiftCursorRight
9D00CC38  00000000   NOP
206:                     }
207:                 } // LCDPutChar
9D00CC3C  03C0E821   ADDU SP, S8, ZERO
9D00CC40  8FBF0014   LW RA, 20(SP)
9D00CC44  8FBE0010   LW S8, 16(SP)
9D00CC48  27BD0018   ADDIU SP, SP, 24
9D00CC4C  03E00008   JR RA
9D00CC50  00000000   NOP
208:                 
209:                 
210:                 void LCDPut(char A)
211:                 {
9D00CC54  27BDFFE0   ADDIU SP, SP, -32
9D00CC58  AFBF001C   SW RA, 28(SP)
9D00CC5C  AFBE0018   SW S8, 24(SP)
9D00CC60  03A0F021   ADDU S8, SP, ZERO
9D00CC64  00801021   ADDU V0, A0, ZERO
9D00CC68  A3C20020   SB V0, 32(S8)
212:                     int tab, i;
213:                     
214:                     switch( A)
9D00CC6C  83C20020   LB V0, 32(S8)
9D00CC70  2C43000E   SLTIU V1, V0, 14
9D00CC74  10600044   BEQ V1, ZERO, 0x9D00CD88
9D00CC78  00000000   NOP
9D00CC7C  00021880   SLL V1, V0, 2
9D00CC80  3C029D01   LUI V0, -25343
9D00CC84  2442CC98   ADDIU V0, V0, -13160
9D00CC88  00621021   ADDU V0, V1, V0
9D00CC8C  8C420000   LW V0, 0(V0)
9D00CC90  00400008   JR V0
9D00CC94  00000000   NOP
215:                     {
216:                         case '\b':    // backstep
217:                             if ( _cx>0)
9D00CCD0  8F828094   LW V0, -32620(GP)
9D00CCD4  18400033   BLEZ V0, 0x9D00CDA4
9D00CCD8  00000000   NOP
218:                                 _cx--;
9D00CCDC  8F828094   LW V0, -32620(GP)
9D00CCE0  2442FFFF   ADDIU V0, V0, -1
9D00CCE4  AF828094   SW V0, -32620(GP)
219:                             break;
9D00CCE8  0B40336A   J 0x9D00CDA8
9D00CCEC  00000000   NOP
9D00CDA4  00000000   NOP
220:                         case 0x0C:
221:                             LCDClear();
9D00CCF0  0F4031E3   JAL LCDClear
9D00CCF4  00000000   NOP
222:                             break;
9D00CCF8  0B40336A   J 0x9D00CDA8
9D00CCFC  00000000   NOP
223:                         case 0x01:
224:                             _cx = 0;
9D00CD00  AF808094   SW ZERO, -32620(GP)
225:                             _cy = 0;
9D00CD04  AF808098   SW ZERO, -32616(GP)
226:                             break;
9D00CD08  0B40336A   J 0x9D00CDA8
9D00CD0C  00000000   NOP
227:                         case '\t':    // move to next tab position
228:                             tab = (_cx/8 + 1) * 8;
9D00CD10  8F828094   LW V0, -32620(GP)
9D00CD14  24430007   ADDIU V1, V0, 7
9D00CD18  28440000   SLTI A0, V0, 0
9D00CD1C  0064100B   MOVN V0, V1, A0
9D00CD20  000210C3   SRA V0, V0, 3
9D00CD24  24420001   ADDIU V0, V0, 1
9D00CD28  000210C0   SLL V0, V0, 3
9D00CD2C  AFC20014   SW V0, 20(S8)
229:                             // add spaces until the next tab stop
230:                             for( i=_cx; i<tab; i++)
9D00CD30  8F828094   LW V0, -32620(GP)
9D00CD34  AFC20010   SW V0, 16(S8)
9D00CD38  0B403356   J 0x9D00CD58
9D00CD3C  00000000   NOP
9D00CD4C  8FC20010   LW V0, 16(S8)
9D00CD50  24420001   ADDIU V0, V0, 1
9D00CD54  AFC20010   SW V0, 16(S8)
9D00CD58  8FC30010   LW V1, 16(S8)
9D00CD5C  8FC20014   LW V0, 20(S8)
9D00CD60  0062102A   SLT V0, V1, V0
9D00CD64  1440FFF6   BNE V0, ZERO, 0x9D00CD40
9D00CD68  00000000   NOP
231:                                 LCDPutChar(' ');
9D00CD40  24040020   ADDIU A0, ZERO, 32
9D00CD44  0F4032BF   JAL LCDPutChar
9D00CD48  00000000   NOP
232:                             break;
9D00CD6C  0B40336A   J 0x9D00CDA8
9D00CD70  00000000   NOP
233:                 
234:                         case '\n':    // New Line
235:                             LCDShiftCursorDown();
9D00CD74  0F403240   JAL LCDShiftCursorDown
9D00CD78  00000000   NOP
236:                             // break;   // continue into Home
237:                         
238:                         case '\r':    // Home
239:                             _cx = 0;
9D00CD7C  AF808094   SW ZERO, -32620(GP)
240:                             break;
9D00CD80  0B40336A   J 0x9D00CDA8
9D00CD84  00000000   NOP
241:                 
242:                         default:      // print-able char
243:                             LCDPutChar( A);
9D00CD88  83C20020   LB V0, 32(S8)
9D00CD8C  00402021   ADDU A0, V0, ZERO
9D00CD90  0F4032BF   JAL LCDPutChar
9D00CD94  00000000   NOP
244:                             break;
9D00CD98  00000000   NOP
9D00CD9C  0B40336A   J 0x9D00CDA8
9D00CDA0  00000000   NOP
245:                     } // switch
246:                     
247:                 } // LCDPut
9D00CDA8  03C0E821   ADDU SP, S8, ZERO
9D00CDAC  8FBF001C   LW RA, 28(SP)
9D00CDB0  8FBE0018   LW S8, 24(SP)
9D00CDB4  27BD0020   ADDIU SP, SP, 32
9D00CDB8  03E00008   JR RA
9D00CDBC  00000000   NOP
248:                 
249:                 
250:                 void LCDPutString( char* s)
251:                 {
9D00CDC0  27BDFFE0   ADDIU SP, SP, -32
9D00CDC4  AFBF001C   SW RA, 28(SP)
9D00CDC8  AFBE0018   SW S8, 24(SP)
9D00CDCC  03A0F021   ADDU S8, SP, ZERO
9D00CDD0  AFC40020   SW A0, 32(S8)
252:                     char c;
253:                     while( c = *s++)
9D00CDD4  0B40337B   J 0x9D00CDEC
9D00CDD8  00000000   NOP
9D00CDEC  8FC20020   LW V0, 32(S8)
9D00CDF0  90420000   LBU V0, 0(V0)
9D00CDF4  A3C20010   SB V0, 16(S8)
9D00CDF8  83C20010   LB V0, 16(S8)
9D00CDFC  0002102B   SLTU V0, ZERO, V0
9D00CE00  304200FF   ANDI V0, V0, 255
9D00CE04  8FC30020   LW V1, 32(S8)
9D00CE08  24630001   ADDIU V1, V1, 1
9D00CE0C  AFC30020   SW V1, 32(S8)
9D00CE10  1440FFF2   BNE V0, ZERO, 0x9D00CDDC
9D00CE14  00000000   NOP
254:                         LCDPut( c);
9D00CDDC  83C20010   LB V0, 16(S8)
9D00CDE0  00402021   ADDU A0, V0, ZERO
9D00CDE4  0F403315   JAL LCDPut
9D00CDE8  00000000   NOP
255:                 }
9D00CE18  03C0E821   ADDU SP, S8, ZERO
9D00CE1C  8FBF001C   LW RA, 28(SP)
9D00CE20  8FBE0018   LW S8, 24(SP)
9D00CE24  27BD0020   ADDIU SP, SP, 32
9D00CE28  03E00008   JR RA
9D00CE2C  00000000   NOP
256:                 
257:                 
258:                 void LCDCenterString( int p, char *s)
259:                 { 
9D00CE30  27BDFFD8   ADDIU SP, SP, -40
9D00CE34  AFBF0024   SW RA, 36(SP)
9D00CE38  AFBE0020   SW S8, 32(SP)
9D00CE3C  03A0F021   ADDU S8, SP, ZERO
9D00CE40  AFC40028   SW A0, 40(S8)
9D00CE44  AFC5002C   SW A1, 44(S8)
260:                     int height, x, y;
261:                 
262:                     // get string width & height
263:                     height = GetTextHeight( (void *)&TerminalFont);
9D00CE48  3C029D00   LUI V0, -25344
9D00CE4C  24446F8C   ADDIU A0, V0, 28556
9D00CE50  0F40091C   JAL GetTextHeight
9D00CE54  00000000   NOP
9D00CE58  AFC20010   SW V0, 16(S8)
264:                     y = GetMaxY()/2 - height/2 + height*p;
9D00CE5C  8FC20010   LW V0, 16(S8)
9D00CE60  00021FC2   SRL V1, V0, 31
9D00CE64  00621021   ADDU V0, V1, V0
9D00CE68  00021043   SRA V0, V0, 1
9D00CE6C  24030077   ADDIU V1, ZERO, 119
9D00CE70  00621023   SUBU V0, V1, V0
9D00CE74  8FC40010   LW A0, 16(S8)
9D00CE78  8FC30028   LW V1, 40(S8)
9D00CE7C  70831802   MUL V1, A0, V1
9D00CE80  00431021   ADDU V0, V0, V1
9D00CE84  AFC20014   SW V0, 20(S8)
265:                     x = (GetMaxX() - GetTextWidth( (void *)s, (void *)&TerminalFont))/2;
9D00CE88  8FC4002C   LW A0, 44(S8)
9D00CE8C  3C029D00   LUI V0, -25344
9D00CE90  24456F8C   ADDIU A1, V0, 28556
9D00CE94  0F4008D2   JAL GetTextWidth
9D00CE98  00000000   NOP
9D00CE9C  2403013F   ADDIU V1, ZERO, 319
9D00CEA0  00621023   SUBU V0, V1, V0
9D00CEA4  00021FC2   SRL V1, V0, 31
9D00CEA8  00621021   ADDU V0, V1, V0
9D00CEAC  00021043   SRA V0, V0, 1
9D00CEB0  AFC20018   SW V0, 24(S8)
266:                     OutTextXY(  x, y, s);
9D00CEB4  8FC20018   LW V0, 24(S8)
9D00CEB8  7C021620   SEH V0, V0
9D00CEBC  00401821   ADDU V1, V0, ZERO
9D00CEC0  8FC20014   LW V0, 20(S8)
9D00CEC4  7C021620   SEH V0, V0
9D00CEC8  00602021   ADDU A0, V1, ZERO
9D00CECC  00402821   ADDU A1, V0, ZERO
9D00CED0  8FC6002C   LW A2, 44(S8)
9D00CED4  0F4007F8   JAL OutTextXY
9D00CED8  00000000   NOP
267:                 } // CenterString
9D00CEDC  03C0E821   ADDU SP, S8, ZERO
9D00CEE0  8FBF0024   LW RA, 36(SP)
9D00CEE4  8FBE0020   LW S8, 32(SP)
9D00CEE8  27BD0028   ADDIU SP, SP, 40
9D00CEEC  03E00008   JR RA
9D00CEF0  00000000   NOP
268:                 
---  C:/MC_XProjects/LIBS/WIFI_LIB/WIFI_SOURCE/wifi.c  --------------------------------------------------
1:                   /*  ***************************************************************************
2:                      CREATED BY: 	Stillbright Managment LLC
3:                   *					Copyright 2012
4:                   *                                                                           
5:                   *   FILE:           sensors.c                                               
6:                   *                                                                           
7:                   *   DESCRIPTION:    variables and functions that manage sensors         
8:                   *                                                        
9:                   *   CREATED:		March 9 2012  
10:                  * 	REVISION:   	v0.1 - Define operation and functions 
11:                  ****************************************************************************/
12:                  
13:                  #include <stdio.h>
14:                  #include <stdlib.h>
15:                  #include <string.h>
16:                  #include "../../SYS_LIB/sysglobals.h"
17:                  #include "../../MENUS_LIB/tMenus.h"
18:                  #include "../../SYS_LIB/c_uart.h"
19:                  #include "../wifi.h"
20:                  
21:                  
22:                  
23:                  char* WiFiConfigMenu(char* cBuff, char keyPress)
24:                  {
9D0164B8  27BDFFE8   ADDIU SP, SP, -24
9D0164BC  AFBF0014   SW RA, 20(SP)
9D0164C0  AFBE0010   SW S8, 16(SP)
9D0164C4  03A0F021   ADDU S8, SP, ZERO
9D0164C8  AFC40018   SW A0, 24(S8)
9D0164CC  00A01021   ADDU V0, A1, ZERO
9D0164D0  A3C2001C   SB V0, 28(S8)
25:                      if(keyPress < 0)
9D0164D4  83C2001C   LB V0, 28(S8)
9D0164D8  0441000A   BGEZ V0, 0x9D016504
9D0164DC  00000000   NOP
26:                      {
27:                          sprintf(cBuff,"\x1B[2J\x1B[H  !** Config WiFi Menu **!\r\n \
9D0164E0  8FC40018   LW A0, 24(S8)
9D0164E4  3C029D01   LUI V0, -25343
9D0164E8  244574D0   ADDIU A1, V0, 29904
9D0164EC  24060058   ADDIU A2, ZERO, 88
9D0164F0  0F405AA3   JAL 0x9D016A8C
9D0164F4  00000000   NOP
28:                  \t1 - List Access Points\r\n \
29:                  \t2 - Configure DHCP 1-9\r\n");
30:                          return cBuff;
9D0164F8  8FC20018   LW V0, 24(S8)
9D0164FC  0B405954   J 0x9D016550
9D016500  00000000   NOP
31:                      }
32:                      if(keyPress == 1)
9D016504  83C3001C   LB V1, 28(S8)
9D016508  24020001   ADDIU V0, ZERO, 1
9D01650C  14620005   BNE V1, V0, 0x9D016524
9D016510  00000000   NOP
33:                      {
34:                          SetMenuPage(WiFiAccessPoints);
9D016514  3C029D01   LUI V0, -25343
9D016518  24446568   ADDIU A0, V0, 25960
9D01651C  0F40173E   JAL SetMenuPage
9D016520  00000000   NOP
35:                      }
36:                      if(keyPress ==2)
9D016524  83C3001C   LB V1, 28(S8)
9D016528  24020002   ADDIU V0, ZERO, 2
9D01652C  14620005   BNE V1, V0, 0x9D016544
9D016530  00000000   NOP
37:                      {
38:                          SetMenuPage(WiFiConfigDHCP);
9D016534  3C029D01   LUI V0, -25343
9D016538  244465CC   ADDIU A0, V0, 26060
9D01653C  0F40173E   JAL SetMenuPage
9D016540  00000000   NOP
39:                      }
40:                      cBuff[0] = 0x00;
9D016544  8FC20018   LW V0, 24(S8)
9D016548  A0400000   SB ZERO, 0(V0)
41:                      return cBuff;
9D01654C  8FC20018   LW V0, 24(S8)
42:                  }
9D016550  03C0E821   ADDU SP, S8, ZERO
9D016554  8FBF0014   LW RA, 20(SP)
9D016558  8FBE0010   LW S8, 16(SP)
9D01655C  27BD0018   ADDIU SP, SP, 24
9D016560  03E00008   JR RA
9D016564  00000000   NOP
43:                  char* WiFiAccessPoints(char* cBuff, char keyPress)
44:                  {
9D016568  27BDFFE8   ADDIU SP, SP, -24
9D01656C  AFBF0014   SW RA, 20(SP)
9D016570  AFBE0010   SW S8, 16(SP)
9D016574  03A0F021   ADDU S8, SP, ZERO
9D016578  AFC40018   SW A0, 24(S8)
9D01657C  00A01021   ADDU V0, A1, ZERO
9D016580  A3C2001C   SB V0, 28(S8)
45:                      if(keyPress < 0)
9D016584  83C2001C   LB V0, 28(S8)
9D016588  0441000A   BGEZ V0, 0x9D0165B4
9D01658C  00000000   NOP
46:                      {
47:                          sprintf(cBuff, "\x1B[2J\x1B[H Available Access Points \r\n \
9D016590  8FC40018   LW A0, 24(S8)
9D016594  3C029D01   LUI V0, -25343
9D016598  24457528   ADDIU A1, V0, 29992
9D01659C  24060035   ADDIU A2, ZERO, 53
9D0165A0  0F405AA3   JAL 0x9D016A8C
9D0165A4  00000000   NOP
48:                  \t1 - Stillbright ");  
49:                          return cBuff;
9D0165A8  8FC20018   LW V0, 24(S8)
9D0165AC  0B40596D   J 0x9D0165B4
9D0165B0  00000000   NOP
50:                      }
51:                  }
9D0165B4  03C0E821   ADDU SP, S8, ZERO
9D0165B8  8FBF0014   LW RA, 20(SP)
9D0165BC  8FBE0010   LW S8, 16(SP)
9D0165C0  27BD0018   ADDIU SP, SP, 24
9D0165C4  03E00008   JR RA
9D0165C8  00000000   NOP
52:                  
53:                  char* WiFiConfigDHCP(char* cBuff, char keyPress)
54:                  {
9D0165CC  27BDFFE8   ADDIU SP, SP, -24
9D0165D0  AFBF0014   SW RA, 20(SP)
9D0165D4  AFBE0010   SW S8, 16(SP)
9D0165D8  03A0F021   ADDU S8, SP, ZERO
9D0165DC  AFC40018   SW A0, 24(S8)
9D0165E0  00A01021   ADDU V0, A1, ZERO
9D0165E4  A3C2001C   SB V0, 28(S8)
55:                      if(keyPress < 0)
9D0165E8  83C2001C   LB V0, 28(S8)
9D0165EC  0441000A   BGEZ V0, 0x9D016618
9D0165F0  00000000   NOP
56:                      {
57:                          sprintf(cBuff,"\x1B[2J\x1B[H  !** Config DHCP **!\r\n \
9D0165F4  8FC40018   LW A0, 24(S8)
9D0165F8  3C029D01   LUI V0, -25343
9D0165FC  24457560   ADDIU A1, V0, 30048
9D016600  2406005F   ADDIU A2, ZERO, 95
9D016604  0F405AA3   JAL 0x9D016A8C
9D016608  00000000   NOP
58:                  \t1 - Set Local IP\r\n \
59:                  \t2 - Set Network Mask \r\n \
60:                  \t3 - Set Static IP");
61:                          return cBuff;
9D01660C  8FC20018   LW V0, 24(S8)
9D016610  0B405986   J 0x9D016618
9D016614  00000000   NOP
62:                      }
63:                  }
9D016618  03C0E821   ADDU SP, S8, ZERO
9D01661C  8FBF0014   LW RA, 20(SP)
9D016620  8FBE0010   LW S8, 16(SP)
9D016624  27BD0018   ADDIU SP, SP, 24
9D016628  03E00008   JR RA
9D01662C  00000000   NOP
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/uarts.c  ---------------------------------------------------
1:                   /****************************************************************************
2:                      CREATED BY: 	Stillbright Managment LLC
3:                   *					Copyright 2008
4:                   *                                                                           
5:                   *   FILE:           b_uart.c  (No DMA)                                              
6:                   *                                                                           
7:                   *   DESCRIPTION:    Source Code for non DMA char based uart routines which implements 
8:                   					the definitions in b_uart.h       
9:                   *                                                                           
10:                  *   REVISION:   	v1.005                                                      
11:                  *   Aug 20 2008	-	Created
12:                  *	3/9/2012	-	Made two different uart h files.  One which is  char based and one  
13:                  *					which is binary based. There are two different ssource files for the 
14:                  *					b_uart.h file one that uses DMA and this one which does not.
15:                  ****************************************************************************/
16:                                      // String and buffer processing definitions
17:                  #include "../uarts.h"
18:                  
19:                  
20:                  //#include "serial.h"                  // Communication interface definitions
21:                  
22:                  
23:                  uInt delay = 0, uartTrash = 0, UARTResetDelay =11;   // Status code definitions
24:                  long 	gblBaud; 	// global variable to hold baud rate
25:                  char U1Buffer[U1_BUFFSZ];
26:                  uChar	*ptrU1TXBuff,
27:                  	*ptrU1RXBuff,
28:                  	lowByte;	//Flag indicating where next byte goes in uInt
29:                          
30:                  uInt    *fileBuff; //Pointer to int data to be stored
31:                  		
32:                  int 	TypeOfDeLimit;		//Var to hold delimiting char between numbers.
33:                  uInt 	*IntsBuffer;  // Pointer to hold Int array for transmission
34:                  		
35:                     // rxCmdBuff[CMD_BUFF_SZ],//Used to capture commands from MB Master mbTXBuff is in modbus.c
36:                  uChar numMBBytesLeftToReceive = 0; //if more then 8 byts neaded for command.
37:                      
38:                      //screenBuff[SCREEN_BUFF_SZ];   //   "     "  transmit  "     "
39:                  
40:                  volatile uInt
41:                      rxISRIndex = 0,           // Index for Rx buffer access by ISR
42:                      u1RXIndex = 0,           // Index for Rx buffer access by application
43:                      u2RXIndex = 0,           // Index for Rx buffer access by application
44:                      txAppIndex = 0,           //   "    "  Tx   "      "    "  application    
45:                      txISRIndex = 0;           //   "    "  Tx   "      "    "  ISR
46:                      
47:                  
48:                  uShort
49:                  	// Change rxPageMaker when wanting to receive new msg while working on old 
50:                  	// msg
51:                  	rxPageMarker = 0, 	// Use this to allow two messages to exist 
52:                  	rxFileLength = 0,	// Length of File to receive;
53:                          u1TXFileLength = 0,
54:                  
55:                  	u1TXStatus = 0,     //Flag that allows transmisson or chars ints floats or common delimited
56:                          u1TXMode = 0,
57:                          u2TXStatus = 0,
58:                          u2TXMode = 0,
59:                  	u1RXStatus = 0,
60:                          u1RXMode = 0,
61:                          u2RXStatus,
62:                          u2RXMode;
63:                  
64:                  
65:                  
66:                  uInt ReadMBMasterU1()
67:                  {
9D008BDC  27BDFFF8   ADDIU SP, SP, -8
9D008BE0  AFBE0004   SW S8, 4(SP)
9D008BE4  03A0F021   ADDU S8, SP, ZERO
68:                      
69:                  }
9D008BE8  03C0E821   ADDU SP, S8, ZERO
9D008BEC  8FBE0004   LW S8, 4(SP)
9D008BF0  27BD0008   ADDIU SP, SP, 8
9D008BF4  03E00008   JR RA
9D008BF8  00000000   NOP
70:                  /****************************************************************************
71:                  *   FUNCTION:       ReadU1(char*)                                    *
72:                  *                                                                           *
73:                  *   DESCRIPTION:    Moves data from RX recieve registers and
74:                   *                  null terminates the array
75:                  *                                                                           *
76:                  *   PARAMETERS:     Pointer to char buffer                                            *
77:                  *                                                                           *
78:                  *   RETURNS:        pointer to the same char buffer parameter.       *
79:                  *                                                                           *
80:                  *   REVISION:  0    v1.0                DATE:  1 October 2012            *
81:                  *       Original release.                                                   *
82:                  ****************************************************************************/
83:                  char* ReadStringU1(char *buffPtr)
84:                  {
9D008BFC  27BDFFF0   ADDIU SP, SP, -16
9D008C00  AFBE000C   SW S8, 12(SP)
9D008C04  03A0F021   ADDU S8, SP, ZERO
9D008C08  AFC40010   SW A0, 16(S8)
85:                      uShort msgIndex = 0;
9D008C0C  A7C00000   SH ZERO, 0(S8)
86:                      while (U1STAbits.URXDA) // While data is available in the buffer
9D008C10  0B402310   J 0x9D008C40
9D008C14  00000000   NOP
9D008C40  3C02BF80   LUI V0, -16512
9D008C44  8C426010   LW V0, 24592(V0)
9D008C48  30420001   ANDI V0, V0, 1
9D008C4C  1440FFF2   BNE V0, ZERO, 0x9D008C18
9D008C50  00000000   NOP
87:                      {
88:                          buffPtr[msgIndex++]=U1RXREG;
9D008C18  97C20000   LHU V0, 0(S8)
9D008C1C  8FC30010   LW V1, 16(S8)
9D008C20  00621021   ADDU V0, V1, V0
9D008C24  3C03BF80   LUI V1, -16512
9D008C28  8C636030   LW V1, 24624(V1)
9D008C2C  7C031C20   SEB V1, V1
9D008C30  A0430000   SB V1, 0(V0)
9D008C34  97C20000   LHU V0, 0(S8)
9D008C38  24420001   ADDIU V0, V0, 1
9D008C3C  A7C20000   SH V0, 0(S8)
89:                      }
90:                      buffPtr[msgIndex]=0x00;//*/
9D008C54  97C20000   LHU V0, 0(S8)
9D008C58  8FC30010   LW V1, 16(S8)
9D008C5C  00621021   ADDU V0, V1, V0
9D008C60  A0400000   SB ZERO, 0(V0)
91:                      //uart.if = 0; //Clear flag
92:                      return buffPtr;
9D008C64  8FC20010   LW V0, 16(S8)
93:                      
94:                  }
9D008C68  03C0E821   ADDU SP, S8, ZERO
9D008C6C  8FBE000C   LW S8, 12(SP)
9D008C70  27BD0010   ADDIU SP, SP, 16
9D008C74  03E00008   JR RA
9D008C78  00000000   NOP
95:                  uInt InitMBSlaveU1(uInt BaudRate, char MasterID)
96:                  {
9D008C7C  27BDFFF8   ADDIU SP, SP, -8
9D008C80  AFBE0004   SW S8, 4(SP)
9D008C84  03A0F021   ADDU S8, SP, ZERO
9D008C88  AFC40008   SW A0, 8(S8)
9D008C8C  00A01021   ADDU V0, A1, ZERO
9D008C90  A3C2000C   SB V0, 12(S8)
97:                      
98:                  }
9D008C94  03C0E821   ADDU SP, S8, ZERO
9D008C98  8FBE0004   LW S8, 4(SP)
9D008C9C  27BD0008   ADDIU SP, SP, 8
9D008CA0  03E00008   JR RA
9D008CA4  00000000   NOP
99:                  /****************************************************************************
100:                 *   FUNCTION:       CommInit(Uint8 ui8Port, uInt ui16BaudRate,            *
101:                 *                            uInt ui16Parity, uInt ui16StopBits)        *
102:                 *                                                                           *
103:                 *   DESCRIPTION:    This function configures the system's communication     *
104:                 *                   channel(s).  It must be customized for the specific     *
105:                 *                   communication modules and channel parameters used       *
106:                 *                   for the particular application.                         *
107:                 *                                                                           *
108:                 *                   The function uses the global system communication       *
109:                 *                   configuration parameters; if any of these parameters    *
110:                 *                   are invalid, it uses the default channel parameters     *
111:                 *                   to ensure that the communication channel is at least    *
112:                 *                   operational.                                            *
113:                 *                                                                           *
114:                 *          			Msg is processed after 4 bytes worth of time            *
115:                 *                                                                           *
116:                 *   PARAMETERS:     ui8Port      - index of UART port to configure          *
117:                 *                                  (MUST be either UART_1 or UART_2)        *
118:                 *                   ui16BaudRate - communication baud rate in bits/sec      *
119:                 *                   ui16Parity   - type of parity to use (MUST be one       *
120:                 *                                  of PARITY_*)                             *
121:                 *                   ui16StopBits - number of stop bits (MUST be either      *
122:                 *                                  STOP_BITS_1 or STOP_BITS_2)              *
123:                 *                                                                           *
124:                 *   RETURNS:        The function returns one of the following status        *
125:                 *                   code values:                                            *
126:                 *                   ST_OK        - operation successful                     *
127:                 *                   ST_INV_PARM  - invalid communication parameter          *
128:                 *                                  detected, default channel parameters     *
129:                 *                                  used                                     *
130:                 *                   ST_COMM_INIT - failed to initialize the requested       *
131:                 *                                  communication channel(s)                 *
132:                 *                                                                           *
133:                 *   REVISION:  0    v1.0                DATE:  1 October 2008               *
134:                 *       Original release.                                                   *
135:                 ****************************************************************************/
136:                 uInt InitUART1(uInt BaudRate)
137:                 {
9D008CA8  27BDFFF8   ADDIU SP, SP, -8
9D008CAC  AFBE0004   SW S8, 4(SP)
9D008CB0  03A0F021   ADDU S8, SP, ZERO
9D008CB4  AFC40008   SW A0, 8(S8)
138:                     U1BRG =  (PBCLK/(16*BaudRate))-1;
9D008CB8  3C02BF81   LUI V0, -16511
9D008CBC  8C42F000   LW V0, -4096(V0)
9D008CC0  7C420CC0   EXT V0, V0, 19, 2
9D008CC4  304200FF   ANDI V0, V0, 255
9D008CC8  3C0304C4   LUI V1, 1220
9D008CCC  3463B400   ORI V1, V1, -19456
9D008CD0  00431007   SRAV V0, V1, V0
9D008CD4  00401821   ADDU V1, V0, ZERO
9D008CD8  8FC20008   LW V0, 8(S8)
9D008CDC  00021100   SLL V0, V0, 4
9D008CE0  0062001B   DIVU V1, V0
9D008CE4  004001F4   TEQ V0, ZERO
9D008CE8  00001810   MFHI V1
9D008CEC  00001012   MFLO V0
9D008CF0  2443FFFF   ADDIU V1, V0, -1
9D008CF4  3C02BF80   LUI V0, -16512
9D008CF8  AC436040   SW V1, 24640(V0)
139:                     U1ASTAbits.UTXEN = 1;
9D008CFC  3C03BF80   LUI V1, -16512
9D008D00  8C626010   LW V0, 24592(V1)
9D008D04  24040001   ADDIU A0, ZERO, 1
9D008D08  7C825284   INS V0, A0, 10, 1
9D008D0C  AC626010   SW V0, 24592(V1)
140:                     U1ASTAbits.URXEN = 1;
9D008D10  3C03BF80   LUI V1, -16512
9D008D14  8C626010   LW V0, 24592(V1)
9D008D18  24040001   ADDIU A0, ZERO, 1
9D008D1C  7C826304   INS V0, A0, 12, 1
9D008D20  AC626010   SW V0, 24592(V1)
141:                     U1MODEbits.ON = 1;
9D008D24  3C03BF80   LUI V1, -16512
9D008D28  8C626000   LW V0, 24576(V1)
9D008D2C  24040001   ADDIU A0, ZERO, 1
9D008D30  7C827BC4   INS V0, A0, 15, 1
9D008D34  AC626000   SW V0, 24576(V1)
142:                     return PBCLK/(16*(U1BRG + 1));
9D008D38  3C02BF81   LUI V0, -16511
9D008D3C  8C42F000   LW V0, -4096(V0)
9D008D40  7C420CC0   EXT V0, V0, 19, 2
9D008D44  304200FF   ANDI V0, V0, 255
9D008D48  3C0304C4   LUI V1, 1220
9D008D4C  3463B400   ORI V1, V1, -19456
9D008D50  00431007   SRAV V0, V1, V0
9D008D54  00401821   ADDU V1, V0, ZERO
9D008D58  3C02BF80   LUI V0, -16512
9D008D5C  8C426040   LW V0, 24640(V0)
9D008D60  24420001   ADDIU V0, V0, 1
9D008D64  00021100   SLL V0, V0, 4
9D008D68  0062001B   DIVU V1, V0
9D008D6C  004001F4   TEQ V0, ZERO
9D008D70  00001810   MFHI V1
9D008D74  00001012   MFLO V0
143:                 }
9D008D78  03C0E821   ADDU SP, S8, ZERO
9D008D7C  8FBE0004   LW S8, 4(SP)
9D008D80  27BD0008   ADDIU SP, SP, 8
9D008D84  03E00008   JR RA
9D008D88  00000000   NOP
144:                 
145:                 void ResetMBU1(char *CmdBuffer)
146:                 {
9D008D8C  27BDFFF8   ADDIU SP, SP, -8
9D008D90  AFBE0004   SW S8, 4(SP)
9D008D94  03A0F021   ADDU S8, SP, ZERO
9D008D98  AFC40008   SW A0, 8(S8)
147:                     u1RXIndex = 0;
9D008D9C  AF8080D8   SW ZERO, -32552(GP)
148:                     CmdBuffer[0] = NULL;
9D008DA0  8FC20008   LW V0, 8(S8)
9D008DA4  A0400000   SB ZERO, 0(V0)
149:                     CmdBuffer[1] = NULL;
9D008DA8  8FC20008   LW V0, 8(S8)
9D008DAC  24420001   ADDIU V0, V0, 1
9D008DB0  A0400000   SB ZERO, 0(V0)
150:                     u1RXStatus == RX_IDLE;
151:                 }
9D008DB4  03C0E821   ADDU SP, S8, ZERO
9D008DB8  8FBE0004   LW S8, 4(SP)
9D008DBC  27BD0008   ADDIU SP, SP, 8
9D008DC0  03E00008   JR RA
9D008DC4  00000000   NOP
152:                 /****************************************************************************
153:                 *   FUNCTION:       ReadMBMasterU1(void)                                   *
154:                 *                                                                           *
155:                 *   DESCRIPTION:    Reads U1 looking for the possiblility of a Modbus
156:                  *                  command.
157:                 *                                                                           *
158:                 *   PARAMETERS:     cmdBuffer - The uChar array holding the command
159:                  *                                                             *
160:                 *                                                                           *
161:                 *   RETURNS:        zero if nither an ESC char or MasterID is found.  The tells
162:                  *              the system that no action is required. The system
163:                  *              will reset the uart if 
164:                  *  
165:                  *                  1 if MasterID found but in row are found then returns 1 *
166:                 *                                                                           *
167:                 *   REVISION:  0    v1.0                DATE:  12/9/2012            *
168:                                                                    *
169:                 ****************************************************************************/
170:                 uShort ReadU1AsSlave(char * CmdBuffer, uShort SysStatus)
171:                 {
9D008DC8  27BDFFE8   ADDIU SP, SP, -24
9D008DCC  AFBF0014   SW RA, 20(SP)
9D008DD0  AFBE0010   SW S8, 16(SP)
9D008DD4  03A0F021   ADDU S8, SP, ZERO
9D008DD8  AFC40018   SW A0, 24(S8)
9D008DDC  00A01021   ADDU V0, A1, ZERO
9D008DE0  A7C2001C   SH V0, 28(S8)
172:                     if(SysStatus == RX_IDLE)//This is because sys main may have timed out leaving the UART is an old state
9D008DE4  97C2001C   LHU V0, 28(S8)
9D008DE8  14400003   BNE V0, ZERO, 0x9D008DF8
9D008DEC  00000000   NOP
173:                     {
174:                         u1RXStatus = RX_IDLE;
9D008DF0  A78080F6   SH ZERO, -32522(GP)
175:                         u1RXIndex = 0;
9D008DF4  AF8080D8   SW ZERO, -32552(GP)
176:                     }
177:                     //The ID and cmd was correct but the cmd needs more bytes
178:                     if(u1RXStatus == RXMB_WAITING)//0x0010
9D008DF8  978380F6   LHU V1, -32522(GP)
9D008DFC  24020010   ADDIU V0, ZERO, 16
9D008E00  14620048   BNE V1, V0, 0x9D008F24
9D008E04  00000000   NOP
179:                     {
180:                         while (U1STAbits.URXDA) // While data is available in the buffer
9D008E08  0B40238D   J 0x9D008E34
9D008E0C  00000000   NOP
9D008E34  3C02BF80   LUI V0, -16512
9D008E38  8C426010   LW V0, 24592(V0)
9D008E3C  30420001   ANDI V0, V0, 1
9D008E40  1440FFF3   BNE V0, ZERO, 0x9D008E10
9D008E44  00000000   NOP
181:                         {
182:                            CmdBuffer[u1RXIndex++] = U1RXREG;
9D008E10  8F8280D8   LW V0, -32552(GP)
9D008E14  8FC30018   LW V1, 24(S8)
9D008E18  00621821   ADDU V1, V1, V0
9D008E1C  3C04BF80   LUI A0, -16512
9D008E20  8C846030   LW A0, 24624(A0)
9D008E24  7C042420   SEB A0, A0
9D008E28  A0640000   SB A0, 0(V1)
9D008E2C  24420001   ADDIU V0, V0, 1
9D008E30  AF8280D8   SW V0, -32552(GP)
183:                         }
184:                         
185:                         if(numMBBytesLeftToReceive == 0)
9D008E48  938280D0   LBU V0, -32560(GP)
9D008E4C  1440001F   BNE V0, ZERO, 0x9D008ECC
9D008E50  00000000   NOP
186:                         {
187:                             //We would only have a non zero numMBBytesLeftToReceive if a cmd
188:                             // had run and was requesting more bytes, therefore
189:                             //UART has not accumlated enough bytes to run any cmd.
190:                             if(u1RXIndex >= MIN_MB_MSG_SZ) 
9D008E54  8F8280D8   LW V0, -32552(GP)
9D008E58  2C420008   SLTIU V0, V0, 8
9D008E5C  14400016   BNE V0, ZERO, 0x9D008EB8
9D008E60  00000000   NOP
191:                             {
192:                                 numMBBytesLeftToReceive = ProcessMBCommand(CmdBuffer,0,MasterID);
9D008E64  8FC30018   LW V1, 24(S8)
9D008E68  93828024   LBU V0, -32732(GP)
9D008E6C  00602021   ADDU A0, V1, ZERO
9D008E70  00002821   ADDU A1, ZERO, ZERO
9D008E74  00403021   ADDU A2, V0, ZERO
9D008E78  0F402668   JAL ProcessMBCommand
9D008E7C  00000000   NOP
9D008E80  304200FF   ANDI V0, V0, 255
9D008E84  A38280D0   SB V0, -32560(GP)
193:                                 if(numMBBytesLeftToReceive > 0)//Still need more bytes
9D008E88  938280D0   LBU V0, -32560(GP)
9D008E8C  10400006   BEQ V0, ZERO, 0x9D008EA8
9D008E90  00000000   NOP
194:                                 {
195:                                     u1RXStatus = RXMB_WAITING;
9D008E94  24020010   ADDIU V0, ZERO, 16
9D008E98  A78280F6   SH V0, -32522(GP)
196:                                     return RXMB_WAITING;   
9D008E9C  24020010   ADDIU V0, ZERO, 16
9D008EA0  0B40247A   J 0x9D0091E8
9D008EA4  00000000   NOP
197:                                 }
198:                                 u1RXStatus = RX_IDLE;
9D008EA8  A78080F6   SH ZERO, -32522(GP)
199:                                 return RX_IDLE;//Stay in command mode
9D008EAC  00001021   ADDU V0, ZERO, ZERO
9D008EB0  0B40247A   J 0x9D0091E8
9D008EB4  00000000   NOP
200:                 
201:                             }
202:                             //MB cmd was processed and system is now ready for another.
203:                             //Errors are handled in the MB module.
204:                             else 
205:                             {
206:                                 u1RXStatus = RXMB_WAITING;
9D008EB8  24020010   ADDIU V0, ZERO, 16
9D008EBC  A78280F6   SH V0, -32522(GP)
207:                                 return RXMB_WAITING;//Stay in command mode
9D008EC0  24020010   ADDIU V0, ZERO, 16
9D008EC4  0B40247A   J 0x9D0091E8
9D008EC8  00000000   NOP
208:                             }
209:                         }
210:                         //MB cmd has been run and is requesting more bytes, ck and see if we have them
211:                         if(u1RXIndex < numMBBytesLeftToReceive)
9D008ECC  938280D0   LBU V0, -32560(GP)
9D008ED0  00401821   ADDU V1, V0, ZERO
9D008ED4  8F8280D8   LW V0, -32552(GP)
9D008ED8  0043102B   SLTU V0, V0, V1
9D008EDC  10400004   BEQ V0, ZERO, 0x9D008EF0
9D008EE0  00000000   NOP
212:                         {
213:                            return RXMB_WAITING; 
9D008EE4  24020010   ADDIU V0, ZERO, 16
9D008EE8  0B40247A   J 0x9D0091E8
9D008EEC  00000000   NOP
214:                         }
215:                         else
216:                         {
217:                             ProcessMBCommand(CmdBuffer,u1RXIndex,MasterID);
9D008EF0  8FC40018   LW A0, 24(S8)
9D008EF4  8F8280D8   LW V0, -32552(GP)
9D008EF8  304200FF   ANDI V0, V0, 255
9D008EFC  00401821   ADDU V1, V0, ZERO
9D008F00  93828024   LBU V0, -32732(GP)
9D008F04  00602821   ADDU A1, V1, ZERO
9D008F08  00403021   ADDU A2, V0, ZERO
9D008F0C  0F402668   JAL ProcessMBCommand
9D008F10  00000000   NOP
218:                             numMBBytesLeftToReceive = 0;
9D008F14  A38080D0   SB ZERO, -32560(GP)
219:                             return RX_IDLE;//RXMB_WAITING
9D008F18  00001021   ADDU V0, ZERO, ZERO
9D008F1C  0B40247A   J 0x9D0091E8
9D008F20  00000000   NOP
220:                         }
221:                     }
222:                     //We weren't waiting on a cmd so check if we have either an ESC char or the MasterID
223:                     else if(u1RXStatus == RX_IDLE)
9D008F24  978280F6   LHU V0, -32522(GP)
9D008F28  1440006C   BNE V0, ZERO, 0x9D0090DC
9D008F2C  00000000   NOP
224:                     {
225:                         u1RXIndex = 0;
9D008F30  AF8080D8   SW ZERO, -32552(GP)
226:                         // Does first byte matches unit ID
227:                         CmdBuffer[u1RXIndex] = U1RXREG;
9D008F34  8F8280D8   LW V0, -32552(GP)
9D008F38  8FC30018   LW V1, 24(S8)
9D008F3C  00621021   ADDU V0, V1, V0
9D008F40  3C03BF80   LUI V1, -16512
9D008F44  8C636030   LW V1, 24624(V1)
9D008F48  7C031C20   SEB V1, V1
9D008F4C  A0430000   SB V1, 0(V0)
228:                         if(CmdBuffer[u1RXIndex] == MasterID)
9D008F50  8F8280D8   LW V0, -32552(GP)
9D008F54  8FC30018   LW V1, 24(S8)
9D008F58  00621021   ADDU V0, V1, V0
9D008F5C  80420000   LB V0, 0(V0)
9D008F60  00401821   ADDU V1, V0, ZERO
9D008F64  93828024   LBU V0, -32732(GP)
9D008F68  14620031   BNE V1, V0, 0x9D009030
9D008F6C  00000000   NOP
229:                         {   
230:                             u1RXIndex = 1;
9D008F70  24020001   ADDIU V0, ZERO, 1
9D008F74  AF8280D8   SW V0, -32552(GP)
231:                             //We know we have one byte do we have more
232:                             while (U1STAbits.URXDA) // While data is available in the buffer
9D008F78  0B4023E9   J 0x9D008FA4
9D008F7C  00000000   NOP
9D008FA4  3C02BF80   LUI V0, -16512
9D008FA8  8C426010   LW V0, 24592(V0)
9D008FAC  30420001   ANDI V0, V0, 1
9D008FB0  1440FFF3   BNE V0, ZERO, 0x9D008F80
9D008FB4  00000000   NOP
233:                             {
234:                                CmdBuffer[u1RXIndex++] = U1RXREG;
9D008F80  8F8280D8   LW V0, -32552(GP)
9D008F84  8FC30018   LW V1, 24(S8)
9D008F88  00621821   ADDU V1, V1, V0
9D008F8C  3C04BF80   LUI A0, -16512
9D008F90  8C846030   LW A0, 24624(A0)
9D008F94  7C042420   SEB A0, A0
9D008F98  A0640000   SB A0, 0(V1)
9D008F9C  24420001   ADDIU V0, V0, 1
9D008FA0  AF8280D8   SW V0, -32552(GP)
235:                             }
236:                             if(u1RXIndex >= MIN_MB_MSG_SZ)
9D008FB8  8F8280D8   LW V0, -32552(GP)
9D008FBC  2C420008   SLTIU V0, V0, 8
9D008FC0  14400016   BNE V0, ZERO, 0x9D00901C
9D008FC4  00000000   NOP
237:                             {
238:                                 numMBBytesLeftToReceive = ProcessMBCommand(CmdBuffer,0,MasterID);
9D008FC8  8FC30018   LW V1, 24(S8)
9D008FCC  93828024   LBU V0, -32732(GP)
9D008FD0  00602021   ADDU A0, V1, ZERO
9D008FD4  00002821   ADDU A1, ZERO, ZERO
9D008FD8  00403021   ADDU A2, V0, ZERO
9D008FDC  0F402668   JAL ProcessMBCommand
9D008FE0  00000000   NOP
9D008FE4  304200FF   ANDI V0, V0, 255
9D008FE8  A38280D0   SB V0, -32560(GP)
239:                                 if(numMBBytesLeftToReceive > 0)
9D008FEC  938280D0   LBU V0, -32560(GP)
9D008FF0  10400006   BEQ V0, ZERO, 0x9D00900C
9D008FF4  00000000   NOP
240:                                 {
241:                                     u1RXStatus = RXMB_WAITING;
9D008FF8  24020010   ADDIU V0, ZERO, 16
9D008FFC  A78280F6   SH V0, -32522(GP)
242:                                     return RXMB_WAITING;   
9D009000  24020010   ADDIU V0, ZERO, 16
9D009004  0B40247A   J 0x9D0091E8
9D009008  00000000   NOP
243:                                 }
244:                                 u1RXStatus = RX_IDLE;
9D00900C  A78080F6   SH ZERO, -32522(GP)
245:                                 return RX_IDLE;//Stay in command mode
9D009010  00001021   ADDU V0, ZERO, ZERO
9D009014  0B40247A   J 0x9D0091E8
9D009018  00000000   NOP
246:                             }
247:                             u1RXStatus = RXMB_WAITING;
9D00901C  24020010   ADDIU V0, ZERO, 16
9D009020  A78280F6   SH V0, -32522(GP)
248:                             return RXMB_WAITING;//Stay in command mode
9D009024  24020010   ADDIU V0, ZERO, 16
9D009028  0B40247A   J 0x9D0091E8
9D00902C  00000000   NOP
249:                         }
250:                         if(CmdBuffer[0] == htESC)
9D009030  8FC20018   LW V0, 24(S8)
9D009034  80430000   LB V1, 0(V0)
9D009038  2402001B   ADDIU V0, ZERO, 27
9D00903C  14620027   BNE V1, V0, 0x9D0090DC
9D009040  00000000   NOP
251:                         {
252:                             u1RXIndex = 1;
9D009044  24020001   ADDIU V0, ZERO, 1
9D009048  AF8280D8   SW V0, -32552(GP)
253:                             
254:                             //We know we have one byte do we have more
255:                             while (U1STAbits.URXDA) // While data is available in the buffer
9D00904C  0B40241E   J 0x9D009078
9D009050  00000000   NOP
9D009078  3C02BF80   LUI V0, -16512
9D00907C  8C426010   LW V0, 24592(V0)
9D009080  30420001   ANDI V0, V0, 1
9D009084  1440FFF3   BNE V0, ZERO, 0x9D009054
9D009088  00000000   NOP
256:                             {
257:                                 CmdBuffer[u1RXIndex++] = U1RXREG;
9D009054  8F8280D8   LW V0, -32552(GP)
9D009058  8FC30018   LW V1, 24(S8)
9D00905C  00621821   ADDU V1, V1, V0
9D009060  3C04BF80   LUI A0, -16512
9D009064  8C846030   LW A0, 24624(A0)
9D009068  7C042420   SEB A0, A0
9D00906C  A0640000   SB A0, 0(V1)
9D009070  24420001   ADDIU V0, V0, 1
9D009074  AF8280D8   SW V0, -32552(GP)
258:                             } 
259:                             if(u1RXIndex > 1)//if we did already get another byte, check for ESC
9D00908C  8F8280D8   LW V0, -32552(GP)
9D009090  2C420002   SLTIU V0, V0, 2
9D009094  1440000F   BNE V0, ZERO, 0x9D0090D4
9D009098  00000000   NOP
260:                             {
261:                                 if(CmdBuffer[1] == htESC)
9D00909C  8FC20018   LW V0, 24(S8)
9D0090A0  24420001   ADDIU V0, V0, 1
9D0090A4  80430000   LB V1, 0(V0)
9D0090A8  2402001B   ADDIU V0, ZERO, 27
9D0090AC  14620006   BNE V1, V0, 0x9D0090C8
9D0090B0  00000000   NOP
262:                                 {
263:                                   u1RXStatus = RXMENU_ACTIVE; 
9D0090B4  24020080   ADDIU V0, ZERO, 128
9D0090B8  A78280F6   SH V0, -32522(GP)
264:                                   return RXMENU_ACTIVE;
9D0090BC  24020080   ADDIU V0, ZERO, 128
9D0090C0  0B40247A   J 0x9D0091E8
9D0090C4  00000000   NOP
265:                                 }
266:                                 else u1RXStatus = RX_IDLE;
9D0090C8  A78080F6   SH ZERO, -32522(GP)
9D0090CC  0B402437   J 0x9D0090DC
9D0090D0  00000000   NOP
267:                             }
268:                             else //if we got one ESC, go back and see if next char is ESC
269:                             {
270:                                 u1RXStatus = RXMENU_STARTING;// We may be in menu mode
9D0090D4  24020040   ADDIU V0, ZERO, 64
9D0090D8  A78280F6   SH V0, -32522(GP)
271:                             }
272:                         }
273:                     }
274:                     if(u1RXStatus == RXMENU_ACTIVE)//0x0080
9D0090DC  978380F6   LHU V1, -32522(GP)
9D0090E0  24020080   ADDIU V0, ZERO, 128
9D0090E4  14620015   BNE V1, V0, 0x9D00913C
9D0090E8  00000000   NOP
275:                     {
276:                         while (U1STAbits.URXDA) // While data is available in the buffer
9D0090EC  0B402446   J 0x9D009118
9D0090F0  00000000   NOP
9D009118  3C02BF80   LUI V0, -16512
9D00911C  8C426010   LW V0, 24592(V0)
9D009120  30420001   ANDI V0, V0, 1
9D009124  1440FFF3   BNE V0, ZERO, 0x9D0090F4
9D009128  00000000   NOP
277:                         {
278:                             CmdBuffer[u1RXIndex++] = U1RXREG;
9D0090F4  8F8280D8   LW V0, -32552(GP)
9D0090F8  8FC30018   LW V1, 24(S8)
9D0090FC  00621821   ADDU V1, V1, V0
9D009100  3C04BF80   LUI A0, -16512
9D009104  8C846030   LW A0, 24624(A0)
9D009108  7C042420   SEB A0, A0
9D00910C  A0640000   SB A0, 0(V1)
9D009110  24420001   ADDIU V0, V0, 1
9D009114  AF8280D8   SW V0, -32552(GP)
279:                         }
280:                         u1RXIndex = 0;
9D00912C  AF8080D8   SW ZERO, -32552(GP)
281:                         //Run menu
282:                         if(1)
283:                         {
284:                             return RXMENU_ACTIVE;//0x0080
9D009130  24020080   ADDIU V0, ZERO, 128
9D009134  0B40247A   J 0x9D0091E8
9D009138  00000000   NOP
285:                         }
286:                         if(0)//if menu returns an exit command
287:                         {
288:                             return RX_IDLE;
289:                         }
290:                     }    
291:                     if(u1RXStatus == RXMENU_STARTING)
9D00913C  978380F6   LHU V1, -32522(GP)
9D009140  24020040   ADDIU V0, ZERO, 64
9D009144  14620027   BNE V1, V0, 0x9D0091E4
9D009148  00000000   NOP
292:                     {
293:                         while (U1STAbits.URXDA) // While data is available in the buffer
9D00914C  0B40245E   J 0x9D009178
9D009150  00000000   NOP
9D009178  3C02BF80   LUI V0, -16512
9D00917C  8C426010   LW V0, 24592(V0)
9D009180  30420001   ANDI V0, V0, 1
9D009184  1440FFF3   BNE V0, ZERO, 0x9D009154
9D009188  00000000   NOP
294:                         {
295:                             CmdBuffer[u1RXIndex++] = U1RXREG;
9D009154  8F8280D8   LW V0, -32552(GP)
9D009158  8FC30018   LW V1, 24(S8)
9D00915C  00621821   ADDU V1, V1, V0
9D009160  3C04BF80   LUI A0, -16512
9D009164  8C846030   LW A0, 24624(A0)
9D009168  7C042420   SEB A0, A0
9D00916C  A0640000   SB A0, 0(V1)
9D009170  24420001   ADDIU V0, V0, 1
9D009174  AF8280D8   SW V0, -32552(GP)
296:                         }
297:                         if(u1RXIndex <= 1) return RXMENU_STARTING;
9D00918C  8F8280D8   LW V0, -32552(GP)
9D009190  2C420002   SLTIU V0, V0, 2
9D009194  10400004   BEQ V0, ZERO, 0x9D0091A8
9D009198  00000000   NOP
9D00919C  24020040   ADDIU V0, ZERO, 64
9D0091A0  0B40247A   J 0x9D0091E8
9D0091A4  00000000   NOP
298:                         if(CmdBuffer[1] == htESC)//The only way menu can start is if first two bytes are esc
9D0091A8  8FC20018   LW V0, 24(S8)
9D0091AC  24420001   ADDIU V0, V0, 1
9D0091B0  80430000   LB V1, 0(V0)
9D0091B4  2402001B   ADDIU V0, ZERO, 27
9D0091B8  14620007   BNE V1, V0, 0x9D0091D8
9D0091BC  00000000   NOP
299:                         {
300:                             u1RXIndex = 0;
9D0091C0  AF8080D8   SW ZERO, -32552(GP)
301:                             u1RXStatus = RXMENU_ACTIVE;
9D0091C4  24020080   ADDIU V0, ZERO, 128
9D0091C8  A78280F6   SH V0, -32522(GP)
302:                             return RXMENU_ACTIVE;
9D0091CC  24020080   ADDIU V0, ZERO, 128
9D0091D0  0B40247A   J 0x9D0091E8
9D0091D4  00000000   NOP
303:                         }
304:                         return RX_IDLE;
9D0091D8  00001021   ADDU V0, ZERO, ZERO
9D0091DC  0B40247A   J 0x9D0091E8
9D0091E0  00000000   NOP
305:                     }
306:                     return 0;//1 if we need to change to menu mode
9D0091E4  00001021   ADDU V0, ZERO, ZERO
307:                   
308:                 }
9D0091E8  03C0E821   ADDU SP, S8, ZERO
9D0091EC  8FBF0014   LW RA, 20(SP)
9D0091F0  8FBE0010   LW S8, 16(SP)
9D0091F4  27BD0018   ADDIU SP, SP, 24
9D0091F8  03E00008   JR RA
9D0091FC  00000000   NOP
309:                 uChar WriteStringU1(uChar *cBuff)
310:                 {
9D009200  27BDFFF0   ADDIU SP, SP, -16
9D009204  AFBE000C   SW S8, 12(SP)
9D009208  03A0F021   ADDU S8, SP, ZERO
9D00920C  AFC40010   SW A0, 16(S8)
311:                     int index = 0;
9D009210  AFC00000   SW ZERO, 0(S8)
312:                       while(cBuff[index] != 0x00)
9D009214  0B402497   J 0x9D00925C
9D009218  00000000   NOP
9D00925C  8FC20000   LW V0, 0(S8)
9D009260  8FC30010   LW V1, 16(S8)
9D009264  00621021   ADDU V0, V1, V0
9D009268  90420000   LBU V0, 0(V0)
9D00926C  1440FFEB   BNE V0, ZERO, 0x9D00921C
9D009270  00000000   NOP
313:                     {
314:                         while(U1STAbits.UTXBF);
9D00921C  00000000   NOP
9D009220  3C02BF80   LUI V0, -16512
9D009224  8C426010   LW V0, 24592(V0)
9D009228  30420200   ANDI V0, V0, 512
9D00922C  1440FFFC   BNE V0, ZERO, 0x9D009220
9D009230  00000000   NOP
315:                         U1TXREG = cBuff[index++];
9D009234  8FC20000   LW V0, 0(S8)
9D009238  8FC30010   LW V1, 16(S8)
9D00923C  00621021   ADDU V0, V1, V0
9D009240  90420000   LBU V0, 0(V0)
9D009244  00401821   ADDU V1, V0, ZERO
9D009248  3C02BF80   LUI V0, -16512
9D00924C  AC436020   SW V1, 24608(V0)
9D009250  8FC20000   LW V0, 0(S8)
9D009254  24420001   ADDIU V0, V0, 1
9D009258  AFC20000   SW V0, 0(S8)
316:                     }
317:                     //uart.if = 0; //Clear flag
318:                     return cBuff[index];
9D009274  8FC20000   LW V0, 0(S8)
9D009278  8FC30010   LW V1, 16(S8)
9D00927C  00621021   ADDU V0, V1, V0
9D009280  90420000   LBU V0, 0(V0)
319:                 }
9D009284  03C0E821   ADDU SP, S8, ZERO
9D009288  8FBE000C   LW S8, 12(SP)
9D00928C  27BD0010   ADDIU SP, SP, 16
9D009290  03E00008   JR RA
9D009294  00000000   NOP
320:                 /****************************************************************************
321:                 *   FUNCTION:       ReadU1(char*)                                    *
322:                 *                                                                           *
323:                 *   DESCRIPTION:    Moves data from RX recieve registers and 
324:                  *                  null terminates the array 
325:                 *                                                                           *
326:                 *   PARAMETERS:     Pointer to char buffer                                            *
327:                 *                                                                           *
328:                 *   RETURNS:        pointer to the same char buffer parameter.       *
329:                 *                                                                           *
330:                 *   REVISION:  0    v1.0                DATE:  1 October 2012            *
331:                 *       Original release.                                                   *
332:                 ****************************************************************************/
333:                 char* ReadStringU2(char *buffPtr)
334:                 {
9D009298  27BDFFF0   ADDIU SP, SP, -16
9D00929C  AFBE000C   SW S8, 12(SP)
9D0092A0  03A0F021   ADDU S8, SP, ZERO
9D0092A4  AFC40010   SW A0, 16(S8)
335:                     int serialIndex = 0;
9D0092A8  AFC00000   SW ZERO, 0(S8)
336:                     while (U1STAbits.URXDA) // While data is available in the buffer
9D0092AC  0B4024B7   J 0x9D0092DC
9D0092B0  00000000   NOP
9D0092DC  3C02BF80   LUI V0, -16512
9D0092E0  8C426010   LW V0, 24592(V0)
9D0092E4  30420001   ANDI V0, V0, 1
9D0092E8  1440FFF2   BNE V0, ZERO, 0x9D0092B4
9D0092EC  00000000   NOP
337:                     {
338:                         buffPtr[serialIndex++]=U2RXREG;
9D0092B4  8FC20000   LW V0, 0(S8)
9D0092B8  8FC30010   LW V1, 16(S8)
9D0092BC  00621021   ADDU V0, V1, V0
9D0092C0  3C03BF80   LUI V1, -16512
9D0092C4  8C636830   LW V1, 26672(V1)
9D0092C8  7C031C20   SEB V1, V1
9D0092CC  A0430000   SB V1, 0(V0)
9D0092D0  8FC20000   LW V0, 0(S8)
9D0092D4  24420001   ADDIU V0, V0, 1
9D0092D8  AFC20000   SW V0, 0(S8)
339:                     }
340:                     buffPtr[serialIndex]=0x00;//*/
9D0092F0  8FC20000   LW V0, 0(S8)
9D0092F4  8FC30010   LW V1, 16(S8)
9D0092F8  00621021   ADDU V0, V1, V0
9D0092FC  A0400000   SB ZERO, 0(V0)
341:                     //uart.if = 0; //Clear flag
342:                     return buffPtr;
9D009300  8FC20010   LW V0, 16(S8)
343:                     
344:                 }
9D009304  03C0E821   ADDU SP, S8, ZERO
9D009308  8FBE000C   LW S8, 12(SP)
9D00930C  27BD0010   ADDIU SP, SP, 16
9D009310  03E00008   JR RA
9D009314  00000000   NOP
345:                   /****************************************************************************
346:                 *   FUNCTION:       TerminalOutU1(char)                                    *
347:                 *                                                                           *
348:                 *   DESCRIPTION:    This function takes a string ment for display
349:                    *                on a embedded LCD screen and adds terminal code
350:                    *                to the front of the string which clears the screen 
351:                    *                the previous message *
352:                 *                                                                           *
353:                 *   PARAMETERS:     None                                                    *
354:                 *                                                                           *
355:                 *   RETURNS:        The function returns no value since it is an ISR.       *
356:                 *                                                                           *
357:                 *   REVISION:  0    v1.0                DATE:  1 October 2012            *
358:                 *       Original release.                                                   *
359:                 ****************************************************************************/
360:                 void WriteTerminalU1(char *buffPtr)
361:                 {
9D009318  27BDFFF0   ADDIU SP, SP, -16
9D00931C  AFBE000C   SW S8, 12(SP)
9D009320  03A0F021   ADDU S8, SP, ZERO
9D009324  AFC40010   SW A0, 16(S8)
362:                     int index = 0;
9D009328  AFC00000   SW ZERO, 0(S8)
363:                     static const char scr1StrLn1[] ="\x1B[2J\x1B[H";
364:                     while(scr1StrLn1[index] != 0x00)
9D00932C  0B4024DE   J 0x9D009378
9D009330  00000000   NOP
9D009378  3C029D02   LUI V0, -25342
9D00937C  24439748   ADDIU V1, V0, -26808
9D009380  8FC20000   LW V0, 0(S8)
9D009384  00621021   ADDU V0, V1, V0
9D009388  80420000   LB V0, 0(V0)
9D00938C  1440FFE9   BNE V0, ZERO, 0x9D009334
9D009390  00000000   NOP
365:                     {
366:                         while(U1STAbits.UTXBF);
9D009334  00000000   NOP
9D009338  3C02BF80   LUI V0, -16512
9D00933C  8C426010   LW V0, 24592(V0)
9D009340  30420200   ANDI V0, V0, 512
9D009344  1440FFFC   BNE V0, ZERO, 0x9D009338
9D009348  00000000   NOP
367:                         U1TXREG = scr1StrLn1[index++];
9D00934C  3C029D02   LUI V0, -25342
9D009350  24439748   ADDIU V1, V0, -26808
9D009354  8FC20000   LW V0, 0(S8)
9D009358  00621021   ADDU V0, V1, V0
9D00935C  80420000   LB V0, 0(V0)
9D009360  00401821   ADDU V1, V0, ZERO
9D009364  3C02BF80   LUI V0, -16512
9D009368  AC436020   SW V1, 24608(V0)
9D00936C  8FC20000   LW V0, 0(S8)
9D009370  24420001   ADDIU V0, V0, 1
9D009374  AFC20000   SW V0, 0(S8)
368:                     }
369:                      while(*buffPtr != 0x00)
9D009394  0B402500   J 0x9D009400
9D009398  00000000   NOP
9D009400  8FC20010   LW V0, 16(S8)
9D009404  80420000   LB V0, 0(V0)
9D009408  1440FFE4   BNE V0, ZERO, 0x9D00939C
9D00940C  00000000   NOP
370:                     {
371:                         switch(buffPtr[index])
9D00939C  8FC20000   LW V0, 0(S8)
9D0093A0  8FC30010   LW V1, 16(S8)
9D0093A4  00621021   ADDU V0, V1, V0
9D0093A8  80420000   LB V0, 0(V0)
9D0093AC  00401821   ADDU V1, V0, ZERO
9D0093B0  24020008   ADDIU V0, ZERO, 8
9D0093B4  10620003   BEQ V1, V0, 0x9D0093C4
9D0093B8  00000000   NOP
372:                         {
373:                             case 0x08:
374:                                 break;
9D0093C4  00000000   NOP
375:                             default:
376:                                 break;
9D0093BC  0B4024F2   J 0x9D0093C8
9D0093C0  00000000   NOP
377:                         }
378:                         while(U1STAbits.UTXBF);
9D0093C8  00000000   NOP
9D0093CC  3C02BF80   LUI V0, -16512
9D0093D0  8C426010   LW V0, 24592(V0)
9D0093D4  30420200   ANDI V0, V0, 512
9D0093D8  1440FFFC   BNE V0, ZERO, 0x9D0093CC
9D0093DC  00000000   NOP
379:                         U1TXREG = *buffPtr++;
9D0093E0  8FC20010   LW V0, 16(S8)
9D0093E4  80420000   LB V0, 0(V0)
9D0093E8  00401821   ADDU V1, V0, ZERO
9D0093EC  3C02BF80   LUI V0, -16512
9D0093F0  AC436020   SW V1, 24608(V0)
9D0093F4  8FC20010   LW V0, 16(S8)
9D0093F8  24420001   ADDIU V0, V0, 1
9D0093FC  AFC20010   SW V0, 16(S8)
380:                     }     
381:                 }
9D009410  03C0E821   ADDU SP, S8, ZERO
9D009414  8FBE000C   LW S8, 12(SP)
9D009418  27BD0010   ADDIU SP, SP, 16
9D00941C  03E00008   JR RA
9D009420  00000000   NOP
382:                 void WriteCharU1(uChar receiveBuff)
383:                 {
9D009424  27BDFFF8   ADDIU SP, SP, -8
9D009428  AFBE0004   SW S8, 4(SP)
9D00942C  03A0F021   ADDU S8, SP, ZERO
9D009430  00801021   ADDU V0, A0, ZERO
9D009434  A3C20008   SB V0, 8(S8)
384:                 	U1TXREG = receiveBuff;
9D009438  93C30008   LBU V1, 8(S8)
9D00943C  3C02BF80   LUI V0, -16512
9D009440  AC436020   SW V1, 24608(V0)
385:                 	//IFS1bits.U2TXIF = 0;
386:                 
387:                 }
9D009444  03C0E821   ADDU SP, S8, ZERO
9D009448  8FBE0004   LW S8, 4(SP)
9D00944C  27BD0008   ADDIU SP, SP, 8
9D009450  03E00008   JR RA
9D009454  00000000   NOP
388:                 char WriteCharsU1(char *Buffer, uInt Length)
389:                 {
9D009458  27BDFFF0   ADDIU SP, SP, -16
9D00945C  AFBE000C   SW S8, 12(SP)
9D009460  03A0F021   ADDU S8, SP, ZERO
9D009464  AFC40010   SW A0, 16(S8)
9D009468  AFC50014   SW A1, 20(S8)
390:                     uChar bIndex = 0;
9D00946C  A3C00000   SB ZERO, 0(S8)
391:                     while(bIndex < Length)
9D009470  0B40252E   J 0x9D0094B8
9D009474  00000000   NOP
9D0094B8  93C30000   LBU V1, 0(S8)
9D0094BC  8FC20014   LW V0, 20(S8)
9D0094C0  0062102B   SLTU V0, V1, V0
9D0094C4  1440FFEC   BNE V0, ZERO, 0x9D009478
9D0094C8  00000000   NOP
392:                     {
393:                         while(U1STAbits.UTXBF);
9D009478  00000000   NOP
9D00947C  3C02BF80   LUI V0, -16512
9D009480  8C426010   LW V0, 24592(V0)
9D009484  30420200   ANDI V0, V0, 512
9D009488  1440FFFC   BNE V0, ZERO, 0x9D00947C
9D00948C  00000000   NOP
394:                         U1TXREG = (char)Buffer[bIndex++];
9D009490  93C20000   LBU V0, 0(S8)
9D009494  8FC30010   LW V1, 16(S8)
9D009498  00621021   ADDU V0, V1, V0
9D00949C  80420000   LB V0, 0(V0)
9D0094A0  00401821   ADDU V1, V0, ZERO
9D0094A4  3C02BF80   LUI V0, -16512
9D0094A8  AC436020   SW V1, 24608(V0)
9D0094AC  93C20000   LBU V0, 0(S8)
9D0094B0  24420001   ADDIU V0, V0, 1
9D0094B4  A3C20000   SB V0, 0(S8)
395:                 
396:                     }
397:                     bIndex = 0;
9D0094CC  A3C00000   SB ZERO, 0(S8)
398:                     return 1;
9D0094D0  24020001   ADDIU V0, ZERO, 1
399:                     /*
400:                     if(u1TXStatus == TXSTATUS_BUSY) return;// Busy transmitting other buffers
401:                     
402:                     IEC1bits.U2TXIE = 0;	// Disable TX interrupt
403:                     uInt dIndex = txAppIndex;
404:                     //uChar *chreceiveBuff = txreceiveBuff;
405:                     for(bIndex = 0;bIndex < Length;bIndex++)
406:                     {
407:                             if(dIndex + 1 != (FILE_BUFF_SZ - 1)) //make sure message in not overwriting self
408:                             {
409:                                     //*chreceiveBuff++ = *Buffer++;
410:                                     dIndex++;
411:                                     //dIndex &= (TX_BUFF_SZ - 1);	//modulus wrap;
412:                             }
413:                     }
414:                     txAppIndex = dIndex;
415:                     +
416:                     u1TXMode  = TXMODE_CHARS;
417:                     IFS1bits.U2TXIF = 1;// Set the interrupt flag
418:                     IEC1bits.U2TXIE = 1;// Enable interrupt for flag to work
419:                     return;
420:                 */
421:                 }
9D0094D4  03C0E821   ADDU SP, S8, ZERO
9D0094D8  8FBE000C   LW S8, 12(SP)
9D0094DC  27BD0010   ADDIU SP, SP, 16
9D0094E0  03E00008   JR RA
9D0094E4  00000000   NOP
422:                   /****************************************************************************
423:                 *   FUNCTION:       _U1TXInterrupt(void)                                    *
424:                 *                                                                           *
425:                 *   DESCRIPTION:    This function is the handler for the UART 2 Transmit    *
426:                 *                   interrupt, which is generated whenever the UART's       *
427:                 *                   Transmit Buffer is empty.  It checks to see whether     *
428:                 *                   more data is queued to send, and if so, loads the       *
429:                 *                   next available byte into the Transmit Buffer.  If       *
430:                 *                   no more data is left to send the routine turns off      *
431:                 *                   the Transmit interrupt.                                 *
432:                 *                                                                           *
433:                 *   PARAMETERS:     None                                                    *
434:                 *                                                                           *
435:                 *   RETURNS:        The function returns no value since it is an ISR.       *
436:                 *                                                                           *
437:                 *   REVISION:  0    v1.0                DATE:  1 October 2006               *
438:                 *       Original release.                                                   *
439:                 ****************************************************************************/
440:                 
441:                 void __attribute__((interrupt, auto_psv)) _U2TXInterrupt(void)
442:                 {
9D0094E8  415DE800   RDPGPR SP, SP
9D0094EC  401B7000   MFC0 K1, EPC
9D0094F0  401A6002   MFC0 K0, SRSCtl
9D0094F4  27BDFFE8   ADDIU SP, SP, -24
9D0094F8  AFBB0014   SW K1, 20(SP)
9D0094FC  401B6000   MFC0 K1, Status
9D009500  AFBA0010   SW K0, 16(SP)
9D009504  401A6800   MFC0 K0, Cause
9D009508  AFBB000C   SW K1, 12(SP)
9D00950C  001AD282   SRL K0, K0, 10
9D009510  7F5B7A84   INS K1, K0, 10, 6
9D009514  7C1B2044   INS K1, ZERO, 1, 4
9D009518  409B6000   MTC0 K1, Status
9D00951C  AFA30000   SW V1, 0(SP)
9D009520  AFA2FFFC   SW V0, -4(SP)
9D009524  8FA30010   LW V1, 16(SP)
9D009528  3063000F   ANDI V1, V1, 15
9D00952C  AFBE0004   SW S8, 4(SP)
9D009530  03A0F021   ADDU S8, SP, ZERO
443:                     /*
444:                     //  Local Variables
445:                     //if(txBuff == 0) return;
446:                     char receiveBuff;   // receiveBuff to transmit to UART     
447:                     uInt Index;  // Index of current slot in the global
448:                                                         //   Transmit receiveBuff Buffer to process
449:                     
450:                     //  Load the next character into the UART
451:                     
452:                    	Index = txISRIndex;   // Work with a temporary copy of the
453:                                                         //  buffer access index to avoid coherency                                   //   problems
454:                 	if(txType == TXTYPE_CHARS)
455:                 	{                                       
456:                             while ((Index != txAppIndex) && !U2STAbits.UTXBF)
457:                             {
458:                                 receiveBuff = txreceiveBuff[Index++];
459:                                 U2TXREG = receiveBuff;
460:                                 //Index &= (TX_BUFF_SZ - 1); // Perform a rapid modulo-COMM_TX_BUFF_SZ
461:                                                              //   calculation (assume power of 2)
462:                             }
463:                 	}
464:                 	if(txType == TXTYPE_INTS)
465:                 	{    
466:                 	
467:                             U2TXREG = IntsBuffer[Index]>>8;
468:                             lowByte = 1;
469:                             U2TXREG = IntsBuffer[Index++] & 0xFF;
470:                             lowByte = 0;
471:                             __builtin_btg( (unsigned int *)&LATA, 7 ); //Blink light for test
472:                 	}		 
473:                     
474:                         txISRIndex = Index;   // Log the updated buffer access index
475:                    	if(Index == txAppIndex) //All data sent
476:                    	{
477:                             IEC1bits.U2EIE = 1;
478:                             txISRIndex = 0;
479:                             txAppIndex =0;
480:                             txType = TXTYPE_NONE;
481:                 	}
482:                    	//  Clear the associated interrupt
483:                     //  flag to complete the ISR    
484:                    	IFS1bits.U2TXIF = 0;
485:                   */
486:                 }
9D009534  03C0E821   ADDU SP, S8, ZERO
9D009538  8FA20010   LW V0, 16(SP)
9D00953C  3042000F   ANDI V0, V0, 15
9D009540  8FBE0004   LW S8, 4(SP)
9D009544  8FA30000   LW V1, 0(SP)
9D009548  8FA2FFFC   LW V0, -4(SP)
9D00954C  41606000   DI ZERO
9D009550  000000C0   EHB
9D009554  8FBA0014   LW K0, 20(SP)
9D009558  8FBB000C   LW K1, 12(SP)
9D00955C  409A7000   MTC0 K0, EPC
9D009560  8FBA0010   LW K0, 16(SP)
9D009564  27BD0018   ADDIU SP, SP, 24
9D009568  409A6002   MTC0 K0, SRSCtl
9D00956C  41DDE800   WRPGPR SP, SP
9D009570  409B6000   MTC0 K1, Status
9D009574  42000018   ERET
487:                 
488:                 
489:                 void WriteCharU2(uChar receiveBuff)
490:                 {
9D009578  27BDFFF8   ADDIU SP, SP, -8
9D00957C  AFBE0004   SW S8, 4(SP)
9D009580  03A0F021   ADDU S8, SP, ZERO
9D009584  00801021   ADDU V0, A0, ZERO
9D009588  A3C20008   SB V0, 8(S8)
491:                 	U2TXREG = receiveBuff;
9D00958C  93C30008   LBU V1, 8(S8)
9D009590  3C02BF80   LUI V0, -16512
9D009594  AC436820   SW V1, 26656(V0)
492:                 	//IFS1bits.U2TXIF = 0;  
493:                 	
494:                 }
9D009598  03C0E821   ADDU SP, S8, ZERO
9D00959C  8FBE0004   LW S8, 4(SP)
9D0095A0  27BD0008   ADDIU SP, SP, 8
9D0095A4  03E00008   JR RA
9D0095A8  00000000   NOP
495:                 
496:                 void WriteCharsU2(uChar *Buffer, uInt Length)
497:                 {	/*
9D0095AC  27BDFFF8   ADDIU SP, SP, -8
9D0095B0  AFBE0004   SW S8, 4(SP)
9D0095B4  03A0F021   ADDU S8, SP, ZERO
9D0095B8  AFC40008   SW A0, 8(S8)
9D0095BC  AFC5000C   SW A1, 12(S8)
498:                 	if((Length+txAppIndex) > (TX_BUFF_SZ - 30))
499:                 	{
500:                 		//ErrorFlags = ERR_TXOVRFLOW;
501:                 		return ;
502:                 	}
503:                 	if(txType != TXTYPE_NONE) return;// Busy transmitting other buffers
504:                 	uChar bIndex;
505:                 	IEC1bits.U2TXIE = 0;	// Disable TX interrupt
506:                 	uInt dIndex = txAppIndex;
507:                 	uChar *chreceiveBuff = txreceiveBuff;		
508:                 	for(bIndex = 0;bIndex < Length;bIndex++)
509:                 	{
510:                 		if(dIndex + 1 != (TX_BUFF_SZ - 1)) //make sure message in not overwriting self
511:                 		{
512:                 			*chreceiveBuff++ = *Buffer++;
513:                 			dIndex++;
514:                 			//dIndex &= (TX_BUFF_SZ - 1);	//modulus wrap;
515:                 		}
516:                 	}
517:                 	txAppIndex = dIndex;
518:                 	!U2STAbits.UTXBF;	// Clear the buffer full flag in status register
519:                 	txType  = TXTYPE_CHARS;
520:                 	IFS1bits.U2TXIF = 1;// Set the interrupt flag	
521:                 	IEC1bits.U2TXIE = 1;// Enable interrupt for flag to work
522:                 	return;
523:                           * */
524:                 }
9D0095C0  03C0E821   ADDU SP, S8, ZERO
9D0095C4  8FBE0004   LW S8, 4(SP)
9D0095C8  27BD0008   ADDIU SP, SP, 8
9D0095CC  03E00008   JR RA
9D0095D0  00000000   NOP
525:                 	
526:                 void WriteIntsU2(uInt *Buffer, int Length)
527:                 {
9D0095D4  27BDFFF8   ADDIU SP, SP, -8
9D0095D8  AFBE0004   SW S8, 4(SP)
9D0095DC  03A0F021   ADDU S8, SP, ZERO
9D0095E0  AFC40008   SW A0, 8(S8)
9D0095E4  AFC5000C   SW A1, 12(S8)
528:                 	if(txAppIndex > 0) return;// ErrorFlags = ERR_TXOVRFLOW;
9D0095E8  8F8280E0   LW V0, -32544(GP)
9D0095EC  14400016   BNE V0, ZERO, 0x9D009648
9D0095F0  00000000   NOP
9D009648  00000000   NOP
529:                 	txISRIndex = 0;
9D0095F4  AF8080E4   SW ZERO, -32540(GP)
530:                 	IntsBuffer = Buffer;
9D0095F8  8FC20008   LW V0, 8(S8)
9D0095FC  AF828208   SW V0, -32248(GP)
531:                 	txAppIndex = Length;
9D009600  8FC2000C   LW V0, 12(S8)
9D009604  AF8280E0   SW V0, -32544(GP)
532:                 	!U2STAbits.UTXBF;	// Clear the buffer full flag in status register
9D009608  3C02BF80   LUI V0, -16512
9D00960C  8C426810   LW V0, 26640(V0)
533:                 	//txType  = TXTYPE_INTS;
534:                 	IFS1bits.U2TXIF = 1;// Set the interrupt flag	
9D009610  3C03BF88   LUI V1, -16504
9D009614  8C621040   LW V0, 4160(V1)
9D009618  24040001   ADDIU A0, ZERO, 1
9D00961C  7C825284   INS V0, A0, 10, 1
9D009620  AC621040   SW V0, 4160(V1)
535:                 	IEC1bits.U2EIE = 1;		// Enable interrupt for flag to work
9D009624  3C03BF88   LUI V1, -16504
9D009628  8C621070   LW V0, 4208(V1)
9D00962C  24040001   ADDIU A0, ZERO, 1
9D009630  7C824204   INS V0, A0, 8, 1
9D009634  AC621070   SW V0, 4208(V1)
536:                 	lowByte = 0;
9D009638  A3808224   SB ZERO, -32220(GP)
537:                 	return;
9D00963C  00000000   NOP
9D009640  0B402593   J 0x9D00964C
9D009644  00000000   NOP
538:                 	__builtin_btg( (unsigned int *)&LATA, 6 );
539:                 	
540:                 }
9D00964C  03C0E821   ADDU SP, S8, ZERO
9D009650  8FBE0004   LW S8, 4(SP)
9D009654  27BD0008   ADDIU SP, SP, 8
9D009658  03E00008   JR RA
9D00965C  00000000   NOP
541:                 
542:                 void ReadIntsU2(uInt *Buffer, uInt Length)
543:                 {
9D009660  27BDFFE8   ADDIU SP, SP, -24
9D009664  AFBF0014   SW RA, 20(SP)
9D009668  AFBE0010   SW S8, 16(SP)
9D00966C  03A0F021   ADDU S8, SP, ZERO
9D009670  AFC40018   SW A0, 24(S8)
9D009674  AFC5001C   SW A1, 28(S8)
544:                 	CheckU2(10); // Delay RX reset for 40mSec
9D009678  2404000A   ADDIU A0, ZERO, 10
9D00967C  0F4025C6   JAL CheckU2
9D009680  00000000   NOP
545:                 	rxFileLength = Length;
9D009684  8FC2001C   LW V0, 28(S8)
9D009688  3042FFFF   ANDI V0, V0, -1
9D00968C  A78280EA   SH V0, -32534(GP)
546:                 	fileBuff = Buffer;
9D009690  8FC20018   LW V0, 24(S8)
9D009694  AF828218   SW V0, -32232(GP)
547:                 	//u1RXState = u1RXState_INTS;
548:                 	rxISRIndex = 0;
9D009698  AF8080D4   SW ZERO, -32556(GP)
549:                 	lowByte = 0;
9D00969C  A3808224   SB ZERO, -32220(GP)
550:                 	return;	
551:                 }
9D0096A0  03C0E821   ADDU SP, S8, ZERO
9D0096A4  8FBF0014   LW RA, 20(SP)
9D0096A8  8FBE0010   LW S8, 16(SP)
9D0096AC  27BD0018   ADDIU SP, SP, 24
9D0096B0  03E00008   JR RA
9D0096B4  00000000   NOP
552:                 
553:                 
554:                 void ReadCharsU2(uChar *Buffer, uInt Length)
555:                 {
9D0096B8  27BDFFF8   ADDIU SP, SP, -8
9D0096BC  AFBE0004   SW S8, 4(SP)
9D0096C0  03A0F021   ADDU S8, SP, ZERO
9D0096C4  AFC40008   SW A0, 8(S8)
9D0096C8  AFC5000C   SW A1, 12(S8)
556:                 	//CheckUART2(6); // Delay RX reset for 50mSec
557:                 	rxFileLength = Length;
9D0096CC  8FC2000C   LW V0, 12(S8)
9D0096D0  3042FFFF   ANDI V0, V0, -1
9D0096D4  A78280EA   SH V0, -32534(GP)
558:                 	u1RXMode = RXMODE_CHARS;
9D0096D8  24020008   ADDIU V0, ZERO, 8
9D0096DC  A78280F8   SH V0, -32520(GP)
559:                 	rxISRIndex = 0;
9D0096E0  AF8080D4   SW ZERO, -32556(GP)
560:                 	return;	
561:                 }  
9D0096E4  03C0E821   ADDU SP, S8, ZERO
9D0096E8  8FBE0004   LW S8, 4(SP)
9D0096EC  27BD0008   ADDIU SP, SP, 8
9D0096F0  03E00008   JR RA
9D0096F4  00000000   NOP
562:                 
563:                 
564:                 	
565:                  /**********************************************************
566:                 *   FUNCTION:   CheckRX(int Delay)                                    
567:                 *	
568:                 *	Resets the receive system after Delay * 10mSec Time
569:                 *************************************************************/
570:                 void ResetMsgBuffU2(void)
571:                 {
9D0096F8  27BDFFF8   ADDIU SP, SP, -8
9D0096FC  AFBE0004   SW S8, 4(SP)
9D009700  03A0F021   ADDU S8, SP, ZERO
572:                     //msgIndex = 0; //reset message Index
573:                     //u2RXBuff[0] = 0; //clear command
574:                   	
575:                 }
9D009704  03C0E821   ADDU SP, S8, ZERO
9D009708  8FBE0004   LW S8, 4(SP)
9D00970C  27BD0008   ADDIU SP, SP, 8
9D009710  03E00008   JR RA
9D009714  00000000   NOP
576:                 
577:                 
578:                 void CheckU2(int Delay)
579:                 {
9D009718  27BDFFF8   ADDIU SP, SP, -8
9D00971C  AFBE0004   SW S8, 4(SP)
9D009720  03A0F021   ADDU S8, SP, ZERO
9D009724  AFC40008   SW A0, 8(S8)
580:                 	delay += Delay;
9D009728  8F8380C8   LW V1, -32568(GP)
9D00972C  8FC20008   LW V0, 8(S8)
9D009730  00621021   ADDU V0, V1, V0
9D009734  AF8280C8   SW V0, -32568(GP)
581:                 	if(u2RXStatus > RX_IDLE)
9D009738  97828204   LHU V0, -32252(GP)
9D00973C  10400021   BEQ V0, ZERO, 0x9D0097C4
9D009740  00000000   NOP
582:                 	{
583:                 		//LATA |= 0x20;
584:                 		if(delay <= 0)
9D009744  8F8280C8   LW V0, -32568(GP)
9D009748  14400018   BNE V0, ZERO, 0x9D0097AC
9D00974C  00000000   NOP
585:                 		{
586:                                     u1RXIndex = 0;
9D009750  AF8080D8   SW ZERO, -32552(GP)
587:                                     //rxAppIndex = 0;
588:                 		    rxISRIndex = 0; 
9D009754  AF8080D4   SW ZERO, -32556(GP)
589:                 		    //rxreceiveBuff[0] = 0;
590:                 		    U2MODEbits.UARTEN = 1;
9D009758  3C03BF80   LUI V1, -16512
9D00975C  8C626800   LW V0, 26624(V1)
9D009760  24040001   ADDIU A0, ZERO, 1
9D009764  7C827BC4   INS V0, A0, 15, 1
9D009768  AC626800   SW V0, 26624(V1)
591:                 		    u2RXStatus =  RX_IDLE;
9D00976C  A7808204   SH ZERO, -32252(GP)
592:                 		    u2RXMode = RXMODE_CMD;
9D009770  A7808210   SH ZERO, -32240(GP)
593:                 		    IEC1bits.U2RXIE = 1; ;
9D009774  3C03BF88   LUI V1, -16504
9D009778  8C621070   LW V0, 4208(V1)
9D00977C  24040001   ADDIU A0, ZERO, 1
9D009780  7C824A44   INS V0, A0, 9, 1
9D009784  AC621070   SW V0, 4208(V1)
594:                 		    IFS1bits.U2RXIF = 0;
9D009788  3C03BF88   LUI V1, -16504
9D00978C  8C621040   LW V0, 4160(V1)
9D009790  7C024A44   INS V0, ZERO, 9, 1
9D009794  AC621040   SW V0, 4160(V1)
595:                                     U2STAbits.OERR = 0;
9D009798  3C03BF80   LUI V1, -16512
9D00979C  8C626810   LW V0, 26640(V1)
9D0097A0  7C020844   INS V0, ZERO, 1, 1
9D0097A4  AC626810   SW V0, 26640(V1)
596:                                     delay = 0;
9D0097A8  AF8080C8   SW ZERO, -32568(GP)
597:                                     //LATA &= ~0x60;
598:                 		}
599:                 		if(delay > 0) delay--;	
9D0097AC  8F8280C8   LW V0, -32568(GP)
9D0097B0  10400004   BEQ V0, ZERO, 0x9D0097C4
9D0097B4  00000000   NOP
9D0097B8  8F8280C8   LW V0, -32568(GP)
9D0097BC  2442FFFF   ADDIU V0, V0, -1
9D0097C0  AF8280C8   SW V0, -32568(GP)
600:                 	}		
601:                 }
9D0097C4  03C0E821   ADDU SP, S8, ZERO
9D0097C8  8FBE0004   LW S8, 4(SP)
9D0097CC  27BD0008   ADDIU SP, SP, 8
9D0097D0  03E00008   JR RA
9D0097D4  00000000   NOP
602:                 /****************************************************************************
603:                 *   FUNCTION:       _U1RXInterrupt(void)                                    *
604:                 *                                                                           *
605:                 *   DESCRIPTION:    This function is the handler for the Receive receiveBuff       *
606:                 *                   Ready interrupt for UART 1.  It reads the received      *
607:                 *                   data from the UART and stores it in the global          *
608:                 *                   Receive receiveBuff Buffer if there is room.                   *
609:                 *                                                                           *
610:                 *
611:                 *                                                        *
612:                 ****************************************************************************/
613:                 
614:                 void __attribute__((interrupt, auto_psv))_U2RXInterrupt(void)
615:                 {
9D0097D8  415DE800   RDPGPR SP, SP
9D0097DC  401B7000   MFC0 K1, EPC
9D0097E0  401A6002   MFC0 K0, SRSCtl
9D0097E4  27BDFFE8   ADDIU SP, SP, -24
9D0097E8  AFBB0014   SW K1, 20(SP)
9D0097EC  401B6000   MFC0 K1, Status
9D0097F0  AFBA0010   SW K0, 16(SP)
9D0097F4  401A6800   MFC0 K0, Cause
9D0097F8  AFBB000C   SW K1, 12(SP)
9D0097FC  001AD282   SRL K0, K0, 10
9D009800  7F5B7A84   INS K1, K0, 10, 6
9D009804  7C1B2044   INS K1, ZERO, 1, 4
9D009808  409B6000   MTC0 K1, Status
9D00980C  AFA30000   SW V1, 0(SP)
9D009810  AFA2FFFC   SW V0, -4(SP)
9D009814  8FA30010   LW V1, 16(SP)
9D009818  3063000F   ANDI V1, V1, 15
9D00981C  AFBE0004   SW S8, 4(SP)
9D009820  03A0F021   ADDU S8, SP, ZERO
616:                   
617:                 };
9D009824  03C0E821   ADDU SP, S8, ZERO
9D009828  8FA20010   LW V0, 16(SP)
9D00982C  3042000F   ANDI V0, V0, 15
9D009830  8FBE0004   LW S8, 4(SP)
9D009834  8FA30000   LW V1, 0(SP)
9D009838  8FA2FFFC   LW V0, -4(SP)
9D00983C  41606000   DI ZERO
9D009840  000000C0   EHB
9D009844  8FBA0014   LW K0, 20(SP)
9D009848  8FBB000C   LW K1, 12(SP)
9D00984C  409A7000   MTC0 K0, EPC
9D009850  8FBA0010   LW K0, 16(SP)
9D009854  27BD0018   ADDIU SP, SP, 24
9D009858  409A6002   MTC0 K0, SRSCtl
9D00985C  41DDE800   WRPGPR SP, SP
9D009860  409B6000   MTC0 K1, Status
9D009864  42000018   ERET
618:                 
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/systime_date.c  --------------------------------------------
1:                   /****************************************************************************
2:                   *          	               *
3:                   *                                                                           *
4:                   *   FILE:           systime_date.c                                                 *
5:                   *                                                                           *
6:                   *   DESCRIPTION:    T1 timer with interrupt configured for 2 mSec         *
7:                   *                                                                           *
8:                   *   REVISION:  0    v1.0                DATE:  1 October 2009              *
9:                   *       Original release.                                                   *
10:                  ****************************************************************************/
11:                  
12:                                                  /*******************
13:                                                  **  Header Files  **
14:                                                  *******************/
15:                  
16:                  
17:                  #include <plib.h>
18:                  #include "../systime_date.h"       // Timer interface definitions
19:                  #include "../sysglobals.h"
20:                  //#include "../digital.h"
21:                  
22:                  //#include "protocols.h"
23:                  
24:                                              /***********************
25:                                              **  Global Variables  **
26:                                              ***********************/
27:                  //#define LED_STATE_OFF 0   // Image of Hardware LED state
28:                  
29:                  //volatile uChar HWErrLEDImage = LED_STATE_OFF; 
30:                  SysClock Time;
31:                   //TODO: Remove onTime  and the need for it.
32:                  //sInt onTime = 1;
33:                  uInt	time2ChckPrgm,			// Number of mSec between T1 interrupts
34:                  	AccumulatedTime = 0,  	// Blade count accumulation time
35:                      	BlinkCount       = 0, 	// LED blink period counter
36:                      	Timer100mSec     = 0; 	// 100 msec system timer counter
37:                  /*********************************************************************************************
38:                   *                                          MENU ROUTINES
39:                   *********************************************************************************************/
40:                  char* ConfigRTC(char* cBuff, char keyPress)
41:                  {
9D012934  27BDFFE8   ADDIU SP, SP, -24
9D012938  AFBF0014   SW RA, 20(SP)
9D01293C  AFBE0010   SW S8, 16(SP)
9D012940  03A0F021   ADDU S8, SP, ZERO
9D012944  AFC40018   SW A0, 24(S8)
9D012948  00A01021   ADDU V0, A1, ZERO
9D01294C  A3C2001C   SB V0, 28(S8)
42:                      if(keyPress < 0)
9D012950  83C2001C   LB V0, 28(S8)
9D012954  0441000A   BGEZ V0, 0x9D012980
9D012958  00000000   NOP
43:                      {
44:                          sprintf(cBuff,"\x1B[2J\x1B[H !* Set Date/Time *!\r\n \
9D01295C  8FC40018   LW A0, 24(S8)
9D012960  3C029D02   LUI V0, -25342
9D012964  24458EF4   ADDIU A1, V0, -28940
9D012968  2406003E   ADDIU A2, ZERO, 62
9D01296C  0F405AA3   JAL 0x9D016A8C
9D012970  00000000   NOP
45:                  \t1 - Set Date\r\n \
46:                  \t2 - Set Time\r\n");
47:                          return cBuff;
9D012974  8FC20018   LW V0, 24(S8)
9D012978  0B404A73   J 0x9D0129CC
9D01297C  00000000   NOP
48:                      }
49:                      if(keyPress == 1)
9D012980  83C3001C   LB V1, 28(S8)
9D012984  24020001   ADDIU V0, ZERO, 1
9D012988  14620005   BNE V1, V0, 0x9D0129A0
9D01298C  00000000   NOP
50:                      {
51:                          SetMenuPage(WiFiConfigMenu);
9D012990  3C029D01   LUI V0, -25343
9D012994  244464B8   ADDIU A0, V0, 25784
9D012998  0F40173E   JAL SetMenuPage
9D01299C  00000000   NOP
52:                      }
53:                      if(keyPress ==2)
9D0129A0  83C3001C   LB V1, 28(S8)
9D0129A4  24020002   ADDIU V0, ZERO, 2
9D0129A8  14620005   BNE V1, V0, 0x9D0129C0
9D0129AC  00000000   NOP
54:                      {
55:                          SetMenuPage(WiFiConfigDHCP);
9D0129B0  3C029D01   LUI V0, -25343
9D0129B4  244465CC   ADDIU A0, V0, 26060
9D0129B8  0F40173E   JAL SetMenuPage
9D0129BC  00000000   NOP
56:                      }
57:                      cBuff[0] = 0x00;
9D0129C0  8FC20018   LW V0, 24(S8)
9D0129C4  A0400000   SB ZERO, 0(V0)
58:                      return cBuff;
9D0129C8  8FC20018   LW V0, 24(S8)
59:                  }
9D0129CC  03C0E821   ADDU SP, S8, ZERO
9D0129D0  8FBF0014   LW RA, 20(SP)
9D0129D4  8FBE0010   LW S8, 16(SP)
9D0129D8  27BD0018   ADDIU SP, SP, 24
9D0129DC  03E00008   JR RA
9D0129E0  00000000   NOP
60:                  char* ConfigTimeDate(char* cBuff, char keyPress)
61:                  {
9D0129E4  27BDFFE8   ADDIU SP, SP, -24
9D0129E8  AFBF0014   SW RA, 20(SP)
9D0129EC  AFBE0010   SW S8, 16(SP)
9D0129F0  03A0F021   ADDU S8, SP, ZERO
9D0129F4  AFC40018   SW A0, 24(S8)
9D0129F8  00A01021   ADDU V0, A1, ZERO
9D0129FC  A3C2001C   SB V0, 28(S8)
62:                      if(keyPress < 0)
9D012A00  83C2001C   LB V0, 28(S8)
9D012A04  0441000A   BGEZ V0, 0x9D012A30
9D012A08  00000000   NOP
63:                      {
64:                          sprintf(cBuff,"\x1B[2J\x1B[H !* Set Date/Time *!\r\n \
9D012A0C  8FC40018   LW A0, 24(S8)
9D012A10  3C029D02   LUI V0, -25342
9D012A14  24458EF4   ADDIU A1, V0, -28940
9D012A18  2406003E   ADDIU A2, ZERO, 62
9D012A1C  0F405AA3   JAL 0x9D016A8C
9D012A20  00000000   NOP
65:                  \t1 - Set Date\r\n \
66:                  \t2 - Set Time\r\n");
67:                          return cBuff;
9D012A24  8FC20018   LW V0, 24(S8)
9D012A28  0B404A9F   J 0x9D012A7C
9D012A2C  00000000   NOP
68:                      }
69:                      if(keyPress == 1)
9D012A30  83C3001C   LB V1, 28(S8)
9D012A34  24020001   ADDIU V0, ZERO, 1
9D012A38  14620005   BNE V1, V0, 0x9D012A50
9D012A3C  00000000   NOP
70:                      {
71:                          SetMenuPage(WiFiConfigMenu);
9D012A40  3C029D01   LUI V0, -25343
9D012A44  244464B8   ADDIU A0, V0, 25784
9D012A48  0F40173E   JAL SetMenuPage
9D012A4C  00000000   NOP
72:                      }
73:                      if(keyPress ==2)
9D012A50  83C3001C   LB V1, 28(S8)
9D012A54  24020002   ADDIU V0, ZERO, 2
9D012A58  14620005   BNE V1, V0, 0x9D012A70
9D012A5C  00000000   NOP
74:                      {
75:                          SetMenuPage(WiFiConfigDHCP);
9D012A60  3C029D01   LUI V0, -25343
9D012A64  244465CC   ADDIU A0, V0, 26060
9D012A68  0F40173E   JAL SetMenuPage
9D012A6C  00000000   NOP
76:                      }
77:                      cBuff[0] = 0x00;
9D012A70  8FC20018   LW V0, 24(S8)
9D012A74  A0400000   SB ZERO, 0(V0)
78:                      return cBuff;
9D012A78  8FC20018   LW V0, 24(S8)
79:                  }
9D012A7C  03C0E821   ADDU SP, S8, ZERO
9D012A80  8FBF0014   LW RA, 20(SP)
9D012A84  8FBE0010   LW S8, 16(SP)
9D012A88  27BD0018   ADDIU SP, SP, 24
9D012A8C  03E00008   JR RA
9D012A90  00000000   NOP
80:                  /****************** CLOCK TIMER 1 SETUP ********************
81:                  *	This configures timer 1 as a 1 mSec resolution timer
82:                  *	which interrupts on time out
83:                  *	This timer can also be configured to be a RTC
84:                  *   Checked for accuracy on 1/16/2011
85:                  *********************************************************/
86:                  
87:                  void InitSysTime(void)
88:                  {
9D012A94  27BDFFE8   ADDIU SP, SP, -24
9D012A98  AFBF0014   SW RA, 20(SP)
9D012A9C  AFBE0010   SW S8, 16(SP)
9D012AA0  03A0F021   ADDU S8, SP, ZERO
89:                  #ifndef __PIC32MX__ 
90:                  	time2ChckPrgm = 1; // Sets the default time to check for lockups to 1 mSec	
91:                  	_T1IP = 2; //SET TIMER 1 INTERRUPT PRIORITY
92:                  	T1CONbits.TON=0;//	TURN OFF T1
93:                  	TMR1 = 0; // CLEAR TIMER	
94:                  	T1CONbits.TCKPS = 3; //SET PRESCALE TO 256  
95:                  	PR1 =  156; //SET PERIOD TIMEOUT TO 1mSEC	
96:                  	T1CONbits.TON=1;//	TURN ON T1
97:                  	_T1IF = 0; // CLEAR TMR1 INTERRUPT FLAG
98:                  	_T1IE = 1; // ENABLE TMR1 INTERRUPT	
99:                  	Time.Hours = 0;
100:                 	Time.Minutes = 0;
101:                 	Time.Seconds = 0;
102:                 	Time.mSeconds = 0;
103:                 #endif
104:                 #ifdef __PIC32MX__
105:                     
106:                     OpenCoreTimer(CORE_TICK_RATE);
9D012AA4  34049C40   ORI A0, ZERO, -25536
9D012AA8  0F4065C7   JAL OpenCoreTimer
9D012AAC  00000000   NOP
107:                     // set up the core timer interrupt with a prioirty of 2 and zero sub-priority
108:                     mConfigIntCoreTimer((CT_INT_ON | CT_INT_PRIOR_2 | CT_INT_SUB_PRIOR_0));
9D012AB0  3C02BF88   LUI V0, -16504
9D012AB4  24030001   ADDIU V1, ZERO, 1
9D012AB8  AC431034   SW V1, 4148(V0)
9D012ABC  3C02BF88   LUI V0, -16504
9D012AC0  2403001C   ADDIU V1, ZERO, 28
9D012AC4  AC431094   SW V1, 4244(V0)
9D012AC8  3C02BF88   LUI V0, -16504
9D012ACC  24030008   ADDIU V1, ZERO, 8
9D012AD0  AC431098   SW V1, 4248(V0)
9D012AD4  3C02BF88   LUI V0, -16504
9D012AD8  24030003   ADDIU V1, ZERO, 3
9D012ADC  AC431094   SW V1, 4244(V0)
9D012AE0  3C02BF88   LUI V0, -16504
9D012AE4  AC401098   SW ZERO, 4248(V0)
9D012AE8  3C02BF88   LUI V0, -16504
9D012AEC  24030001   ADDIU V1, ZERO, 1
9D012AF0  AC431064   SW V1, 4196(V0)
9D012AF4  3C02BF88   LUI V0, -16504
9D012AF8  24030001   ADDIU V1, ZERO, 1
9D012AFC  AC431068   SW V1, 4200(V0)
109:                     // configure pins for LEDs
110:                     PORTSetPinsDigitalOut(IOPORT_A, BIT_0 | BIT_1); //JK Added  for LEDs10/11/12
9D012B00  00002021   ADDU A0, ZERO, ZERO
9D012B04  24050003   ADDIU A1, ZERO, 3
9D012B08  0F4063ED   JAL PORTSetPinsDigitalOut
9D012B0C  00000000   NOP
111:                     PORTSetBits(IOPORT_A, BIT_1);
9D012B10  00002021   ADDU A0, ZERO, ZERO
9D012B14  24050002   ADDIU A1, ZERO, 2
9D012B18  0F406524   JAL PORTSetBits
9D012B1C  00000000   NOP
112:                     // enable device multi-vector interrupts
113:                     INTEnableSystemMultiVectoredInt();
9D012B20  0F406436   JAL INTEnableSystemMultiVectoredInt
9D012B24  00000000   NOP
114:                     Time.Hours = 0;
9D012B28  A38081F0   SB ZERO, -32272(GP)
115:                     Time.Minutes = 0;
9D012B2C  A38081F1   SB ZERO, -32271(GP)
116:                     Time.Seconds = 0;
9D012B30  A38081F2   SB ZERO, -32270(GP)
117:                     Time.mSeconds = 0;
9D012B34  AF8081F4   SW ZERO, -32268(GP)
118:                  #endif   
119:                 	
120:                 	//******************* END TIMER 1 SETUP ***************************
121:                 }  
9D012B38  03C0E821   ADDU SP, S8, ZERO
9D012B3C  8FBF0014   LW RA, 20(SP)
9D012B40  8FBE0010   LW S8, 16(SP)
9D012B44  27BD0018   ADDIU SP, SP, 24
9D012B48  03E00008   JR RA
9D012B4C  00000000   NOP
122:                 
123:                 #ifndef __PIC32MX__ 
124:                 //1/16/2011: T1 interrupt was check on a PIC33 to make sure time base was accurate.
125:                 void __attribute__((interrupt, auto_psv)) _T1Interrupt(void)
126:                 {
127:                 
128:                 	TMR1 = 0;
129:                 	Time.mSeconds ++;
130:                 	MachineState |= sys_CHCKSYSTEM; // Do Housekeeping
131:                 	if(Time.mSeconds > 999)
132:                 	{	
133:                 		Time.mSeconds = 0;
134:                 		Time.Seconds++;
135:                 		if(Time.Seconds > 59)
136:                 		{
137:                                     Time.Seconds = 0;
138:                                     Time.Minutes++;
139:                                     if(Time.Hours >= 23) Time.Hours = 0;
140:                 		}		
141:                 	}
142:                 	_T1IF = 0; // CLEAR TMR1 INTERRUPT FLAG						
143:                 }; 
144:                 #endif
145:                 
146:                 
147:                 #ifdef __PIC32MX__ 
148:                 void __ISR(_CORE_TIMER_VECTOR, ipl2) CoreTimerHandler(void)
149:                 {
9D012B50  415DE800   RDPGPR SP, SP
9D012B54  401A7000   MFC0 K0, EPC
9D012B58  401B6000   MFC0 K1, Status
9D012B5C  27BDFF90   ADDIU SP, SP, -112
9D012B60  AFBA006C   SW K0, 108(SP)
9D012B64  AFBB0068   SW K1, 104(SP)
9D012B68  7C1B7844   INS K1, ZERO, 1, 15
9D012B6C  377B0800   ORI K1, K1, 2048
9D012B70  409B6000   MTC0 K1, Status
9D012B74  AFBF005C   SW RA, 92(SP)
9D012B78  AFBE0058   SW S8, 88(SP)
9D012B7C  AFB90054   SW T9, 84(SP)
9D012B80  AFB80050   SW T8, 80(SP)
9D012B84  AFAF004C   SW T7, 76(SP)
9D012B88  AFAE0048   SW T6, 72(SP)
9D012B8C  AFAD0044   SW T5, 68(SP)
9D012B90  AFAC0040   SW T4, 64(SP)
9D012B94  AFAB003C   SW T3, 60(SP)
9D012B98  AFAA0038   SW T2, 56(SP)
9D012B9C  AFA90034   SW T1, 52(SP)
9D012BA0  AFA80030   SW T0, 48(SP)
9D012BA4  AFA7002C   SW A3, 44(SP)
9D012BA8  AFA60028   SW A2, 40(SP)
9D012BAC  AFA50024   SW A1, 36(SP)
9D012BB0  AFA40020   SW A0, 32(SP)
9D012BB4  AFA3001C   SW V1, 28(SP)
9D012BB8  AFA20018   SW V0, 24(SP)
9D012BBC  AFA10014   SW AT, 20(SP)
9D012BC0  00001012   MFLO V0
9D012BC4  AFA20064   SW V0, 100(SP)
9D012BC8  00001810   MFHI V1
9D012BCC  AFA30060   SW V1, 96(SP)
9D012BD0  03A0F021   ADDU S8, SP, ZERO
150:                     // clear the interrupt flag
151:                     Time.mSeconds ++;
9D012BD4  8F8281F4   LW V0, -32268(GP)
9D012BD8  24420001   ADDIU V0, V0, 1
9D012BDC  AF8281F4   SW V0, -32268(GP)
152:                     MachineState |= sys_CHCKSYSTEM; // Do Housekeeping
9D012BE0  8F828278   LW V0, -32136(GP)
9D012BE4  34420001   ORI V0, V0, 1
9D012BE8  AF828278   SW V0, -32136(GP)
153:                     if(Time.mSeconds > 999)
9D012BEC  8F8281F4   LW V0, -32268(GP)
9D012BF0  2C4203E8   SLTIU V0, V0, 1000
9D012BF4  1440001D   BNE V0, ZERO, 0x9D012C6C
9D012BF8  00000000   NOP
154:                     { 
155:                         Time.mSeconds = 0;
9D012BFC  AF8081F4   SW ZERO, -32268(GP)
156:                         Time.Seconds++;
9D012C00  938281F2   LBU V0, -32270(GP)
9D012C04  24420001   ADDIU V0, V0, 1
9D012C08  304200FF   ANDI V0, V0, 255
9D012C0C  A38281F2   SB V0, -32270(GP)
157:                         if(Time.Seconds > 59)
9D012C10  938281F2   LBU V0, -32270(GP)
9D012C14  2C42003C   SLTIU V0, V0, 60
9D012C18  14400006   BNE V0, ZERO, 0x9D012C34
9D012C1C  00000000   NOP
158:                         {
159:                             Time.Seconds = 0;
9D012C20  A38081F2   SB ZERO, -32270(GP)
160:                             Time.Minutes++;         
9D012C24  938281F1   LBU V0, -32271(GP)
9D012C28  24420001   ADDIU V0, V0, 1
9D012C2C  304200FF   ANDI V0, V0, 255
9D012C30  A38281F1   SB V0, -32271(GP)
161:                         }
162:                         if(Time.Minutes > 59)
9D012C34  938281F1   LBU V0, -32271(GP)
9D012C38  2C42003C   SLTIU V0, V0, 60
9D012C3C  1440000B   BNE V0, ZERO, 0x9D012C6C
9D012C40  00000000   NOP
163:                         {
164:                             Time.Minutes = 0;
9D012C44  A38081F1   SB ZERO, -32271(GP)
165:                             Time.Hours++;
9D012C48  938281F0   LBU V0, -32272(GP)
9D012C4C  24420001   ADDIU V0, V0, 1
9D012C50  304200FF   ANDI V0, V0, 255
9D012C54  A38281F0   SB V0, -32272(GP)
166:                             if(Time.Hours >= 23) Time.Hours = 0;        
9D012C58  938281F0   LBU V0, -32272(GP)
9D012C5C  2C420017   SLTIU V0, V0, 23
9D012C60  14400002   BNE V0, ZERO, 0x9D012C6C
9D012C64  00000000   NOP
9D012C68  A38081F0   SB ZERO, -32272(GP)
167:                         }
168:                     }
169:                     UpdateCoreTimer(CORE_TICK_RATE);
9D012C6C  34049C40   ORI A0, ZERO, -25536
9D012C70  0F4065BB   JAL UpdateCoreTimer
9D012C74  00000000   NOP
170:                     mCTClearIntFlag();
9D012C78  3C02BF88   LUI V0, -16504
9D012C7C  24030001   ADDIU V1, ZERO, 1
9D012C80  AC431034   SW V1, 4148(V0)
171:                 }
9D012C84  03C0E821   ADDU SP, S8, ZERO
9D012C88  8FA20064   LW V0, 100(SP)
9D012C8C  00400013   MTLO V0
9D012C90  8FA30060   LW V1, 96(SP)
9D012C94  00600011   MTHI V1
9D012C98  8FBF005C   LW RA, 92(SP)
9D012C9C  8FBE0058   LW S8, 88(SP)
9D012CA0  8FB90054   LW T9, 84(SP)
9D012CA4  8FB80050   LW T8, 80(SP)
9D012CA8  8FAF004C   LW T7, 76(SP)
9D012CAC  8FAE0048   LW T6, 72(SP)
9D012CB0  8FAD0044   LW T5, 68(SP)
9D012CB4  8FAC0040   LW T4, 64(SP)
9D012CB8  8FAB003C   LW T3, 60(SP)
9D012CBC  8FAA0038   LW T2, 56(SP)
9D012CC0  8FA90034   LW T1, 52(SP)
9D012CC4  8FA80030   LW T0, 48(SP)
9D012CC8  8FA7002C   LW A3, 44(SP)
9D012CCC  8FA60028   LW A2, 40(SP)
9D012CD0  8FA50024   LW A1, 36(SP)
9D012CD4  8FA40020   LW A0, 32(SP)
9D012CD8  8FA3001C   LW V1, 28(SP)
9D012CDC  8FA20018   LW V0, 24(SP)
9D012CE0  8FA10014   LW AT, 20(SP)
9D012CE4  41606000   DI ZERO
9D012CE8  000000C0   EHB
9D012CEC  8FBA006C   LW K0, 108(SP)
9D012CF0  8FBB0068   LW K1, 104(SP)
9D012CF4  409A7000   MTC0 K0, EPC
9D012CF8  27BD0070   ADDIU SP, SP, 112
9D012CFC  41DDE800   WRPGPR SP, SP
9D012D00  409B6000   MTC0 K1, Status
9D012D04  42000018   ERET
172:                 #endif
173:                 
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/sys_inputs.c  ----------------------------------------------
1:                   #include "../sys_inputs.h"
2:                   a_Input sysInputChannel[3];
3:                   uChar sysInputIndex = 0;
4:                   
5:                   char* ConfigSystemInputs(char* cBuff, char keyPress)
6:                   {
9D017018  27BDFFE8   ADDIU SP, SP, -24
9D01701C  AFBF0014   SW RA, 20(SP)
9D017020  AFBE0010   SW S8, 16(SP)
9D017024  03A0F021   ADDU S8, SP, ZERO
9D017028  AFC40018   SW A0, 24(S8)
9D01702C  00A01021   ADDU V0, A1, ZERO
9D017030  A3C2001C   SB V0, 28(S8)
7:                       if(keyPress < 0)
9D017034  83C2001C   LB V0, 28(S8)
9D017038  0441000A   BGEZ V0, 0x9D017064
9D01703C  00000000   NOP
8:                       {
9:                           sprintf(cBuff,"*! ADC Configuration !*\r\n \
9D017040  8FC40018   LW A0, 24(S8)
9D017044  3C029D02   LUI V0, -25342
9D017048  24458484   ADDIU A1, V0, -31612
9D01704C  24060042   ADDIU A2, ZERO, 66
9D017050  0F405AA3   JAL 0x9D016A8C
9D017054  00000000   NOP
10:                  1-Channel 1\r\n \
11:                  2-Channel 2\r\n \
12:                  3-Channel 3");
13:                          return cBuff;
9D017058  8FC20018   LW V0, 24(S8)
9D01705C  0B405C29   J 0x9D0170A4
9D017060  00000000   NOP
14:                      }
15:                      if(keyPress >=1 && keyPress <= 3)
9D017064  83C2001C   LB V0, 28(S8)
9D017068  1840000B   BLEZ V0, 0x9D017098
9D01706C  00000000   NOP
9D017070  83C2001C   LB V0, 28(S8)
9D017074  28420004   SLTI V0, V0, 4
9D017078  10400007   BEQ V0, ZERO, 0x9D017098
9D01707C  00000000   NOP
16:                      {
17:                          sysInputIndex = keyPress;
9D017080  93C2001C   LBU V0, 28(S8)
9D017084  A38280B8   SB V0, -32584(GP)
18:                          SetMenuPage(ConfigChannel);
9D017088  3C029D01   LUI V0, -25343
9D01708C  244470BC   ADDIU A0, V0, 28860
9D017090  0F40173E   JAL SetMenuPage
9D017094  00000000   NOP
19:                      }
20:                  
21:                      cBuff[0] = 0x00;
9D017098  8FC20018   LW V0, 24(S8)
9D01709C  A0400000   SB ZERO, 0(V0)
22:                      return cBuff;
9D0170A0  8FC20018   LW V0, 24(S8)
23:                  }
9D0170A4  03C0E821   ADDU SP, S8, ZERO
9D0170A8  8FBF0014   LW RA, 20(SP)
9D0170AC  8FBE0010   LW S8, 16(SP)
9D0170B0  27BD0018   ADDIU SP, SP, 24
9D0170B4  03E00008   JR RA
9D0170B8  00000000   NOP
24:                  
25:                  
26:                  char* ConfigChannel(char* cBuff, char keyPress)
27:                  {
9D0170BC  27BDFFE8   ADDIU SP, SP, -24
9D0170C0  AFBF0014   SW RA, 20(SP)
9D0170C4  AFBE0010   SW S8, 16(SP)
9D0170C8  03A0F021   ADDU S8, SP, ZERO
9D0170CC  AFC40018   SW A0, 24(S8)
9D0170D0  00A01021   ADDU V0, A1, ZERO
9D0170D4  A3C2001C   SB V0, 28(S8)
28:                      if(keyPress < 0)
9D0170D8  83C2001C   LB V0, 28(S8)
9D0170DC  0441000B   BGEZ V0, 0x9D01710C
9D0170E0  00000000   NOP
29:                      {
30:                          sprintf(cBuff,"!*SysInput Channel %d*!\r\n \
9D0170E4  938280B8   LBU V0, -32584(GP)
9D0170E8  8FC40018   LW A0, 24(S8)
9D0170EC  3C039D02   LUI V1, -25342
9D0170F0  246584C8   ADDIU A1, V1, -31544
9D0170F4  00403021   ADDU A2, V0, ZERO
9D0170F8  0F40627D   JAL sprintf
9D0170FC  00000000   NOP
31:                  1-Current Settings\r\n \
32:                  2-Run Configurator\r\n",sysInputIndex);
33:                          return cBuff;
9D017100  8FC20018   LW V0, 24(S8)
9D017104  0B405C56   J 0x9D017158
9D017108  00000000   NOP
34:                      }
35:                      if(keyPress == 1)
9D01710C  83C3001C   LB V1, 28(S8)
9D017110  24020001   ADDIU V0, ZERO, 1
9D017114  14620005   BNE V1, V0, 0x9D01712C
9D017118  00000000   NOP
36:                      {
37:                          SetMenuPage(WiFiConfigMenu);
9D01711C  3C029D01   LUI V0, -25343
9D017120  244464B8   ADDIU A0, V0, 25784
9D017124  0F40173E   JAL SetMenuPage
9D017128  00000000   NOP
38:                      }
39:                      if(keyPress ==2)
9D01712C  83C3001C   LB V1, 28(S8)
9D017130  24020002   ADDIU V0, ZERO, 2
9D017134  14620005   BNE V1, V0, 0x9D01714C
9D017138  00000000   NOP
40:                      {
41:                          SetMenuPage(WiFiConfigDHCP);
9D01713C  3C029D01   LUI V0, -25343
9D017140  244465CC   ADDIU A0, V0, 26060
9D017144  0F40173E   JAL SetMenuPage
9D017148  00000000   NOP
42:                      }
43:                      cBuff[0] = 0x00;
9D01714C  8FC20018   LW V0, 24(S8)
9D017150  A0400000   SB ZERO, 0(V0)
44:                      return cBuff;
9D017154  8FC20018   LW V0, 24(S8)
45:                  }
9D017158  03C0E821   ADDU SP, S8, ZERO
9D01715C  8FBF0014   LW RA, 20(SP)
9D017160  8FBE0010   LW S8, 16(SP)
9D017164  27BD0018   ADDIU SP, SP, 24
9D017168  03E00008   JR RA
9D01716C  00000000   NOP
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/spi_memory.c  ----------------------------------------------
1:                   //#include "modbus.h"
2:                   //#include "p33FJ256GP710.h"
3:                   #include "../sysglobals.h"
4:                   #include "../spi_memory.h"
5:                   #include <plib.h>
6:                   //#include "../spi.h"
7:                   
8:                   uShort 	sIndex; // Used in writing arrays to pages, no page is > 256
9:                   uInt 	*iNVBuff = 0; //Pointer to hold address to pending signed int array operations
10:                  uChar	*cNVBuff = 0; //Pointer to hold address to pending uChar array operations
11:                  long 	*lNVBuff = 0; // Pointer to buffer of longs for flash chips
12:                  float	*fNVBuff = 0; //Pointer to hold address to pending uDbl array operations
13:                  uInt 	nvMemStatus;
14:                  long	nextAddress2Write; //Holds the next non volital memory addres to be written
15:                  volatile uInt	numberRemaining; //Number of numbers(any type) left to write
16:                  //volatile uInt
17:                  
18:                  uChar   mDevice0, mDevice0;// Index to the spiBusDevice array in spi.h
19:                  
20:                  
21:                  
22:                  //Must be call first
23:                  void InitSPI1MemBus(void)
24:                  {
9D00BB28  27BDFFF8   ADDIU SP, SP, -8
9D00BB2C  AFBE0004   SW S8, 4(SP)
9D00BB30  03A0F021   ADDU S8, SP, ZERO
25:                      SPI1CONbits.ON = 0;
9D00BB34  3C03BF80   LUI V1, -16512
9D00BB38  8C625E00   LW V0, 24064(V1)
9D00BB3C  7C027BC4   INS V0, ZERO, 15, 1
9D00BB40  AC625E00   SW V0, 24064(V1)
26:                      // Initialize SPI1
27:                      SPI1STAT = 0;
9D00BB44  3C02BF80   LUI V0, -16512
9D00BB48  AC405E10   SW ZERO, 24080(V0)
28:                      SPI1CON = 0;
9D00BB4C  3C02BF80   LUI V0, -16512
9D00BB50  AC405E00   SW ZERO, 24064(V0)
29:                      SPI1CONbits.MSTEN = 1;
9D00BB54  3C03BF80   LUI V1, -16512
9D00BB58  8C625E00   LW V0, 24064(V1)
9D00BB5C  24040001   ADDIU A0, ZERO, 1
9D00BB60  7C822944   INS V0, A0, 5, 1
9D00BB64  AC625E00   SW V0, 24064(V1)
30:                      SPI1CONbits.CKP = 1;
9D00BB68  3C03BF80   LUI V1, -16512
9D00BB6C  8C625E00   LW V0, 24064(V1)
9D00BB70  24040001   ADDIU A0, ZERO, 1
9D00BB74  7C823184   INS V0, A0, 6, 1
9D00BB78  AC625E00   SW V0, 24064(V1)
31:                      SPI1CONbits.CKE = 0;
9D00BB7C  3C03BF80   LUI V1, -16512
9D00BB80  8C625E00   LW V0, 24064(V1)
9D00BB84  7C024204   INS V0, ZERO, 8, 1
9D00BB88  AC625E00   SW V0, 24064(V1)
32:                      SPI1CONbits.SMP = 0;
9D00BB8C  3C03BF80   LUI V1, -16512
9D00BB90  8C625E00   LW V0, 24064(V1)
9D00BB94  7C024A44   INS V0, ZERO, 9, 1
9D00BB98  AC625E00   SW V0, 24064(V1)
33:                      SPI1BRG = 15;
9D00BB9C  3C02BF80   LUI V0, -16512
9D00BBA0  2403000F   ADDIU V1, ZERO, 15
9D00BBA4  AC435E30   SW V1, 24112(V0)
34:                      SPI1CONbits.ON = 1;
9D00BBA8  3C03BF80   LUI V1, -16512
9D00BBAC  8C625E00   LW V0, 24064(V1)
9D00BBB0  24040001   ADDIU A0, ZERO, 1
9D00BBB4  7C827BC4   INS V0, A0, 15, 1
9D00BBB8  AC625E00   SW V0, 24064(V1)
35:                  
36:                      // Set IOs directions for SFLASH SPI
37:                  
38:                      _TRISC2 = 0;
9D00BBBC  3C03BF88   LUI V1, -16504
9D00BBC0  8C626080   LW V0, 24704(V1)
9D00BBC4  7C021084   INS V0, ZERO, 2, 1
9D00BBC8  AC626080   SW V0, 24704(V1)
39:                      _TRISD10 = 0;
9D00BBCC  3C03BF88   LUI V1, -16504
9D00BBD0  8C6260C0   LW V0, 24768(V1)
9D00BBD4  7C025284   INS V0, ZERO, 10, 1
9D00BBD8  AC6260C0   SW V0, 24768(V1)
40:                      _TRISC4 = 1;
9D00BBDC  3C03BF88   LUI V1, -16504
9D00BBE0  8C626080   LW V0, 24704(V1)
9D00BBE4  24040001   ADDIU A0, ZERO, 1
9D00BBE8  7C822104   INS V0, A0, 4, 1
9D00BBEC  AC626080   SW V0, 24704(V1)
41:                      _TRISD0 = 0;
9D00BBF0  3C03BF88   LUI V1, -16504
9D00BBF4  8C6260C0   LW V0, 24768(V1)
9D00BBF8  7C020004   INS V0, ZERO, 0, 1
9D00BBFC  AC6260C0   SW V0, 24768(V1)
42:                  
43:                  }
9D00BC00  03C0E821   ADDU SP, S8, ZERO
9D00BC04  8FBE0004   LW S8, 4(SP)
9D00BC08  27BD0008   ADDIU SP, SP, 8
9D00BC0C  03E00008   JR RA
9D00BC10  00000000   NOP
44:                  void InitRamtron(void)
45:                  {
9D00BC14  27BDFFF8   ADDIU SP, SP, -8
9D00BC18  AFBE0004   SW S8, 4(SP)
9D00BC1C  03A0F021   ADDU S8, SP, ZERO
46:                          //Device settings for Ramtron
47:                      // Initialize SPI1
48:                      //SPI1CONbits.ON = 0;
49:                      ///SPI1CONbits.CKP = 1;
50:                      //SPI1CONbits.CKE = 0;
51:                      //SPI1CONbits.SMP = 0;
52:                      SPI1CON = 0x00008120; //=the above
9D00BC20  3C02BF80   LUI V0, -16512
9D00BC24  34038120   ORI V1, ZERO, -32480
9D00BC28  AC435E00   SW V1, 24064(V0)
53:                      SPI1BRG = 15;//Different IC might need different speeds
9D00BC2C  3C02BF80   LUI V0, -16512
9D00BC30  2403000F   ADDIU V1, ZERO, 15
9D00BC34  AC435E30   SW V1, 24112(V0)
54:                      SPI1CONbits.ON = 1;
9D00BC38  3C03BF80   LUI V1, -16512
9D00BC3C  8C625E00   LW V0, 24064(V1)
9D00BC40  24040001   ADDIU A0, ZERO, 1
9D00BC44  7C827BC4   INS V0, A0, 15, 1
9D00BC48  AC625E00   SW V0, 24064(V1)
55:                  
56:                      // Set IOs directions for SFLASH SPI
57:                     
58:                      //SPI1CONbits.intEnable = 0;
59:                  }
9D00BC4C  03C0E821   ADDU SP, S8, ZERO
9D00BC50  8FBE0004   LW S8, 4(SP)
9D00BC54  27BD0008   ADDIU SP, SP, 8
9D00BC58  03E00008   JR RA
9D00BC5C  00000000   NOP
60:                  
61:                  
62:                  void InitFlash(void)
63:                  {
9D00BC60  27BDFFF8   ADDIU SP, SP, -8
9D00BC64  AFBE0004   SW S8, 4(SP)
9D00BC68  03A0F021   ADDU S8, SP, ZERO
64:                      //Device settings for Flash Memory
65:                      _TRISD12 = 0;
9D00BC6C  3C03BF88   LUI V1, -16504
9D00BC70  8C6260C0   LW V0, 24768(V1)
9D00BC74  7C026304   INS V0, ZERO, 12, 1
9D00BC78  AC6260C0   SW V0, 24768(V1)
66:                      fmChipSelect = 1;
9D00BC7C  3C03BF88   LUI V1, -16504
9D00BC80  8C6260D0   LW V0, 24784(V1)
9D00BC84  24040001   ADDIU A0, ZERO, 1
9D00BC88  7C826304   INS V0, A0, 12, 1
9D00BC8C  AC6260D0   SW V0, 24784(V1)
67:                      SPI1CONbits.CKE = 1;
9D00BC90  3C03BF80   LUI V1, -16512
9D00BC94  8C625E00   LW V0, 24064(V1)
9D00BC98  24040001   ADDIU A0, ZERO, 1
9D00BC9C  7C824204   INS V0, A0, 8, 1
9D00BCA0  AC625E00   SW V0, 24064(V1)
68:                      SPI1CONbits.CKP = 0;
9D00BCA4  3C03BF80   LUI V1, -16512
9D00BCA8  8C625E00   LW V0, 24064(V1)
9D00BCAC  7C023184   INS V0, ZERO, 6, 1
9D00BCB0  AC625E00   SW V0, 24064(V1)
69:                      SPI1CONbits.MODE16 = 0;
9D00BCB4  3C03BF80   LUI V1, -16512
9D00BCB8  8C625E00   LW V0, 24064(V1)
9D00BCBC  7C025284   INS V0, ZERO, 10, 1
9D00BCC0  AC625E00   SW V0, 24064(V1)
70:                      
71:                  }
9D00BCC4  03C0E821   ADDU SP, S8, ZERO
9D00BCC8  8FBE0004   LW S8, 4(SP)
9D00BCCC  27BD0008   ADDIU SP, SP, 8
9D00BCD0  03E00008   JR RA
9D00BCD4  00000000   NOP
72:                  void InitEProm(void)
73:                  {
9D00BCD8  27BDFFF8   ADDIU SP, SP, -8
9D00BCDC  AFBE0004   SW S8, 4(SP)
9D00BCE0  03A0F021   ADDU S8, SP, ZERO
74:                      //Device settings for EEProm
75:                      _TRISD12 = 0;
9D00BCE4  3C03BF88   LUI V1, -16504
9D00BCE8  8C6260C0   LW V0, 24768(V1)
9D00BCEC  7C026304   INS V0, ZERO, 12, 1
9D00BCF0  AC6260C0   SW V0, 24768(V1)
76:                      epChipSelect = 1;
9D00BCF4  3C03BF88   LUI V1, -16504
9D00BCF8  8C6260D0   LW V0, 24784(V1)
9D00BCFC  24040001   ADDIU A0, ZERO, 1
9D00BD00  7C826304   INS V0, A0, 12, 1
9D00BD04  AC6260D0   SW V0, 24784(V1)
77:                      SPI1CONbits.CKE = 1;
9D00BD08  3C03BF80   LUI V1, -16512
9D00BD0C  8C625E00   LW V0, 24064(V1)
9D00BD10  24040001   ADDIU A0, ZERO, 1
9D00BD14  7C824204   INS V0, A0, 8, 1
9D00BD18  AC625E00   SW V0, 24064(V1)
78:                      SPI1CONbits.CKP = 0;
9D00BD1C  3C03BF80   LUI V1, -16512
9D00BD20  8C625E00   LW V0, 24064(V1)
9D00BD24  7C023184   INS V0, ZERO, 6, 1
9D00BD28  AC625E00   SW V0, 24064(V1)
79:                      SPI1CONbits.MODE16 = 0;
9D00BD2C  3C03BF80   LUI V1, -16512
9D00BD30  8C625E00   LW V0, 24064(V1)
9D00BD34  7C025284   INS V0, ZERO, 10, 1
9D00BD38  AC625E00   SW V0, 24064(V1)
80:                      //spi2DeviceArray[epDevice].intEnable = 0;
81:                  }
9D00BD3C  03C0E821   ADDU SP, S8, ZERO
9D00BD40  8FBE0004   LW S8, 4(SP)
9D00BD44  27BD0008   ADDIU SP, SP, 8
9D00BD48  03E00008   JR RA
9D00BD4C  00000000   NOP
82:                  
83:                  
84:                  uChar SPI1_WR(uChar Data)//Write then read the SPI bus
85:                  {	
9D00BD50  27BDFFF8   ADDIU SP, SP, -8
9D00BD54  AFBE0004   SW S8, 4(SP)
9D00BD58  03A0F021   ADDU S8, SP, ZERO
9D00BD5C  00801021   ADDU V0, A0, ZERO
9D00BD60  A3C20008   SB V0, 8(S8)
86:                  	
87:                      NV_SPIBUFF = Data;
9D00BD64  93C30008   LBU V1, 8(S8)
9D00BD68  3C02BF80   LUI V0, -16512
9D00BD6C  AC435E20   SW V1, 24096(V0)
88:                      while(SPI1STATbits.SPIRBF); // Watch RX buff to see if TX is finished
9D00BD70  00000000   NOP
9D00BD74  3C02BF80   LUI V0, -16512
9D00BD78  8C425E10   LW V0, 24080(V0)
9D00BD7C  30420001   ANDI V0, V0, 1
9D00BD80  1440FFFC   BNE V0, ZERO, 0x9D00BD74
9D00BD84  00000000   NOP
89:                      return NV_SPIBUFF;
9D00BD88  3C02BF80   LUI V0, -16512
9D00BD8C  8C425E20   LW V0, 24096(V0)
9D00BD90  304200FF   ANDI V0, V0, 255
90:                  }
9D00BD94  03C0E821   ADDU SP, S8, ZERO
9D00BD98  8FBE0004   LW S8, 4(SP)
9D00BD9C  27BD0008   ADDIU SP, SP, 8
9D00BDA0  03E00008   JR RA
9D00BDA4  00000000   NOP
91:                  void EP_WriteEnable()
92:                  {
9D00BDA8  27BDFFE8   ADDIU SP, SP, -24
9D00BDAC  AFBF0014   SW RA, 20(SP)
9D00BDB0  AFBE0010   SW S8, 16(SP)
9D00BDB4  03A0F021   ADDU S8, SP, ZERO
93:                      epChipSelect = 0;//Enable Chip
9D00BDB8  3C03BF88   LUI V1, -16504
9D00BDBC  8C6260D0   LW V0, 24784(V1)
9D00BDC0  7C026304   INS V0, ZERO, 12, 1
9D00BDC4  AC6260D0   SW V0, 24784(V1)
94:                      SPI1_WR(NV_WEN); // Send write enable command
9D00BDC8  24040006   ADDIU A0, ZERO, 6
9D00BDCC  0F402F54   JAL SPI1_WR
9D00BDD0  00000000   NOP
95:                      epChipSelect = 1; //Enable chip to Finish write enable
9D00BDD4  3C03BF88   LUI V1, -16504
9D00BDD8  8C6260D0   LW V0, 24784(V1)
9D00BDDC  24040001   ADDIU A0, ZERO, 1
9D00BDE0  7C826304   INS V0, A0, 12, 1
9D00BDE4  AC6260D0   SW V0, 24784(V1)
96:                  }
9D00BDE8  03C0E821   ADDU SP, S8, ZERO
9D00BDEC  8FBF0014   LW RA, 20(SP)
9D00BDF0  8FBE0010   LW S8, 16(SP)
9D00BDF4  27BD0018   ADDIU SP, SP, 24
9D00BDF8  03E00008   JR RA
9D00BDFC  00000000   NOP
97:                  void EP_WriteDisable()
98:                  {
9D00BE00  27BDFFE8   ADDIU SP, SP, -24
9D00BE04  AFBF0014   SW RA, 20(SP)
9D00BE08  AFBE0010   SW S8, 16(SP)
9D00BE0C  03A0F021   ADDU S8, SP, ZERO
99:                      epChipSelect = 0;//Enable Chip
9D00BE10  3C03BF88   LUI V1, -16504
9D00BE14  8C6260D0   LW V0, 24784(V1)
9D00BE18  7C026304   INS V0, ZERO, 12, 1
9D00BE1C  AC6260D0   SW V0, 24784(V1)
100:                     SPI1_WR(NV_WDIS); // Send write disable command
9D00BE20  24040004   ADDIU A0, ZERO, 4
9D00BE24  0F402F54   JAL SPI1_WR
9D00BE28  00000000   NOP
101:                     epChipSelect = 1; //Enable chip to Finish write enable
9D00BE2C  3C03BF88   LUI V1, -16504
9D00BE30  8C6260D0   LW V0, 24784(V1)
9D00BE34  24040001   ADDIU A0, ZERO, 1
9D00BE38  7C826304   INS V0, A0, 12, 1
9D00BE3C  AC6260D0   SW V0, 24784(V1)
102:                 }
9D00BE40  03C0E821   ADDU SP, S8, ZERO
9D00BE44  8FBF0014   LW RA, 20(SP)
9D00BE48  8FBE0010   LW S8, 16(SP)
9D00BE4C  27BD0018   ADDIU SP, SP, 24
9D00BE50  03E00008   JR RA
9D00BE54  00000000   NOP
103:                 /*CheckNVMemory is for use with interrupts or DMA */
104:                 
105:                 
106:                 uInt EP_Status(void)
107:                 {
9D00BE58  27BDFFE0   ADDIU SP, SP, -32
9D00BE5C  AFBF001C   SW RA, 28(SP)
9D00BE60  AFBE0018   SW S8, 24(SP)
9D00BE64  03A0F021   ADDU S8, SP, ZERO
108:                     uChar data = 0;
9D00BE68  A3C00010   SB ZERO, 16(S8)
109:                     fmChipSelect = 0;
9D00BE6C  3C03BF88   LUI V1, -16504
9D00BE70  8C6260D0   LW V0, 24784(V1)
9D00BE74  7C026304   INS V0, ZERO, 12, 1
9D00BE78  AC6260D0   SW V0, 24784(V1)
110:                     SPI1_WR(NV_READSTATE);
9D00BE7C  24040005   ADDIU A0, ZERO, 5
9D00BE80  0F402F54   JAL SPI1_WR
9D00BE84  00000000   NOP
111:                     data = SPI1_WR(0);
9D00BE88  00002021   ADDU A0, ZERO, ZERO
9D00BE8C  0F402F54   JAL SPI1_WR
9D00BE90  00000000   NOP
9D00BE94  A3C20010   SB V0, 16(S8)
112:                     fmChipSelect = 1;
9D00BE98  3C03BF88   LUI V1, -16504
9D00BE9C  8C6260D0   LW V0, 24784(V1)
9D00BEA0  24040001   ADDIU A0, ZERO, 1
9D00BEA4  7C826304   INS V0, A0, 12, 1
9D00BEA8  AC6260D0   SW V0, 24784(V1)
113:                     return data;//Disable Chip
9D00BEAC  93C20010   LBU V0, 16(S8)
114:                 }
9D00BEB0  03C0E821   ADDU SP, S8, ZERO
9D00BEB4  8FBF001C   LW RA, 28(SP)
9D00BEB8  8FBE0018   LW S8, 24(SP)
9D00BEBC  27BD0020   ADDIU SP, SP, 32
9D00BEC0  03E00008   JR RA
9D00BEC4  00000000   NOP
115:                 
116:                 
117:                 uInt EP_WriteChars(uInt Address, uInt numChars, uChar *charArray, char New)
118:                 {
9D00BEC8  27BDFFE0   ADDIU SP, SP, -32
9D00BECC  AFBF001C   SW RA, 28(SP)
9D00BED0  AFBE0018   SW S8, 24(SP)
9D00BED4  03A0F021   ADDU S8, SP, ZERO
9D00BED8  AFC40020   SW A0, 32(S8)
9D00BEDC  AFC50024   SW A1, 36(S8)
9D00BEE0  AFC60028   SW A2, 40(S8)
9D00BEE4  00E01021   ADDU V0, A3, ZERO
9D00BEE8  A3C2002C   SB V0, 44(S8)
119:                     uChar cIndex = 0;
9D00BEEC  A3C00010   SB ZERO, 16(S8)
120:                     if((nvMemStatus > 0) && (New == 1)) return 1;//Cannot start new job until I finish old
9D00BEF0  8F828264   LW V0, -32156(GP)
9D00BEF4  10400008   BEQ V0, ZERO, 0x9D00BF18
9D00BEF8  00000000   NOP
9D00BEFC  83C3002C   LB V1, 44(S8)
9D00BF00  24020001   ADDIU V0, ZERO, 1
9D00BF04  14620004   BNE V1, V0, 0x9D00BF18
9D00BF08  00000000   NOP
9D00BF0C  24020001   ADDIU V0, ZERO, 1
9D00BF10  0B403036   J 0x9D00C0D8
9D00BF14  00000000   NOP
121:                     numberRemaining = numChars;//Save total number bytes to write
9D00BF18  8FC20024   LW V0, 36(S8)
9D00BF1C  AF82826C   SW V0, -32148(GP)
122:                     if((Address + numberRemaining) > EP_CHIPSIZE) return 3; // not enough room for this operation
9D00BF20  8F83826C   LW V1, -32148(GP)
9D00BF24  8FC20020   LW V0, 32(S8)
9D00BF28  00621821   ADDU V1, V1, V0
9D00BF2C  34028001   ORI V0, ZERO, -32767
9D00BF30  0062102B   SLTU V0, V1, V0
9D00BF34  14400004   BNE V0, ZERO, 0x9D00BF48
9D00BF38  00000000   NOP
9D00BF3C  24020003   ADDIU V0, ZERO, 3
9D00BF40  0B403036   J 0x9D00C0D8
9D00BF44  00000000   NOP
123:                     while(EP_Status() & 0X01); // Wait for previous write to finish before disabling WEN
9D00BF48  00000000   NOP
9D00BF4C  0F402F96   JAL EP_Status
9D00BF50  00000000   NOP
9D00BF54  30420001   ANDI V0, V0, 1
9D00BF58  304200FF   ANDI V0, V0, 255
9D00BF5C  1440FFFB   BNE V0, ZERO, 0x9D00BF4C
9D00BF60  00000000   NOP
124:                     EP_WriteDisable();//This should not be necessary but it stuck on once.
9D00BF64  0F402F80   JAL EP_WriteDisable
9D00BF68  00000000   NOP
125:                     cIndex = (Address/EP_PAGESIZE) + 1; //What memory page is tha address
9D00BF6C  8FC20020   LW V0, 32(S8)
9D00BF70  00021182   SRL V0, V0, 6
9D00BF74  304200FF   ANDI V0, V0, 255
9D00BF78  24420001   ADDIU V0, V0, 1
9D00BF7C  A3C20010   SB V0, 16(S8)
126:                     numChars = (EP_PAGESIZE * cIndex) - Address; //How many bytes can I write this page
9D00BF80  93C20010   LBU V0, 16(S8)
9D00BF84  00021180   SLL V0, V0, 6
9D00BF88  00401821   ADDU V1, V0, ZERO
9D00BF8C  8FC20020   LW V0, 32(S8)
9D00BF90  00621023   SUBU V0, V1, V0
9D00BF94  AFC20024   SW V0, 36(S8)
127:                     if(numberRemaining > numChars)//Do I need to write more than will fit on this page?
9D00BF98  8F83826C   LW V1, -32148(GP)
9D00BF9C  8FC20024   LW V0, 36(S8)
9D00BFA0  0043102B   SLTU V0, V0, V1
9D00BFA4  10400007   BEQ V0, ZERO, 0x9D00BFC4
9D00BFA8  00000000   NOP
128:                     {
129:                             //numChars will write as many bytes as will fit in this page
130:                             numberRemaining -= numChars; //Then save the number of bytes for next write
9D00BFAC  8F83826C   LW V1, -32148(GP)
9D00BFB0  8FC20024   LW V0, 36(S8)
9D00BFB4  00621023   SUBU V0, V1, V0
9D00BFB8  AF82826C   SW V0, -32148(GP)
9D00BFBC  0B402FF4   J 0x9D00BFD0
9D00BFC0  00000000   NOP
131:                 
132:                     }
133:                     else //It all fits, just write number of bytes
134:                     {
135:                             numChars = numberRemaining;
9D00BFC4  8F82826C   LW V0, -32148(GP)
9D00BFC8  AFC20024   SW V0, 36(S8)
136:                             numberRemaining = 0;
9D00BFCC  AF80826C   SW ZERO, -32148(GP)
137:                     }
138:                     EP_WriteEnable();
9D00BFD0  0F402F6A   JAL EP_WriteEnable
9D00BFD4  00000000   NOP
139:                     epChipSelect = 0;//Enable Chip
9D00BFD8  3C03BF88   LUI V1, -16504
9D00BFDC  8C6260D0   LW V0, 24784(V1)
9D00BFE0  7C026304   INS V0, ZERO, 12, 1
9D00BFE4  AC6260D0   SW V0, 24784(V1)
140:                     SPI1_WR(NV_WRITE);//Send the write command
9D00BFE8  24040002   ADDIU A0, ZERO, 2
9D00BFEC  0F402F54   JAL SPI1_WR
9D00BFF0  00000000   NOP
141:                     SPI1_WR(Address >> 8); //send address high byte
9D00BFF4  8FC20020   LW V0, 32(S8)
9D00BFF8  00021202   SRL V0, V0, 8
9D00BFFC  304200FF   ANDI V0, V0, 255
9D00C000  00402021   ADDU A0, V0, ZERO
9D00C004  0F402F54   JAL SPI1_WR
9D00C008  00000000   NOP
142:                     SPI1_WR(Address & 0x00FE); //send address low byte, byte aligned
9D00C00C  8FC20020   LW V0, 32(S8)
9D00C010  304200FF   ANDI V0, V0, 255
9D00C014  304200FE   ANDI V0, V0, 254
9D00C018  00402021   ADDU A0, V0, ZERO
9D00C01C  0F402F54   JAL SPI1_WR
9D00C020  00000000   NOP
143:                     for(cIndex = 0; cIndex < numChars; cIndex++)
9D00C024  A3C00010   SB ZERO, 16(S8)
9D00C028  0B403016   J 0x9D00C058
9D00C02C  00000000   NOP
9D00C04C  93C20010   LBU V0, 16(S8)
9D00C050  24420001   ADDIU V0, V0, 1
9D00C054  A3C20010   SB V0, 16(S8)
9D00C058  93C30010   LBU V1, 16(S8)
9D00C05C  8FC20024   LW V0, 36(S8)
9D00C060  0062102B   SLTU V0, V1, V0
9D00C064  1440FFF2   BNE V0, ZERO, 0x9D00C030
9D00C068  00000000   NOP
144:                     {
145:                             SPI1_WR(charArray[cIndex]);
9D00C030  93C20010   LBU V0, 16(S8)
9D00C034  8FC30028   LW V1, 40(S8)
9D00C038  00621021   ADDU V0, V1, V0
9D00C03C  90420000   LBU V0, 0(V0)
9D00C040  00402021   ADDU A0, V0, ZERO
9D00C044  0F402F54   JAL SPI1_WR
9D00C048  00000000   NOP
146:                     }
147:                     epChipSelect = 1;//Disable EP Chip
9D00C06C  3C03BF88   LUI V1, -16504
9D00C070  8C6260D0   LW V0, 24784(V1)
9D00C074  24040001   ADDIU A0, ZERO, 1
9D00C078  7C826304   INS V0, A0, 12, 1
9D00C07C  AC6260D0   SW V0, 24784(V1)
148:                 
149:                     if(numberRemaining > 0)//Do I need to come back and write more?
9D00C080  8F82826C   LW V0, -32148(GP)
9D00C084  10400010   BEQ V0, ZERO, 0x9D00C0C8
9D00C088  00000000   NOP
150:                     {
151:                             // Yes, set status and save parameters
152:                             nvMemStatus = EP_MEMORY | CHAR_WRITING; //Set UART state machine.
9D00C08C  24020021   ADDIU V0, ZERO, 33
9D00C090  AF828264   SW V0, -32156(GP)
153:                             MachineState |= sys_RUNNVMEM; //Set System State Machine
9D00C094  8F828278   LW V0, -32136(GP)
9D00C098  34420020   ORI V0, V0, 32
9D00C09C  AF828278   SW V0, -32136(GP)
154:                             cNVBuff = &charArray[numChars]; //Save nvAddress of buffer to read from
9D00C0A0  8FC30028   LW V1, 40(S8)
9D00C0A4  8FC20024   LW V0, 36(S8)
9D00C0A8  00621021   ADDU V0, V1, V0
9D00C0AC  AF828104   SW V0, -32508(GP)
155:                             nextAddress2Write += nextAddress2Write; // Save EEProm Address for next NV write
9D00C0B0  8F838260   LW V1, -32160(GP)
9D00C0B4  8F828260   LW V0, -32160(GP)
9D00C0B8  00621021   ADDU V0, V1, V0
9D00C0BC  AF828260   SW V0, -32160(GP)
9D00C0C0  0B403035   J 0x9D00C0D4
9D00C0C4  00000000   NOP
156:                     }
157:                     else//reset to zero
158:                     {
159:                             nvMemStatus = 0; //Clear State Machine
9D00C0C8  AF808264   SW ZERO, -32156(GP)
160:                             cNVBuff = 0;
9D00C0CC  AF808104   SW ZERO, -32508(GP)
161:                             nextAddress2Write = 0;
9D00C0D0  AF808260   SW ZERO, -32160(GP)
162:                     }
163:                     return 0;
9D00C0D4  00001021   ADDU V0, ZERO, ZERO
164:                 }
9D00C0D8  03C0E821   ADDU SP, S8, ZERO
9D00C0DC  8FBF001C   LW RA, 28(SP)
9D00C0E0  8FBE0018   LW S8, 24(SP)
9D00C0E4  27BD0020   ADDIU SP, SP, 32
9D00C0E8  03E00008   JR RA
9D00C0EC  00000000   NOP
165:                 uInt EP_ReadChars(uInt Address, uInt numValues, uChar *charArray)
166:                 {
9D00C0F0  27BDFFD8   ADDIU SP, SP, -40
9D00C0F4  AFBF0024   SW RA, 36(SP)
9D00C0F8  AFBE0020   SW S8, 32(SP)
9D00C0FC  AFB0001C   SW S0, 28(SP)
9D00C100  03A0F021   ADDU S8, SP, ZERO
9D00C104  AFC40028   SW A0, 40(S8)
9D00C108  AFC5002C   SW A1, 44(S8)
9D00C10C  AFC60030   SW A2, 48(S8)
167:                 	uChar cIndex = 0;	
9D00C110  A3C00010   SB ZERO, 16(S8)
168:                 	if((Address + numValues) > EP_CHIPSIZE) return 3; 
9D00C114  8FC30028   LW V1, 40(S8)
9D00C118  8FC2002C   LW V0, 44(S8)
9D00C11C  00621821   ADDU V1, V1, V0
9D00C120  34028001   ORI V0, ZERO, -32767
9D00C124  0062102B   SLTU V0, V1, V0
9D00C128  14400004   BNE V0, ZERO, 0x9D00C13C
9D00C12C  00000000   NOP
9D00C130  24020003   ADDIU V0, ZERO, 3
9D00C134  0B403083   J 0x9D00C20C
9D00C138  00000000   NOP
169:                 	while(EP_Status() & 0X01); // Wait for previous write to finish before disabling WEN
9D00C13C  00000000   NOP
9D00C140  0F402F96   JAL EP_Status
9D00C144  00000000   NOP
9D00C148  30420001   ANDI V0, V0, 1
9D00C14C  304200FF   ANDI V0, V0, 255
9D00C150  1440FFFB   BNE V0, ZERO, 0x9D00C140
9D00C154  00000000   NOP
170:                 	EP_WriteDisable();//This should not be necessary but it stuck on once.	EPWriteDisable();s() & 0x01);
9D00C158  0F402F80   JAL EP_WriteDisable
9D00C15C  00000000   NOP
171:                 	epChipSelect = 0;//Enable Chip
9D00C160  3C03BF88   LUI V1, -16504
9D00C164  8C6260D0   LW V0, 24784(V1)
9D00C168  7C026304   INS V0, ZERO, 12, 1
9D00C16C  AC6260D0   SW V0, 24784(V1)
172:                 	SPI1_WR(NV_READ);//Send read command
9D00C170  24040003   ADDIU A0, ZERO, 3
9D00C174  0F402F54   JAL SPI1_WR
9D00C178  00000000   NOP
173:                 	SPI1_WR(Address >> 8); //send address high byte
9D00C17C  8FC20028   LW V0, 40(S8)
9D00C180  00021202   SRL V0, V0, 8
9D00C184  304200FF   ANDI V0, V0, 255
9D00C188  00402021   ADDU A0, V0, ZERO
9D00C18C  0F402F54   JAL SPI1_WR
9D00C190  00000000   NOP
174:                 	SPI1_WR(Address & 0x00FE); //send address low byte, byte aligned
9D00C194  8FC20028   LW V0, 40(S8)
9D00C198  304200FF   ANDI V0, V0, 255
9D00C19C  304200FE   ANDI V0, V0, 254
9D00C1A0  00402021   ADDU A0, V0, ZERO
9D00C1A4  0F402F54   JAL SPI1_WR
9D00C1A8  00000000   NOP
175:                 	for(cIndex = 0;cIndex < numValues; cIndex++)
9D00C1AC  A3C00010   SB ZERO, 16(S8)
9D00C1B0  0B403078   J 0x9D00C1E0
9D00C1B4  00000000   NOP
9D00C1D4  93C20010   LBU V0, 16(S8)
9D00C1D8  24420001   ADDIU V0, V0, 1
9D00C1DC  A3C20010   SB V0, 16(S8)
9D00C1E0  93C30010   LBU V1, 16(S8)
9D00C1E4  8FC2002C   LW V0, 44(S8)
9D00C1E8  0062102B   SLTU V0, V1, V0
9D00C1EC  1440FFF2   BNE V0, ZERO, 0x9D00C1B8
9D00C1F0  00000000   NOP
176:                 	{
177:                 		charArray[cIndex] = SPI1_WR(0);
9D00C1B8  93C20010   LBU V0, 16(S8)
9D00C1BC  8FC30030   LW V1, 48(S8)
9D00C1C0  00628021   ADDU S0, V1, V0
9D00C1C4  00002021   ADDU A0, ZERO, ZERO
9D00C1C8  0F402F54   JAL SPI1_WR
9D00C1CC  00000000   NOP
9D00C1D0  A2020000   SB V0, 0(S0)
178:                 	}
179:                 	epChipSelect = 1;//Disable Chip
9D00C1F4  3C03BF88   LUI V1, -16504
9D00C1F8  8C6260D0   LW V0, 24784(V1)
9D00C1FC  24040001   ADDIU A0, ZERO, 1
9D00C200  7C826304   INS V0, A0, 12, 1
9D00C204  AC6260D0   SW V0, 24784(V1)
180:                 	return 0;	
9D00C208  00001021   ADDU V0, ZERO, ZERO
181:                 }
9D00C20C  03C0E821   ADDU SP, S8, ZERO
9D00C210  8FBF0024   LW RA, 36(SP)
9D00C214  8FBE0020   LW S8, 32(SP)
9D00C218  8FB0001C   LW S0, 28(SP)
9D00C21C  27BD0028   ADDIU SP, SP, 40
9D00C220  03E00008   JR RA
9D00C224  00000000   NOP
182:                 
183:                 uInt FM_Status()
184:                 {
9D00C228  27BDFFE0   ADDIU SP, SP, -32
9D00C22C  AFBF001C   SW RA, 28(SP)
9D00C230  AFBE0018   SW S8, 24(SP)
9D00C234  03A0F021   ADDU S8, SP, ZERO
185:                 	uChar data = 0;
9D00C238  A3C00010   SB ZERO, 16(S8)
186:                 	fmChipSelect = 0;
9D00C23C  3C03BF88   LUI V1, -16504
9D00C240  8C6260D0   LW V0, 24784(V1)
9D00C244  7C026304   INS V0, ZERO, 12, 1
9D00C248  AC6260D0   SW V0, 24784(V1)
187:                 	SPI1_WR(NV_READSTATE);
9D00C24C  24040005   ADDIU A0, ZERO, 5
9D00C250  0F402F54   JAL SPI1_WR
9D00C254  00000000   NOP
188:                 	data = SPI1_WR(0);
9D00C258  00002021   ADDU A0, ZERO, ZERO
9D00C25C  0F402F54   JAL SPI1_WR
9D00C260  00000000   NOP
9D00C264  A3C20010   SB V0, 16(S8)
189:                 	fmChipSelect = 1;
9D00C268  3C03BF88   LUI V1, -16504
9D00C26C  8C6260D0   LW V0, 24784(V1)
9D00C270  24040001   ADDIU A0, ZERO, 1
9D00C274  7C826304   INS V0, A0, 12, 1
9D00C278  AC6260D0   SW V0, 24784(V1)
190:                 	return data;//Disable Chip
9D00C27C  93C20010   LBU V0, 16(S8)
191:                 }
9D00C280  03C0E821   ADDU SP, S8, ZERO
9D00C284  8FBF001C   LW RA, 28(SP)
9D00C288  8FBE0018   LW S8, 24(SP)
9D00C28C  27BD0020   ADDIU SP, SP, 32
9D00C290  03E00008   JR RA
9D00C294  00000000   NOP
192:                 void   FM_ErasePage(uInt PageNumber)
193:                 {
9D00C298  27BDFFF8   ADDIU SP, SP, -8
9D00C29C  AFBE0004   SW S8, 4(SP)
9D00C2A0  03A0F021   ADDU S8, SP, ZERO
9D00C2A4  AFC40008   SW A0, 8(S8)
194:                 	
195:                 }
9D00C2A8  03C0E821   ADDU SP, S8, ZERO
9D00C2AC  8FBE0004   LW S8, 4(SP)
9D00C2B0  27BD0008   ADDIU SP, SP, 8
9D00C2B4  03E00008   JR RA
9D00C2B8  00000000   NOP
196:                 void   FM_EraseFMBlock(uInt BlockNumber)
197:                 {
9D00C2BC  27BDFFF8   ADDIU SP, SP, -8
9D00C2C0  AFBE0004   SW S8, 4(SP)
9D00C2C4  03A0F021   ADDU S8, SP, ZERO
9D00C2C8  AFC40008   SW A0, 8(S8)
198:                 	
199:                 }
9D00C2CC  03C0E821   ADDU SP, S8, ZERO
9D00C2D0  8FBE0004   LW S8, 4(SP)
9D00C2D4  27BD0008   ADDIU SP, SP, 8
9D00C2D8  03E00008   JR RA
9D00C2DC  00000000   NOP
200:                 void   FM_EraseFMSector(uInt SectorNumber) //0a = 1 Block, 0b = 31 blocks, all others 32 = blocks
201:                 {
9D00C2E0  27BDFFF8   ADDIU SP, SP, -8
9D00C2E4  AFBE0004   SW S8, 4(SP)
9D00C2E8  03A0F021   ADDU S8, SP, ZERO
9D00C2EC  AFC40008   SW A0, 8(S8)
202:                 
203:                 }
9D00C2F0  03C0E821   ADDU SP, S8, ZERO
9D00C2F4  8FBE0004   LW S8, 4(SP)
9D00C2F8  27BD0008   ADDIU SP, SP, 8
9D00C2FC  03E00008   JR RA
9D00C300  00000000   NOP
204:                 
205:                 uInt RT_WriteChars(uInt Address, uInt NumBytes, uChar *Data)
206:                 {
9D00C304  27BDFFE8   ADDIU SP, SP, -24
9D00C308  AFBF0014   SW RA, 20(SP)
9D00C30C  AFBE0010   SW S8, 16(SP)
9D00C310  03A0F021   ADDU S8, SP, ZERO
9D00C314  AFC40018   SW A0, 24(S8)
9D00C318  AFC5001C   SW A1, 28(S8)
9D00C31C  AFC60020   SW A2, 32(S8)
207:                     sIndex = 0;
9D00C320  A7808268   SH ZERO, -32152(GP)
208:                     InitRamtron();
9D00C324  0F402F05   JAL InitRamtron
9D00C328  00000000   NOP
209:                     while(NV_TXFULL); //Make sure we have finished from previous operation   
9D00C32C  00000000   NOP
9D00C330  3C02BF80   LUI V0, -16512
9D00C334  8C425E10   LW V0, 24080(V0)
9D00C338  30420002   ANDI V0, V0, 2
9D00C33C  1440FFFC   BNE V0, ZERO, 0x9D00C330
9D00C340  00000000   NOP
210:                     //Wait if writing or reading
211:                     if((Address + NumBytes) > RT_CHIPSIZE) return 1;
9D00C344  8FC30018   LW V1, 24(S8)
9D00C348  8FC2001C   LW V0, 28(S8)
9D00C34C  00621021   ADDU V0, V1, V0
9D00C350  2C422001   SLTIU V0, V0, 8193
9D00C354  14400004   BNE V0, ZERO, 0x9D00C368
9D00C358  00000000   NOP
9D00C35C  24020001   ADDIU V0, ZERO, 1
9D00C360  0B40311A   J 0x9D00C468
9D00C364  00000000   NOP
212:                     csRamtron = 0;//Enable Chip
9D00C368  3C03BF88   LUI V1, -16504
9D00C36C  8C626090   LW V0, 24720(V1)
9D00C370  7C021084   INS V0, ZERO, 2, 1
9D00C374  AC626090   SW V0, 24720(V1)
213:                     SPI1_WR(RT_WREN);
9D00C378  24040006   ADDIU A0, ZERO, 6
9D00C37C  0F402F54   JAL SPI1_WR
9D00C380  00000000   NOP
214:                     csRamtron = 1;//Disable Chip
9D00C384  3C03BF88   LUI V1, -16504
9D00C388  8C626090   LW V0, 24720(V1)
9D00C38C  24040001   ADDIU A0, ZERO, 1
9D00C390  7C821084   INS V0, A0, 2, 1
9D00C394  AC626090   SW V0, 24720(V1)
215:                     csRamtron = 0;//Enable Chip
9D00C398  3C03BF88   LUI V1, -16504
9D00C39C  8C626090   LW V0, 24720(V1)
9D00C3A0  7C021084   INS V0, ZERO, 2, 1
9D00C3A4  AC626090   SW V0, 24720(V1)
216:                     SPI1_WR(RT_WRITE);//Send the write command(Same for Ramtron)
9D00C3A8  24040002   ADDIU A0, ZERO, 2
9D00C3AC  0F402F54   JAL SPI1_WR
9D00C3B0  00000000   NOP
217:                     //while(NV_TXFULL);
218:                     SPI1_WR(((Address & 0x00070000)>>16));
9D00C3B4  8FC30018   LW V1, 24(S8)
9D00C3B8  3C020007   LUI V0, 7
9D00C3BC  00621024   AND V0, V1, V0
9D00C3C0  00021402   SRL V0, V0, 16
9D00C3C4  304200FF   ANDI V0, V0, 255
9D00C3C8  00402021   ADDU A0, V0, ZERO
9D00C3CC  0F402F54   JAL SPI1_WR
9D00C3D0  00000000   NOP
219:                     SPI1_WR((Address >> 8)); //send address high byte
9D00C3D4  8FC20018   LW V0, 24(S8)
9D00C3D8  00021202   SRL V0, V0, 8
9D00C3DC  304200FF   ANDI V0, V0, 255
9D00C3E0  00402021   ADDU A0, V0, ZERO
9D00C3E4  0F402F54   JAL SPI1_WR
9D00C3E8  00000000   NOP
220:                     SPI1_WR( (Address & 0x000000FE)); //send address low byte, byte aligned
9D00C3EC  8FC20018   LW V0, 24(S8)
9D00C3F0  304200FF   ANDI V0, V0, 255
9D00C3F4  304200FE   ANDI V0, V0, 254
9D00C3F8  00402021   ADDU A0, V0, ZERO
9D00C3FC  0F402F54   JAL SPI1_WR
9D00C400  00000000   NOP
221:                     while(sIndex < NumBytes)
9D00C404  0B40310E   J 0x9D00C438
9D00C408  00000000   NOP
9D00C438  97828268   LHU V0, -32152(GP)
9D00C43C  00401821   ADDU V1, V0, ZERO
9D00C440  8FC2001C   LW V0, 28(S8)
9D00C444  0062102B   SLTU V0, V1, V0
9D00C448  1440FFF0   BNE V0, ZERO, 0x9D00C40C
9D00C44C  00000000   NOP
222:                     {
223:                         SPI1_WR(Data[sIndex++]);
9D00C40C  97828268   LHU V0, -32152(GP)
9D00C410  00401821   ADDU V1, V0, ZERO
9D00C414  8FC40020   LW A0, 32(S8)
9D00C418  00831821   ADDU V1, A0, V1
9D00C41C  90630000   LBU V1, 0(V1)
9D00C420  24420001   ADDIU V0, V0, 1
9D00C424  3042FFFF   ANDI V0, V0, -1
9D00C428  A7828268   SH V0, -32152(GP)
9D00C42C  00602021   ADDU A0, V1, ZERO
9D00C430  0F402F54   JAL SPI1_WR
9D00C434  00000000   NOP
224:                         //Data[cIndex++];
225:                     }
226:                     csRamtron = 1;//Disable Chip
9D00C450  3C03BF88   LUI V1, -16504
9D00C454  8C626090   LW V0, 24720(V1)
9D00C458  24040001   ADDIU A0, ZERO, 1
9D00C45C  7C821084   INS V0, A0, 2, 1
9D00C460  AC626090   SW V0, 24720(V1)
227:                     return 0;
9D00C464  00001021   ADDU V0, ZERO, ZERO
228:                 }
9D00C468  03C0E821   ADDU SP, S8, ZERO
9D00C46C  8FBF0014   LW RA, 20(SP)
9D00C470  8FBE0010   LW S8, 16(SP)
9D00C474  27BD0018   ADDIU SP, SP, 24
9D00C478  03E00008   JR RA
9D00C47C  00000000   NOP
229:                 uInt RT_ReadChars(uInt Address, uInt NumBytes, uChar *Data)
230:                 {
9D00C480  27BDFFE0   ADDIU SP, SP, -32
9D00C484  AFBF001C   SW RA, 28(SP)
9D00C488  AFBE0018   SW S8, 24(SP)
9D00C48C  03A0F021   ADDU S8, SP, ZERO
9D00C490  AFC40020   SW A0, 32(S8)
9D00C494  AFC50024   SW A1, 36(S8)
9D00C498  AFC60028   SW A2, 40(S8)
231:                     uShort index = 0;
9D00C49C  A7C00010   SH ZERO, 16(S8)
232:                     uChar tempChar = 0;
9D00C4A0  A3C00012   SB ZERO, 18(S8)
233:                     while(NV_TXFULL); //Make sure we have finished from previous operation
9D00C4A4  00000000   NOP
9D00C4A8  3C02BF80   LUI V0, -16512
9D00C4AC  8C425E10   LW V0, 24080(V0)
9D00C4B0  30420002   ANDI V0, V0, 2
9D00C4B4  1440FFFC   BNE V0, ZERO, 0x9D00C4A8
9D00C4B8  00000000   NOP
234:                     csRamtron = 0;//Enable Chip
9D00C4BC  3C03BF88   LUI V1, -16504
9D00C4C0  8C626090   LW V0, 24720(V1)
9D00C4C4  7C021084   INS V0, ZERO, 2, 1
9D00C4C8  AC626090   SW V0, 24720(V1)
235:                     SPI1_WR(RT_READ);//Send the write command(Same for Ramtron)
9D00C4CC  24040003   ADDIU A0, ZERO, 3
9D00C4D0  0F402F54   JAL SPI1_WR
9D00C4D4  00000000   NOP
236:                     //while(NV_TXFULL);
237:                     SPI1_WR(((Address & 0x00070000)>>16));
9D00C4D8  8FC30020   LW V1, 32(S8)
9D00C4DC  3C020007   LUI V0, 7
9D00C4E0  00621024   AND V0, V1, V0
9D00C4E4  00021402   SRL V0, V0, 16
9D00C4E8  304200FF   ANDI V0, V0, 255
9D00C4EC  00402021   ADDU A0, V0, ZERO
9D00C4F0  0F402F54   JAL SPI1_WR
9D00C4F4  00000000   NOP
238:                     SPI1_WR((Address >> 8)); //send address high byte
9D00C4F8  8FC20020   LW V0, 32(S8)
9D00C4FC  00021202   SRL V0, V0, 8
9D00C500  304200FF   ANDI V0, V0, 255
9D00C504  00402021   ADDU A0, V0, ZERO
9D00C508  0F402F54   JAL SPI1_WR
9D00C50C  00000000   NOP
239:                     SPI1_WR( (Address & 0x000000FE)); //send address low byte, byte aligned
9D00C510  8FC20020   LW V0, 32(S8)
9D00C514  304200FF   ANDI V0, V0, 255
9D00C518  304200FE   ANDI V0, V0, 254
9D00C51C  00402021   ADDU A0, V0, ZERO
9D00C520  0F402F54   JAL SPI1_WR
9D00C524  00000000   NOP
240:                     while(index < NumBytes)
9D00C528  0B403158   J 0x9D00C560
9D00C52C  00000000   NOP
9D00C560  97C30010   LHU V1, 16(S8)
9D00C564  8FC20024   LW V0, 36(S8)
9D00C568  0062102B   SLTU V0, V1, V0
9D00C56C  1440FFF0   BNE V0, ZERO, 0x9D00C530
9D00C570  00000000   NOP
241:                     {
242:                        
243:                         tempChar = SPI1_WR(0);
9D00C530  00002021   ADDU A0, ZERO, ZERO
9D00C534  0F402F54   JAL SPI1_WR
9D00C538  00000000   NOP
9D00C53C  A3C20012   SB V0, 18(S8)
244:                         Data[index++] = tempChar;
9D00C540  97C20010   LHU V0, 16(S8)
9D00C544  8FC30028   LW V1, 40(S8)
9D00C548  00621021   ADDU V0, V1, V0
9D00C54C  93C30012   LBU V1, 18(S8)
9D00C550  A0430000   SB V1, 0(V0)
9D00C554  97C20010   LHU V0, 16(S8)
9D00C558  24420001   ADDIU V0, V0, 1
9D00C55C  A7C20010   SH V0, 16(S8)
245:                     }
246:                     csRamtron = 1;//Disable Chip
9D00C574  3C03BF88   LUI V1, -16504
9D00C578  8C626090   LW V0, 24720(V1)
9D00C57C  24040001   ADDIU A0, ZERO, 1
9D00C580  7C821084   INS V0, A0, 2, 1
9D00C584  AC626090   SW V0, 24720(V1)
247:                     return;    
248:                 }
9D00C588  03C0E821   ADDU SP, S8, ZERO
9D00C58C  8FBF001C   LW RA, 28(SP)
9D00C590  8FBE0018   LW S8, 24(SP)
9D00C594  27BD0020   ADDIU SP, SP, 32
9D00C598  03E00008   JR RA
9D00C59C  00000000   NOP
249:                 
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/msg_mgr.c  -------------------------------------------------
1:                   #include "msg_mgr.h"
2:                   
3:                   
4:                   void LogMessageEvent(uShort EventNumber)
5:                   {
9D01939C  27BDFFF8   ADDIU SP, SP, -8
9D0193A0  AFBE0004   SW S8, 4(SP)
9D0193A4  03A0F021   ADDU S8, SP, ZERO
9D0193A8  00801021   ADDU V0, A0, ZERO
9D0193AC  A7C20008   SH V0, 8(S8)
6:                   
7:                   }
9D0193B0  03C0E821   ADDU SP, S8, ZERO
9D0193B4  8FBE0004   LW S8, 4(SP)
9D0193B8  27BD0008   ADDIU SP, SP, 8
9D0193BC  03E00008   JR RA
9D0193C0  00000000   NOP
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/mem_mgr.c  -------------------------------------------------
1:                   /**********************************************************************
2:                   * © 2009 Stillbright
3:                   * Created 10/24/2009
4:                   *	
5:                   * FileName:        mem_mgr.c
6:                   * Purpose:  This module manages applicationa and system variables that are
7:                    *          accesable over Modbus.
8:                   * Dependencies:    Other (.h) files if applicable, see below
9:                   * 1/3/13 -  Defined structs that used to register valid Modbus registers.
10:                   *          Only 30001 to 30201 and 40001 to 40201 numbered register addresses
11:                   *          will be used.  To save nv memory, the 30001 range will be normalized
12:                   *          down to the zero index in memory and the 40001 will be moved down
13:                   *          nv index 400.
14:                   *
15:                  *
16:                  **********************************************************************/
17:                  #include "../mem_mgr.h"
18:                  //This is the list of all configurable and accessable variables used in the system
19:                  
20:                  #define iUnitID 0;
21:                  #define iBaud 1;
22:                  #define iKFactor 2;
23:                  
24:                  cVar  u1Baud, unitID, kFactor, lowerAlarm;
25:                  
26:                  int test1, test2,test3, test4,test5;
27:                  //nvSysVar nvVar;
28:                  uChar varType = 0, xIndex = 0;
29:                  
30:                  
31:                  cVar *cVarPtr[] = {&unitID, &u1Baud, &kFactor, &lowerAlarm}; // For configurable
32:                  uChar nvCharBuffer[NV_BUFFSZ];
33:                  fiUnion tempNVVar;
34:                  
35:                  //void *pVars[3] = {&testUChar, &testChar, &testFloat};
36:                  //extern spiStatus cSPI2;
37:                  
38:                  
39:                  
40:                  //InitNVM
41:                  void LoadNVArray(void)
42:                  {
9D012104  27BDFFF8   ADDIU SP, SP, -8
9D012108  AFBE0004   SW S8, 4(SP)
9D01210C  03A0F021   ADDU S8, SP, ZERO
43:                      u1Baud.vType = typeUInt;
9D012110  24020004   ADDIU V0, ZERO, 4
9D012114  A3828250   SB V0, -32176(GP)
44:                      u1Baud.v.i = 1234;
9D012118  240204D2   ADDIU V0, ZERO, 1234
9D01211C  AF82824C   SW V0, -32180(GP)
45:                      unitID.vType = typeInt;
9D012120  24020003   ADDIU V0, ZERO, 3
9D012124  A3828230   SB V0, -32208(GP)
46:                      unitID.v.i = -1234;
9D012128  2402FB2E   ADDIU V0, ZERO, -1234
9D01212C  AF82822C   SW V0, -32212(GP)
47:                      kFactor.vType = typeFloat;
9D012130  24020005   ADDIU V0, ZERO, 5
9D012134  A382823C   SB V0, -32196(GP)
48:                      kFactor.v.f = 1234.5678;
9D012138  3C029D02   LUI V0, -25342
9D01213C  8C429464   LW V0, -27548(V0)
9D012140  AF828238   SW V0, -32200(GP)
49:                  
50:                  }
9D012144  03C0E821   ADDU SP, S8, ZERO
9D012148  8FBE0004   LW S8, 4(SP)
9D01214C  27BD0008   ADDIU SP, SP, 8
9D012150  03E00008   JR RA
9D012154  00000000   NOP
51:                  int WriteIndexedVariable(uShort MemIndex, double value)
52:                  {
9D012158  27BDFFE0   ADDIU SP, SP, -32
9D01215C  AFBF001C   SW RA, 28(SP)
9D012160  AFBE0018   SW S8, 24(SP)
9D012164  AFB00014   SW S0, 20(SP)
9D012168  03A0F021   ADDU S8, SP, ZERO
9D01216C  00801021   ADDU V0, A0, ZERO
9D012170  AFC50024   SW A1, 36(S8)
9D012174  A7C20020   SH V0, 32(S8)
53:                      
54:                      varType  = cVarPtr[MemIndex]->vType;
9D012178  97C30020   LHU V1, 32(S8)
9D01217C  3C02A000   LUI V0, -24576
9D012180  00031880   SLL V1, V1, 2
9D012184  244210E0   ADDIU V0, V0, 4320
9D012188  00621021   ADDU V0, V1, V0
9D01218C  8C420000   LW V0, 0(V0)
9D012190  90420004   LBU V0, 4(V0)
9D012194  A38280FC   SB V0, -32516(GP)
55:                      switch(varType)
9D012198  938280FC   LBU V0, -32516(GP)
9D01219C  24030004   ADDIU V1, ZERO, 4
9D0121A0  10430013   BEQ V0, V1, 0x9D0121F0
9D0121A4  00000000   NOP
9D0121A8  24030005   ADDIU V1, ZERO, 5
9D0121AC  1043001C   BEQ V0, V1, 0x9D012220
9D0121B0  00000000   NOP
9D0121B4  24030003   ADDIU V1, ZERO, 3
9D0121B8  14430022   BNE V0, V1, 0x9D012244
9D0121BC  00000000   NOP
56:                      {
57:                          case typeInt:
58:                              cVarPtr[MemIndex]->v.i = (int)value;
9D0121C0  97C30020   LHU V1, 32(S8)
9D0121C4  3C02A000   LUI V0, -24576
9D0121C8  00031880   SLL V1, V1, 2
9D0121CC  244210E0   ADDIU V0, V0, 4320
9D0121D0  00621021   ADDU V0, V1, V0
9D0121D4  8C500000   LW S0, 0(V0)
9D0121D8  8FC40024   LW A0, 36(S8)
9D0121DC  0F403A1E   JAL fptosi
9D0121E0  00000000   NOP
9D0121E4  AE020000   SW V0, 0(S0)
59:                  
60:                              break;
9D0121E8  0B404891   J 0x9D012244
9D0121EC  00000000   NOP
61:                          case typeUInt:
62:                              cVarPtr[MemIndex]->v.i = (uInt)value;
9D0121F0  97C30020   LHU V1, 32(S8)
9D0121F4  3C02A000   LUI V0, -24576
9D0121F8  00031880   SLL V1, V1, 2
9D0121FC  244210E0   ADDIU V0, V0, 4320
9D012200  00621021   ADDU V0, V1, V0
9D012204  8C500000   LW S0, 0(V0)
9D012208  8FC40024   LW A0, 36(S8)
9D01220C  0F403A3C   JAL __fixunssfsi
9D012210  00000000   NOP
9D012214  AE020000   SW V0, 0(S0)
63:                              break;
9D012218  0B404891   J 0x9D012244
9D01221C  00000000   NOP
64:                          case typeFloat:
65:                              cVarPtr[MemIndex]->v.f = (float)value;
9D012220  97C30020   LHU V1, 32(S8)
9D012224  3C02A000   LUI V0, -24576
9D012228  00031880   SLL V1, V1, 2
9D01222C  244210E0   ADDIU V0, V0, 4320
9D012230  00621021   ADDU V0, V1, V0
9D012234  8C420000   LW V0, 0(V0)
9D012238  8FC30024   LW V1, 36(S8)
9D01223C  AC430000   SW V1, 0(V0)
66:                              break;
9D012240  00000000   NOP
67:                      }
68:                  }
9D012244  03C0E821   ADDU SP, S8, ZERO
9D012248  8FBF001C   LW RA, 28(SP)
9D01224C  8FBE0018   LW S8, 24(SP)
9D012250  8FB00014   LW S0, 20(SP)
9D012254  27BD0020   ADDIU SP, SP, 32
9D012258  03E00008   JR RA
9D01225C  00000000   NOP
69:                  int ReadIndexedVariable(uShort MemIndex,double Value)
70:                  {
9D012260  27BDFFF8   ADDIU SP, SP, -8
9D012264  AFBE0004   SW S8, 4(SP)
9D012268  03A0F021   ADDU S8, SP, ZERO
9D01226C  00801021   ADDU V0, A0, ZERO
9D012270  AFC5000C   SW A1, 12(S8)
9D012274  A7C20008   SH V0, 8(S8)
71:                  
72:                  }
9D012278  03C0E821   ADDU SP, S8, ZERO
9D01227C  8FBE0004   LW S8, 4(SP)
9D012280  27BD0008   ADDIU SP, SP, 8
9D012284  03E00008   JR RA
9D012288  00000000   NOP
73:                  char WriteNVMemory(uShort RegAddress,uShort NumRegs, uInt *Data)
74:                  {
9D01228C  27BDFFE0   ADDIU SP, SP, -32
9D012290  AFBF001C   SW RA, 28(SP)
9D012294  AFBE0018   SW S8, 24(SP)
9D012298  03A0F021   ADDU S8, SP, ZERO
9D01229C  00801821   ADDU V1, A0, ZERO
9D0122A0  00A01021   ADDU V0, A1, ZERO
9D0122A4  AFC60028   SW A2, 40(S8)
9D0122A8  A7C30020   SH V1, 32(S8)
9D0122AC  A7C20024   SH V0, 36(S8)
75:                      int Index = 0;
9D0122B0  AFC00010   SW ZERO, 16(S8)
76:                      
77:                      //Find out if variable to be modified is a float
78:                  
79:                      for(;Index < NumRegs; Index++)
9D0122B4  0B4048CC   J 0x9D012330
9D0122B8  00000000   NOP
9D012324  8FC20010   LW V0, 16(S8)
9D012328  24420001   ADDIU V0, V0, 1
9D01232C  AFC20010   SW V0, 16(S8)
9D012330  97C30024   LHU V1, 36(S8)
9D012334  8FC20010   LW V0, 16(S8)
9D012338  0043102A   SLT V0, V0, V1
9D01233C  1440FFDF   BNE V0, ZERO, 0x9D0122BC
9D012340  00000000   NOP
80:                      {
81:                          nvCharBuffer[Index * 2] = Data[Index] >> 8;
9D0122BC  8FC20010   LW V0, 16(S8)
9D0122C0  00022040   SLL A0, V0, 1
9D0122C4  8FC20010   LW V0, 16(S8)
9D0122C8  00021080   SLL V0, V0, 2
9D0122CC  8FC30028   LW V1, 40(S8)
9D0122D0  00621021   ADDU V0, V1, V0
9D0122D4  8C420000   LW V0, 0(V0)
9D0122D8  00021202   SRL V0, V0, 8
9D0122DC  304300FF   ANDI V1, V0, 255
9D0122E0  3C02A000   LUI V0, -24576
9D0122E4  24420878   ADDIU V0, V0, 2168
9D0122E8  00821021   ADDU V0, A0, V0
9D0122EC  A0430000   SB V1, 0(V0)
82:                          nvCharBuffer[(Index * 2) + 1] = Data[Index] & 0x00FF;
9D0122F0  8FC20010   LW V0, 16(S8)
9D0122F4  00021040   SLL V0, V0, 1
9D0122F8  24440001   ADDIU A0, V0, 1
9D0122FC  8FC20010   LW V0, 16(S8)
9D012300  00021080   SLL V0, V0, 2
9D012304  8FC30028   LW V1, 40(S8)
9D012308  00621021   ADDU V0, V1, V0
9D01230C  8C420000   LW V0, 0(V0)
9D012310  304300FF   ANDI V1, V0, 255
9D012314  3C02A000   LUI V0, -24576
9D012318  24420878   ADDIU V0, V0, 2168
9D01231C  00821021   ADDU V0, A0, V0
9D012320  A0430000   SB V1, 0(V0)
83:                      }//MBSTART_NV_MEMSTART moves the index pointer from 4000 down to zero
84:                      RT_WriteChars(RegAddress - MBSTART_NV_MEMSTART, NumRegs *2, nvCharBuffer);
9D012344  97C20020   LHU V0, 32(S8)
9D012348  2442F060   ADDIU V0, V0, -4000
9D01234C  00401821   ADDU V1, V0, ZERO
9D012350  97C20024   LHU V0, 36(S8)
9D012354  00021040   SLL V0, V0, 1
9D012358  00602021   ADDU A0, V1, ZERO
9D01235C  00402821   ADDU A1, V0, ZERO
9D012360  3C02A000   LUI V0, -24576
9D012364  24460878   ADDIU A2, V0, 2168
9D012368  0F4030C1   JAL RT_WriteChars
9D01236C  00000000   NOP
85:                      
86:                      //Look through all the registed address and see if this is a good one
87:                      //What type of variable is it
88:                      return 2;
9D012370  24020002   ADDIU V0, ZERO, 2
89:                  }
9D012374  03C0E821   ADDU SP, S8, ZERO
9D012378  8FBF001C   LW RA, 28(SP)
9D01237C  8FBE0018   LW S8, 24(SP)
9D012380  27BD0020   ADDIU SP, SP, 32
9D012384  03E00008   JR RA
9D012388  00000000   NOP
90:                  int NVMemory2MBReg(int RegAdd, uShort NumRegs, uShort *Data)
91:                  {
9D01238C  27BDFFF8   ADDIU SP, SP, -8
9D012390  AFBE0004   SW S8, 4(SP)
9D012394  03A0F021   ADDU S8, SP, ZERO
9D012398  AFC40008   SW A0, 8(S8)
9D01239C  00A01021   ADDU V0, A1, ZERO
9D0123A0  AFC60010   SW A2, 16(S8)
9D0123A4  A7C2000C   SH V0, 12(S8)
92:                      test2 = cVarPtr[0]->v.i;
9D0123A8  3C02A000   LUI V0, -24576
9D0123AC  8C4210E0   LW V0, 4320(V0)
9D0123B0  8C420000   LW V0, 0(V0)
9D0123B4  AF828254   SW V0, -32172(GP)
93:                      test1 = cVarPtr[RegAdd - 4000]->vType;
9D0123B8  8FC20008   LW V0, 8(S8)
9D0123BC  2443F060   ADDIU V1, V0, -4000
9D0123C0  3C02A000   LUI V0, -24576
9D0123C4  00031880   SLL V1, V1, 2
9D0123C8  244210E0   ADDIU V0, V0, 4320
9D0123CC  00621021   ADDU V0, V1, V0
9D0123D0  8C420000   LW V0, 0(V0)
9D0123D4  90420004   LBU V0, 4(V0)
9D0123D8  AF828240   SW V0, -32192(GP)
94:                      Data[RegAdd - 4000] = cVarPtr[RegAdd - 4000]->vType;
9D0123DC  8FC20008   LW V0, 8(S8)
9D0123E0  2442F060   ADDIU V0, V0, -4000
9D0123E4  00021040   SLL V0, V0, 1
9D0123E8  8FC30010   LW V1, 16(S8)
9D0123EC  00621021   ADDU V0, V1, V0
9D0123F0  8FC30008   LW V1, 8(S8)
9D0123F4  2464F060   ADDIU A0, V1, -4000
9D0123F8  3C03A000   LUI V1, -24576
9D0123FC  00042080   SLL A0, A0, 2
9D012400  246310E0   ADDIU V1, V1, 4320
9D012404  00831821   ADDU V1, A0, V1
9D012408  8C630000   LW V1, 0(V1)
9D01240C  90630004   LBU V1, 4(V1)
9D012410  A4430000   SH V1, 0(V0)
95:                      
96:                      
97:                      return 2;
9D012414  24020002   ADDIU V0, ZERO, 2
98:                  }
9D012418  03C0E821   ADDU SP, S8, ZERO
9D01241C  8FBE0004   LW S8, 4(SP)
9D012420  27BD0008   ADDIU SP, SP, 8
9D012424  03E00008   JR RA
9D012428  00000000   NOP
99:                  char WriteDefaults2NVMemory(uShort numVariables)
100:                 {
9D01242C  27BDFFF8   ADDIU SP, SP, -8
9D012430  AFBE0004   SW S8, 4(SP)
9D012434  03A0F021   ADDU S8, SP, ZERO
9D012438  00801021   ADDU V0, A0, ZERO
9D01243C  A7C20008   SH V0, 8(S8)
101:                     /*
102:                     sysVar[0].varAddress = &unitID;
103:                     sysVar[0].varType = typeInt;
104:                     sysVar[1].varAddress = &lowerAlarm;
105:                     sysVar[1].varType = typeInt;
106:                     sysVar[2].varAddress = &kFactor;
107:                     sysVar[2].varType = typeFloat;*/
108:                 /*
109:                     uInt x = 0;
110:                     for(;x < numVariables; x++)
111:                     {   
112:                         if(sysVar[x].varType == typeFloat)
113:                         {
114:                             tempNVVar.i = (int)sysVar[x].varAddress;
115:                         }
116:                         else
117:                         {         
118:                             tempNVVar.i = (int)sysVar[x].varAddress;
119:                         }
120:                         nvCharBuffer[0] = tempNVVar.c[0];
121:                         nvCharBuffer[1] = tempNVVar.c[1];
122:                         nvCharBuffer[2] = tempNVVar.c[2];
123:                         nvCharBuffer[3] = tempNVVar.c[3];
124:                         Chars2Ramtron(x*4, 4, nvCharBuffer);
125:                     }*/
126:                 }
9D012440  03C0E821   ADDU SP, S8, ZERO
9D012444  8FBE0004   LW S8, 4(SP)
9D012448  27BD0008   ADDIU SP, SP, 8
9D01244C  03E00008   JR RA
9D012450  00000000   NOP
127:                 
128:                 
129:                 char WriteMBVariable(uShort RegAddress,uShort NumRegs, uShort *Data)
130:                 {
9D012454  27BDFFF8   ADDIU SP, SP, -8
9D012458  AFBE0004   SW S8, 4(SP)
9D01245C  03A0F021   ADDU S8, SP, ZERO
9D012460  00801821   ADDU V1, A0, ZERO
9D012464  00A01021   ADDU V0, A1, ZERO
9D012468  AFC60010   SW A2, 16(S8)
9D01246C  A7C30008   SH V1, 8(S8)
9D012470  A7C2000C   SH V0, 12(S8)
131:                     if(RegAddress > MBSTART_LOWERBOUNDS)//Check lower bounds
9D012474  97C20008   LHU V0, 8(S8)
9D012478  2C420F8D   SLTIU V0, V0, 3981
9D01247C  14400008   BNE V0, ZERO, 0x9D0124A0
9D012480  00000000   NOP
132:                     {
133:                         if(RegAddress < MBSTART_NV_MEMSTART)//Do MBSTART_INPUT_REGS
134:                         {
135:                             //Not Persistent
136:                         }
137:                         if(RegAddress < MBSTART_UPPERBOUNDS) // Do MBSTART_NV_MEMSTART
9D012484  97C20008   LHU V0, 8(S8)
9D012488  2C420FD2   SLTIU V0, V0, 4050
9D01248C  14400007   BNE V0, ZERO, 0x9D0124AC
9D012490  00000000   NOP
138:                         {
139:                             //Persistent
140:                             
141:                         }
142:                         else return 4;
9D012494  24020004   ADDIU V0, ZERO, 4
9D012498  0B40492D   J 0x9D0124B4
9D01249C  00000000   NOP
143:                     }
144:                     else return 4;// bad address
9D0124A0  24020004   ADDIU V0, ZERO, 4
9D0124A4  0B40492D   J 0x9D0124B4
9D0124A8  00000000   NOP
9D0124AC  0B40492D   J 0x9D0124B4
9D0124B0  00000000   NOP
145:                 
146:                 }
9D0124B4  03C0E821   ADDU SP, S8, ZERO
9D0124B8  8FBE0004   LW S8, 4(SP)
9D0124BC  27BD0008   ADDIU SP, SP, 8
9D0124C0  03E00008   JR RA
9D0124C4  00000000   NOP
147:                 char ReadMBVariable(uShort RegAddress,uShort NumRegs, uShort *Data)
148:                 {
9D0124C8  27BDFFF8   ADDIU SP, SP, -8
9D0124CC  AFBE0004   SW S8, 4(SP)
9D0124D0  03A0F021   ADDU S8, SP, ZERO
9D0124D4  00801821   ADDU V1, A0, ZERO
9D0124D8  00A01021   ADDU V0, A1, ZERO
9D0124DC  AFC60010   SW A2, 16(S8)
9D0124E0  A7C30008   SH V1, 8(S8)
9D0124E4  A7C2000C   SH V0, 12(S8)
149:                 
150:                 }
9D0124E8  03C0E821   ADDU SP, S8, ZERO
9D0124EC  8FBE0004   LW S8, 4(SP)
9D0124F0  27BD0008   ADDIU SP, SP, 8
9D0124F4  03E00008   JR RA
9D0124F8  00000000   NOP
151:                 /*
152:                 int  ChangeVarValue(uInt Index, nvSysVar *Data)
153:                 {
154:                 
155:                 }
156:                 */
157:                 void SetNVMemory2Defaults(uShort Defaults
158:                 )
159:                 {
9D0124FC  27BDFFF8   ADDIU SP, SP, -8
9D012500  AFBE0004   SW S8, 4(SP)
9D012504  03A0F021   ADDU S8, SP, ZERO
9D012508  00801021   ADDU V0, A0, ZERO
9D01250C  A7C20008   SH V0, 8(S8)
160:                 
161:                 }
9D012510  03C0E821   ADDU SP, S8, ZERO
9D012514  8FBE0004   LW S8, 4(SP)
9D012518  27BD0008   ADDIU SP, SP, 8
9D01251C  03E00008   JR RA
9D012520  00000000   NOP
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/lcd_interface.c  -------------------------------------------
1:                   
2:                   #include "../lcd_interface.h"
3:                   #include "../TouchScreen.h"
4:                   #include <stdio.h>
5:                   #include <string.h>
6:                   
7:                   tButton *CurrentTouchPad;
8:                   
9:                   tButton FloatPad[]={
10:                                          {271,110,BTN_W,BTN_H,"-","-",1},
11:                                          {6,155,BTN_W,BTN_H,"5","5",1},
12:                                          {59,155,BTN_W,BTN_H,"6","6",1},
13:                                          {112,155,BTN_W,BTN_H,"7","7",1},
14:                                          {165,155,BTN_W,BTN_H,"8","8",1},
15:                                          {218,155,BTN_W,BTN_H,"9","9",1},
16:                                          {271,155,BTN_W,BTN_H,".",".",1},
17:                                          {6,200,BTN_W,BTN_H,"0","0",1},
18:                                          {59,200,BTN_W,BTN_H,"1","1",1},
19:                                          {112,200,BTN_W,BTN_H,"2","2",1},
20:                                          {165,200,BTN_W,BTN_H,"3","3",1},
21:                                          {218,200,BTN_W,BTN_H,"4","4",1},
22:                                          {271,200,BTN_W,BTN_H,{0x0D,0x00},"RTN",1},
23:                                          {271,65,BTN_W,BTN_H,{0x08,0x00},"BS",0}
24:                  							
25:                  };
26:                  
27:                  tButton NavigationPad[]={	
28:                                          {271,155,BTN_W,BTN_H,{0x1B,0x00},"ESC",1},
29:                                          {6,200,BTN_W,BTN_H,"1","1",1},
30:                                          {59,200,BTN_W,BTN_H,"2","2",1},
31:                                          {112,200,BTN_W,BTN_H,"3","3",1},
32:                                          {165,200,BTN_W,BTN_H,"4","4",1},
33:                                          {218,200,BTN_W,BTN_H,"5","5",1},
34:                                          {271,200,BTN_W,BTN_H,"6","6",0}
35:                  							
36:                  };
37:                  
38:                  tButton StartPad[] = {{6,6,308,228,{0x1B,0x00},"",0}};
39:                  tButton YesNoPad[]={
40:                                      {49,195,55,BTN_H + 10,"1","Yes",1},
41:                                      {105,195,55,BTN_H + 10,"0","No",0}
42:                      
43:                  };
44:                  tButton PlusMinusPad[] ={
45:                                          {259,38,55,42,"+","+",1},
46:                                          {259,84,55,42,{0x0D,0x00},"RTN",1},
47:                                          {259,174,55,42,"-","-",0},
48:                  };
49:                  void CalibrateTouch(void)
50:                  {
9D00B058  27BDFFC0   ADDIU SP, SP, -64
9D00B05C  AFBF003C   SW RA, 60(SP)
9D00B060  AFBE0038   SW S8, 56(SP)
9D00B064  03A0F021   ADDU S8, SP, ZERO
51:                      short xTouch = -1, xMin = -1, yMin, xMax = -1, yMax;
9D00B068  2402FFFF   ADDIU V0, ZERO, -1
9D00B06C  A7C20010   SH V0, 16(S8)
9D00B070  2402FFFF   ADDIU V0, ZERO, -1
9D00B074  A7C20012   SH V0, 18(S8)
9D00B078  2402FFFF   ADDIU V0, ZERO, -1
9D00B07C  A7C20016   SH V0, 22(S8)
52:                      char s[25];
53:                      //Capture (0,0) position first
54:                      MakeTouchButton(270,5,"X");
9D00B080  2404010E   ADDIU A0, ZERO, 270
9D00B084  24050005   ADDIU A1, ZERO, 5
9D00B088  3C029D02   LUI V0, -25342
9D00B08C  244692C0   ADDIU A2, V0, -27968
9D00B090  0F402CE9   JAL MakeTouchButton
9D00B094  00000000   NOP
55:                      while(xTouch < 0)
9D00B098  0B402C48   J 0x9D00B120
9D00B09C  00000000   NOP
9D00B120  87C20010   LH V0, 16(S8)
9D00B124  0440FFDE   BLTZ V0, 0x9D00B0A0
9D00B128  00000000   NOP
56:                      {
57:                          RunTouchScreen();
9D00B0A0  0F403A99   JAL RunTouchScreen
9D00B0A4  00000000   NOP
58:                          yMin = ADCGetY();
9D00B0A8  97828016   LHU V0, -32746(GP)
9D00B0AC  A7C20014   SH V0, 20(S8)
59:                          if(yMin == -1 ) // yResults could be -1
9D00B0B0  87C30014   LH V1, 20(S8)
9D00B0B4  2402FFFF   ADDIU V0, ZERO, -1
9D00B0B8  1462000F   BNE V1, V0, 0x9D00B0F8
9D00B0BC  00000000   NOP
60:                          {
61:                              xMin = ADCGetX();
9D00B0C0  97828014   LHU V0, -32748(GP)
9D00B0C4  A7C20012   SH V0, 18(S8)
62:                              {
63:                                  if(xMin != -1) //Chances that both are really -1 is remote
9D00B0C8  87C30012   LH V1, 18(S8)
9D00B0CC  2402FFFF   ADDIU V0, ZERO, -1
9D00B0D0  10620013   BEQ V1, V0, 0x9D00B120
9D00B0D4  00000000   NOP
64:                                  {
65:                                      xTouch = 1; // Accept that yMin is -1
9D00B0D8  24020001   ADDIU V0, ZERO, 1
9D00B0DC  A7C20010   SH V0, 16(S8)
66:                                      xMin = ADCGetX();
9D00B0E0  97828014   LHU V0, -32748(GP)
9D00B0E4  A7C20012   SH V0, 18(S8)
67:                                      yMin = ADCGetY();
9D00B0E8  97828016   LHU V0, -32746(GP)
9D00B0EC  A7C20014   SH V0, 20(S8)
9D00B0F0  0B402C48   J 0x9D00B120
9D00B0F4  00000000   NOP
68:                                  }
69:                              }
70:                          }
71:                          else if(yMin != -1)
9D00B0F8  87C30014   LH V1, 20(S8)
9D00B0FC  2402FFFF   ADDIU V0, ZERO, -1
9D00B100  10620007   BEQ V1, V0, 0x9D00B120
9D00B104  00000000   NOP
72:                          {
73:                              xMin = ADCGetX();
9D00B108  97828014   LHU V0, -32748(GP)
9D00B10C  A7C20012   SH V0, 18(S8)
74:                              yMin = ADCGetY();
9D00B110  97828016   LHU V0, -32746(GP)
9D00B114  A7C20014   SH V0, 20(S8)
75:                              xTouch = 1; // Accept that yMin is -1
9D00B118  24020001   ADDIU V0, ZERO, 1
9D00B11C  A7C20010   SH V0, 16(S8)
76:                          }
77:                      }
78:                  
79:                      xTouch = 1;
9D00B12C  24020001   ADDIU V0, ZERO, 1
9D00B130  A7C20010   SH V0, 16(S8)
80:                      sprintf(s,"Coord Min=(%d,%d)\n",xMin,yMin);
9D00B134  87C30012   LH V1, 18(S8)
9D00B138  87C20014   LH V0, 20(S8)
9D00B13C  27C4001C   ADDIU A0, S8, 28
9D00B140  3C059D02   LUI A1, -25342
9D00B144  24A592C4   ADDIU A1, A1, -27964
9D00B148  00603021   ADDU A2, V1, ZERO
9D00B14C  00403821   ADDU A3, V0, ZERO
9D00B150  0F40627D   JAL sprintf
9D00B154  00000000   NOP
81:                      LCDPutString(s);
9D00B158  27C2001C   ADDIU V0, S8, 28
9D00B15C  00402021   ADDU A0, V0, ZERO
9D00B160  0F403370   JAL LCDPutString
9D00B164  00000000   NOP
82:                      //DelayMs(200);    
83:                  
84:                      while(xTouch > 0)
9D00B168  0B402C61   J 0x9D00B184
9D00B16C  00000000   NOP
9D00B184  87C20010   LH V0, 16(S8)
9D00B188  1C40FFF9   BGTZ V0, 0x9D00B170
9D00B18C  00000000   NOP
85:                      {
86:                          RunTouchScreen();
9D00B170  0F403A99   JAL RunTouchScreen
9D00B174  00000000   NOP
87:                          xTouch = TouchGetX();
9D00B178  0F403C13   JAL TouchGetX
9D00B17C  00000000   NOP
9D00B180  A7C20010   SH V0, 16(S8)
88:                      }
89:                      MakeTouchButton(5,200,"X");   
9D00B190  24040005   ADDIU A0, ZERO, 5
9D00B194  240500C8   ADDIU A1, ZERO, 200
9D00B198  3C029D02   LUI V0, -25342
9D00B19C  244692C0   ADDIU A2, V0, -27968
9D00B1A0  0F402CE9   JAL MakeTouchButton
9D00B1A4  00000000   NOP
90:                      xTouch = -1;
9D00B1A8  2402FFFF   ADDIU V0, ZERO, -1
9D00B1AC  A7C20010   SH V0, 16(S8)
91:                      while(xTouch < 0)
9D00B1B0  0B402C93   J 0x9D00B24C
9D00B1B4  00000000   NOP
9D00B24C  87C20010   LH V0, 16(S8)
9D00B250  0440FFD9   BLTZ V0, 0x9D00B1B8
9D00B254  00000000   NOP
92:                      {
93:                          RunTouchScreen();
9D00B1B8  0F403A99   JAL RunTouchScreen
9D00B1BC  00000000   NOP
94:                          yMax= TouchGetY();
9D00B1C0  0F403C35   JAL TouchGetY
9D00B1C4  00000000   NOP
9D00B1C8  A7C20018   SH V0, 24(S8)
95:                          if(yMax == -1 ) // yResults could really be -1
9D00B1CC  87C30018   LH V1, 24(S8)
9D00B1D0  2402FFFF   ADDIU V0, ZERO, -1
9D00B1D4  14620010   BNE V1, V0, 0x9D00B218
9D00B1D8  00000000   NOP
96:                          {
97:                              xMax = TouchGetX();
9D00B1DC  0F403C13   JAL TouchGetX
9D00B1E0  00000000   NOP
9D00B1E4  A7C20016   SH V0, 22(S8)
98:                              {
99:                                  if(xMax != -1) //Chances
9D00B1E8  87C30016   LH V1, 22(S8)
9D00B1EC  2402FFFF   ADDIU V0, ZERO, -1
9D00B1F0  10620016   BEQ V1, V0, 0x9D00B24C
9D00B1F4  00000000   NOP
100:                                 {
101:                                     xTouch = 1; // Accept that yMin is -1
9D00B1F8  24020001   ADDIU V0, ZERO, 1
9D00B1FC  A7C20010   SH V0, 16(S8)
102:                                     xMin = ADCGetX();
9D00B200  97828014   LHU V0, -32748(GP)
9D00B204  A7C20012   SH V0, 18(S8)
103:                                     yMin = ADCGetY();
9D00B208  97828016   LHU V0, -32746(GP)
9D00B20C  A7C20014   SH V0, 20(S8)
9D00B210  0B402C93   J 0x9D00B24C
9D00B214  00000000   NOP
104:                                 }
105:                             }
106:                         }
107:                         else if(yMax != -1)
9D00B218  87C30018   LH V1, 24(S8)
9D00B21C  2402FFFF   ADDIU V0, ZERO, -1
9D00B220  1062000A   BEQ V1, V0, 0x9D00B24C
9D00B224  00000000   NOP
108:                         {
109:                             xMax = TouchGetX();
9D00B228  0F403C13   JAL TouchGetX
9D00B22C  00000000   NOP
9D00B230  A7C20016   SH V0, 22(S8)
110:                             xMax = ADCGetX();
9D00B234  97828014   LHU V0, -32748(GP)
9D00B238  A7C20016   SH V0, 22(S8)
111:                             yMax = ADCGetY();
9D00B23C  97828016   LHU V0, -32746(GP)
9D00B240  A7C20018   SH V0, 24(S8)
112:                             xTouch = 1; // Accept that yMin is -1
9D00B244  24020001   ADDIU V0, ZERO, 1
9D00B248  A7C20010   SH V0, 16(S8)
113:                         }
114:                     }
115:                 
116:                     xTouch = 1;
9D00B258  24020001   ADDIU V0, ZERO, 1
9D00B25C  A7C20010   SH V0, 16(S8)
117:                     sprintf(s,"Coords=(%d,%d)\n",xMax,yMax);
9D00B260  87C30016   LH V1, 22(S8)
9D00B264  87C20018   LH V0, 24(S8)
9D00B268  27C4001C   ADDIU A0, S8, 28
9D00B26C  3C059D02   LUI A1, -25342
9D00B270  24A592D8   ADDIU A1, A1, -27944
9D00B274  00603021   ADDU A2, V1, ZERO
9D00B278  00403821   ADDU A3, V0, ZERO
9D00B27C  0F40627D   JAL sprintf
9D00B280  00000000   NOP
118:                     LCDPutString(s);
9D00B284  27C2001C   ADDIU V0, S8, 28
9D00B288  00402021   ADDU A0, V0, ZERO
9D00B28C  0F403370   JAL LCDPutString
9D00B290  00000000   NOP
119:                     // Sreen is divided into 12 sections of which the two previous
120:                     // key presses captured only 10.  To find the zero coords and the 
121:                     // ratio of touch distance to pixals, expand touch distace to full extent
122:                     // by added one of the unincluded sections to the max and subtracting  the other
123:                     // from the min coords
124:                     xTouch = (xMax - xMin)/10;
9D00B294  87C30016   LH V1, 22(S8)
9D00B298  87C20012   LH V0, 18(S8)
9D00B29C  00621823   SUBU V1, V1, V0
9D00B2A0  2402000A   ADDIU V0, ZERO, 10
9D00B2A4  0062001A   DIV V1, V0
9D00B2A8  004001F4   TEQ V0, ZERO
9D00B2AC  00001810   MFHI V1
9D00B2B0  00001012   MFLO V0
9D00B2B4  A7C20010   SH V0, 16(S8)
125:                     xMin -= xTouch;
9D00B2B8  97C30012   LHU V1, 18(S8)
9D00B2BC  97C20010   LHU V0, 16(S8)
9D00B2C0  00621023   SUBU V0, V1, V0
9D00B2C4  3042FFFF   ANDI V0, V0, -1
9D00B2C8  A7C20012   SH V0, 18(S8)
126:                     xMax += xTouch - 25;
9D00B2CC  97C30010   LHU V1, 16(S8)
9D00B2D0  97C20016   LHU V0, 22(S8)
9D00B2D4  00621021   ADDU V0, V1, V0
9D00B2D8  3042FFFF   ANDI V0, V0, -1
9D00B2DC  2442FFE7   ADDIU V0, V0, -25
9D00B2E0  3042FFFF   ANDI V0, V0, -1
9D00B2E4  A7C20016   SH V0, 22(S8)
127:                     xTouch = (yMax - yMin)/10;
9D00B2E8  87C30018   LH V1, 24(S8)
9D00B2EC  87C20014   LH V0, 20(S8)
9D00B2F0  00621823   SUBU V1, V1, V0
9D00B2F4  2402000A   ADDIU V0, ZERO, 10
9D00B2F8  0062001A   DIV V1, V0
9D00B2FC  004001F4   TEQ V0, ZERO
9D00B300  00001810   MFHI V1
9D00B304  00001012   MFLO V0
9D00B308  A7C20010   SH V0, 16(S8)
128:                     yMin -= xTouch;
9D00B30C  97C30014   LHU V1, 20(S8)
9D00B310  97C20010   LHU V0, 16(S8)
9D00B314  00621023   SUBU V0, V1, V0
9D00B318  3042FFFF   ANDI V0, V0, -1
9D00B31C  A7C20014   SH V0, 20(S8)
129:                     yMax += xTouch + 10;
9D00B320  97C30010   LHU V1, 16(S8)
9D00B324  97C20018   LHU V0, 24(S8)
9D00B328  00621021   ADDU V0, V1, V0
9D00B32C  3042FFFF   ANDI V0, V0, -1
9D00B330  2442000A   ADDIU V0, V0, 10
9D00B334  3042FFFF   ANDI V0, V0, -1
9D00B338  A7C20018   SH V0, 24(S8)
130:                     while(xTouch > 0)
9D00B33C  0B402CD6   J 0x9D00B358
9D00B340  00000000   NOP
9D00B358  87C20010   LH V0, 16(S8)
9D00B35C  1C40FFF9   BGTZ V0, 0x9D00B344
9D00B360  00000000   NOP
131:                     {
132:                         RunTouchScreen();
9D00B344  0F403A99   JAL RunTouchScreen
9D00B348  00000000   NOP
133:                         xTouch = TouchGetX();
9D00B34C  0F403C13   JAL TouchGetX
9D00B350  00000000   NOP
9D00B354  A7C20010   SH V0, 16(S8)
134:                     }
135:                     
136:                     StoreCalFactors(xMin,xMax,yMin,yMax);
9D00B364  87C40012   LH A0, 18(S8)
9D00B368  87C50016   LH A1, 22(S8)
9D00B36C  87C30014   LH V1, 20(S8)
9D00B370  87C20018   LH V0, 24(S8)
9D00B374  00603021   ADDU A2, V1, ZERO
9D00B378  00403821   ADDU A3, V0, ZERO
9D00B37C  0F403C57   JAL StoreCalFactors
9D00B380  00000000   NOP
137:                     //StoreCalFactors(100,100,100,100);
138:                     TouchLoadCalibration();
9D00B384  0F403C9F   JAL TouchLoadCalibration
9D00B388  00000000   NOP
139:                 }
9D00B38C  03C0E821   ADDU SP, S8, ZERO
9D00B390  8FBF003C   LW RA, 60(SP)
9D00B394  8FBE0038   LW S8, 56(SP)
9D00B398  27BD0040   ADDIU SP, SP, 64
9D00B39C  03E00008   JR RA
9D00B3A0  00000000   NOP
140:                 void MakeTouchButton(int x, int y, char *lable)
141:                 {
9D00B3A4  27BDFFD8   ADDIU SP, SP, -40
9D00B3A8  AFBF0024   SW RA, 36(SP)
9D00B3AC  AFBE0020   SW S8, 32(SP)
9D00B3B0  03A0F021   ADDU S8, SP, ZERO
9D00B3B4  AFC40028   SW A0, 40(S8)
9D00B3B8  AFC5002C   SW A1, 44(S8)
9D00B3BC  AFC60030   SW A2, 48(S8)
142:                     Arc(x,y,x+BTN_W,y+BTN_H,4,5,0xff);
9D00B3C0  8FC20028   LW V0, 40(S8)
9D00B3C4  7C021620   SEH V0, V0
9D00B3C8  00402021   ADDU A0, V0, ZERO
9D00B3CC  8FC2002C   LW V0, 44(S8)
9D00B3D0  7C021620   SEH V0, V0
9D00B3D4  00402821   ADDU A1, V0, ZERO
9D00B3D8  8FC20028   LW V0, 40(S8)
9D00B3DC  3042FFFF   ANDI V0, V0, -1
9D00B3E0  2442002A   ADDIU V0, V0, 42
9D00B3E4  3042FFFF   ANDI V0, V0, -1
9D00B3E8  7C021620   SEH V0, V0
9D00B3EC  00401821   ADDU V1, V0, ZERO
9D00B3F0  8FC2002C   LW V0, 44(S8)
9D00B3F4  3042FFFF   ANDI V0, V0, -1
9D00B3F8  24420022   ADDIU V0, V0, 34
9D00B3FC  3042FFFF   ANDI V0, V0, -1
9D00B400  7C021620   SEH V0, V0
9D00B404  24060004   ADDIU A2, ZERO, 4
9D00B408  AFA60010   SW A2, 16(SP)
9D00B40C  24060005   ADDIU A2, ZERO, 5
9D00B410  AFA60014   SW A2, 20(SP)
9D00B414  240600FF   ADDIU A2, ZERO, 255
9D00B418  AFA60018   SW A2, 24(SP)
9D00B41C  00603021   ADDU A2, V1, ZERO
9D00B420  00403821   ADDU A3, V0, ZERO
9D00B424  0F400033   JAL Arc
9D00B428  00000000   NOP
143:                     x += (BTN_W/2) - (FONT_W/2);
9D00B42C  8FC20028   LW V0, 40(S8)
9D00B430  2442000F   ADDIU V0, V0, 15
9D00B434  AFC20028   SW V0, 40(S8)
144:                     y += (BTN_H/2) - (FONT_H/2);
9D00B438  8FC2002C   LW V0, 44(S8)
9D00B43C  24420007   ADDIU V0, V0, 7
9D00B440  AFC2002C   SW V0, 44(S8)
145:                     OutTextXY(x,y,lable);
9D00B444  8FC20028   LW V0, 40(S8)
9D00B448  7C021620   SEH V0, V0
9D00B44C  00401821   ADDU V1, V0, ZERO
9D00B450  8FC2002C   LW V0, 44(S8)
9D00B454  7C021620   SEH V0, V0
9D00B458  00602021   ADDU A0, V1, ZERO
9D00B45C  00402821   ADDU A1, V0, ZERO
9D00B460  8FC60030   LW A2, 48(S8)
9D00B464  0F4007F8   JAL OutTextXY
9D00B468  00000000   NOP
146:                 }
9D00B46C  03C0E821   ADDU SP, S8, ZERO
9D00B470  8FBF0024   LW RA, 36(SP)
9D00B474  8FBE0020   LW S8, 32(SP)
9D00B478  27BD0028   ADDIU SP, SP, 40
9D00B47C  03E00008   JR RA
9D00B480  00000000   NOP
147:                 
148:                 void MakeButtonRow(short x, short y, short l, short h, short num, short rows)
149:                 {
9D00B484  27BDFFC0   ADDIU SP, SP, -64
9D00B488  AFBF003C   SW RA, 60(SP)
9D00B48C  AFBE0038   SW S8, 56(SP)
9D00B490  03A0F021   ADDU S8, SP, ZERO
9D00B494  00804821   ADDU T1, A0, ZERO
9D00B498  00A04021   ADDU T0, A1, ZERO
9D00B49C  00C02821   ADDU A1, A2, ZERO
9D00B4A0  00E02021   ADDU A0, A3, ZERO
9D00B4A4  8FC30050   LW V1, 80(S8)
9D00B4A8  8FC20054   LW V0, 84(S8)
9D00B4AC  A7C90040   SH T1, 64(S8)
9D00B4B0  A7C80044   SH T0, 68(S8)
9D00B4B4  A7C50048   SH A1, 72(S8)
9D00B4B8  A7C4004C   SH A0, 76(S8)
9D00B4BC  A7C30030   SH V1, 48(S8)
9D00B4C0  A7C20034   SH V0, 52(S8)
150:                     short index1,index2,sX,sY,offset, yOffset;
151:                     offset = 10;  //Need to move the button over the width of the arc in Arc()(4th param)
9D00B4C4  2402000A   ADDIU V0, ZERO, 10
9D00B4C8  A7C20024   SH V0, 36(S8)
152:                     yOffset = 8;
9D00B4CC  24020008   ADDIU V0, ZERO, 8
9D00B4D0  A7C20026   SH V0, 38(S8)
153:                     sX = x;
9D00B4D4  97C20040   LHU V0, 64(S8)
9D00B4D8  A7C20028   SH V0, 40(S8)
154:                     sY = y;
9D00B4DC  97C20044   LHU V0, 68(S8)
9D00B4E0  A7C2002A   SH V0, 42(S8)
155:                     for(index1 = 0; index1 < rows; index1++)
9D00B4E4  A7C00020   SH ZERO, 32(S8)
9D00B4E8  0B402DC1   J 0x9D00B704
9D00B4EC  00000000   NOP
9D00B6F8  97C20020   LHU V0, 32(S8)
9D00B6FC  24420001   ADDIU V0, V0, 1
9D00B700  A7C20020   SH V0, 32(S8)
9D00B704  87C30020   LH V1, 32(S8)
9D00B708  87C20034   LH V0, 52(S8)
9D00B70C  0062102A   SLT V0, V1, V0
9D00B710  1440FF77   BNE V0, ZERO, 0x9D00B4F0
9D00B714  00000000   NOP
156:                     {
157:                         for(index2 = 0; index2 < num; index2++)
9D00B4F0  A7C00022   SH ZERO, 34(S8)
9D00B4F4  0B402DB9   J 0x9D00B6E4
9D00B4F8  00000000   NOP
9D00B6D8  97C20022   LHU V0, 34(S8)
9D00B6DC  24420001   ADDIU V0, V0, 1
9D00B6E0  A7C20022   SH V0, 34(S8)
9D00B6E4  87C30022   LH V1, 34(S8)
9D00B6E8  87C20030   LH V0, 48(S8)
9D00B6EC  0062102A   SLT V0, V1, V0
9D00B6F0  1440FF82   BNE V0, ZERO, 0x9D00B4FC
9D00B6F4  00000000   NOP
158:                         {
159:                                 Arc(x + ((l + offset) * index2),
9D00B4FC  87C30048   LH V1, 72(S8)
9D00B500  87C20024   LH V0, 36(S8)
9D00B504  00621021   ADDU V0, V1, V0
9D00B508  3043FFFF   ANDI V1, V0, -1
9D00B50C  97C20022   LHU V0, 34(S8)
9D00B510  70621002   MUL V0, V1, V0
9D00B514  3043FFFF   ANDI V1, V0, -1
9D00B518  97C20040   LHU V0, 64(S8)
9D00B51C  00621021   ADDU V0, V1, V0
9D00B520  3042FFFF   ANDI V0, V0, -1
9D00B524  7C021620   SEH V0, V0
9D00B528  00402021   ADDU A0, V0, ZERO
9D00B538  3043FFFF   ANDI V1, V0, -1
9D00B53C  97C20020   LHU V0, 32(S8)
9D00B540  70621002   MUL V0, V1, V0
9D00B544  3043FFFF   ANDI V1, V0, -1
9D00B548  97C20044   LHU V0, 68(S8)
9D00B54C  00621021   ADDU V0, V1, V0
9D00B550  3042FFFF   ANDI V0, V0, -1
9D00B554  7C021620   SEH V0, V0
9D00B558  00402821   ADDU A1, V0, ZERO
9D00B568  3043FFFF   ANDI V1, V0, -1
9D00B56C  97C20022   LHU V0, 34(S8)
9D00B570  70621002   MUL V0, V1, V0
9D00B574  3043FFFF   ANDI V1, V0, -1
9D00B578  97C20040   LHU V0, 64(S8)
9D00B57C  00621021   ADDU V0, V1, V0
9D00B580  3043FFFF   ANDI V1, V0, -1
9D00B584  97C20048   LHU V0, 72(S8)
9D00B588  00621021   ADDU V0, V1, V0
9D00B58C  3042FFFF   ANDI V0, V0, -1
9D00B590  7C021620   SEH V0, V0
9D00B594  00401821   ADDU V1, V0, ZERO
9D00B5A4  3046FFFF   ANDI A2, V0, -1
9D00B5A8  97C20020   LHU V0, 32(S8)
9D00B5AC  70C21002   MUL V0, A2, V0
9D00B5B0  3046FFFF   ANDI A2, V0, -1
9D00B5B4  97C20044   LHU V0, 68(S8)
9D00B5B8  00C21021   ADDU V0, A2, V0
9D00B5BC  3046FFFF   ANDI A2, V0, -1
9D00B5C0  97C2004C   LHU V0, 76(S8)
9D00B5C4  00C21021   ADDU V0, A2, V0
9D00B5C8  3042FFFF   ANDI V0, V0, -1
9D00B5CC  7C021620   SEH V0, V0
9D00B5D0  24060004   ADDIU A2, ZERO, 4
9D00B5D4  AFA60010   SW A2, 16(SP)
9D00B5D8  24060005   ADDIU A2, ZERO, 5
9D00B5DC  AFA60014   SW A2, 20(SP)
9D00B5E0  240600FF   ADDIU A2, ZERO, 255
9D00B5E4  AFA60018   SW A2, 24(SP)
9D00B5E8  00603021   ADDU A2, V1, ZERO
9D00B5EC  00403821   ADDU A3, V0, ZERO
9D00B5F0  0F400033   JAL Arc
9D00B5F4  00000000   NOP
160:                                         y + (h + yOffset) *index1,
9D00B52C  87C3004C   LH V1, 76(S8)
9D00B530  87C20026   LH V0, 38(S8)
9D00B534  00621021   ADDU V0, V1, V0
161:                                         x + ((l + offset)  * index2) + l,
9D00B55C  87C30048   LH V1, 72(S8)
9D00B560  87C20024   LH V0, 36(S8)
9D00B564  00621021   ADDU V0, V1, V0
162:                                         y + (h + yOffset) * index1 + h,4,5,0xff);
9D00B598  87C6004C   LH A2, 76(S8)
9D00B59C  87C20026   LH V0, 38(S8)
9D00B5A0  00C21021   ADDU V0, A2, V0
163:                                         sX = (x + ((l + offset) * index2)) + (l/2) - (FONT_W/2);
9D00B5F8  87C30048   LH V1, 72(S8)
9D00B5FC  87C20024   LH V0, 36(S8)
9D00B600  00621021   ADDU V0, V1, V0
9D00B604  3043FFFF   ANDI V1, V0, -1
9D00B608  97C20022   LHU V0, 34(S8)
9D00B60C  70621002   MUL V0, V1, V0
9D00B610  3043FFFF   ANDI V1, V0, -1
9D00B614  97C20040   LHU V0, 64(S8)
9D00B618  00621021   ADDU V0, V1, V0
9D00B61C  3043FFFF   ANDI V1, V0, -1
9D00B620  87C20048   LH V0, 72(S8)
9D00B624  000227C2   SRL A0, V0, 31
9D00B628  00821021   ADDU V0, A0, V0
9D00B62C  00021043   SRA V0, V0, 1
9D00B630  7C021620   SEH V0, V0
9D00B634  3042FFFF   ANDI V0, V0, -1
9D00B638  00621021   ADDU V0, V1, V0
9D00B63C  3042FFFF   ANDI V0, V0, -1
9D00B640  2442FFFA   ADDIU V0, V0, -6
9D00B644  3042FFFF   ANDI V0, V0, -1
9D00B648  A7C20028   SH V0, 40(S8)
164:                                         sY = (y + ((h + yOffset) * index1)) + ((h + yOffset)/2) - (FONT_H/2);
9D00B64C  87C3004C   LH V1, 76(S8)
9D00B650  87C20026   LH V0, 38(S8)
9D00B654  00621021   ADDU V0, V1, V0
9D00B658  3043FFFF   ANDI V1, V0, -1
9D00B65C  97C20020   LHU V0, 32(S8)
9D00B660  70621002   MUL V0, V1, V0
9D00B664  3043FFFF   ANDI V1, V0, -1
9D00B668  97C20044   LHU V0, 68(S8)
9D00B66C  00621021   ADDU V0, V1, V0
9D00B670  3043FFFF   ANDI V1, V0, -1
9D00B674  87C4004C   LH A0, 76(S8)
9D00B678  87C20026   LH V0, 38(S8)
9D00B67C  00821021   ADDU V0, A0, V0
9D00B680  000227C2   SRL A0, V0, 31
9D00B684  00821021   ADDU V0, A0, V0
9D00B688  00021043   SRA V0, V0, 1
9D00B68C  3042FFFF   ANDI V0, V0, -1
9D00B690  00621021   ADDU V0, V1, V0
9D00B694  3042FFFF   ANDI V0, V0, -1
9D00B698  2442FFF6   ADDIU V0, V0, -10
9D00B69C  3042FFFF   ANDI V0, V0, -1
9D00B6A0  A7C2002A   SH V0, 42(S8)
165:                                         //sprintf(numKeyPad[index2].keyPress,"%d",index2*(index1+1));
166:                                         OutTextXY(sX,sY,FloatPad[index2].keyPress);
9D00B6A4  87C40028   LH A0, 40(S8)
9D00B6A8  87C3002A   LH V1, 42(S8)
9D00B6AC  87C50022   LH A1, 34(S8)
9D00B6B0  24020012   ADDIU V0, ZERO, 18
9D00B6B4  70A21002   MUL V0, A1, V0
9D00B6B8  24450008   ADDIU A1, V0, 8
9D00B6BC  3C02A000   LUI V0, -24576
9D00B6C0  244208B8   ADDIU V0, V0, 2232
9D00B6C4  00A21021   ADDU V0, A1, V0
9D00B6C8  00602821   ADDU A1, V1, ZERO
9D00B6CC  00403021   ADDU A2, V0, ZERO
9D00B6D0  0F4007F8   JAL OutTextXY
9D00B6D4  00000000   NOP
167:                         }
168:                     }
169:                 	
170:                 }
9D00B718  03C0E821   ADDU SP, S8, ZERO
9D00B71C  8FBF003C   LW RA, 60(SP)
9D00B720  8FBE0038   LW S8, 56(SP)
9D00B724  27BD0040   ADDIU SP, SP, 64
9D00B728  03E00008   JR RA
9D00B72C  00000000   NOP
171:                 
172:                 
173:                 void BuildTouchPad(tButton *TouchPad, int Color )
174:                 {
9D00B730  27BDFFC8   ADDIU SP, SP, -56
9D00B734  AFBF0034   SW RA, 52(SP)
9D00B738  AFBE0030   SW S8, 48(SP)
9D00B73C  AFB0002C   SW S0, 44(SP)
9D00B740  03A0F021   ADDU S8, SP, ZERO
9D00B744  AFC40038   SW A0, 56(S8)
9D00B748  AFC5003C   SW A1, 60(S8)
175:                     SetColor(Color);
9D00B74C  8FC2003C   LW V0, 60(S8)
9D00B750  3042FFFF   ANDI V0, V0, -1
9D00B754  A7828198   SH V0, -32360(GP)
176:                     _cursorX = 0;
9D00B758  A78081B0   SH ZERO, -32336(GP)
177:                     _cursorY = 0;
9D00B75C  A78081A6   SH ZERO, -32346(GP)
178:                     if(TouchPad != NULL)
9D00B760  8FC20038   LW V0, 56(S8)
9D00B764  1040007C   BEQ V0, ZERO, 0x9D00B958
9D00B768  00000000   NOP
179:                     {
180:                         CurrentTouchPad = TouchPad;
9D00B76C  8FC20038   LW V0, 56(S8)
9D00B770  AF828200   SW V0, -32256(GP)
181:                 	short index = 0,tX,tY;
9D00B774  A7C00020   SH ZERO, 32(S8)
182:                 	do
183:                 	{
184:                             Arc(CurrentTouchPad[index].x,
9D00B778  8F828200   LW V0, -32256(GP)
9D00B77C  87C40020   LH A0, 32(S8)
9D00B780  24030012   ADDIU V1, ZERO, 18
9D00B784  70831802   MUL V1, A0, V1
9D00B788  00431021   ADDU V0, V0, V1
9D00B78C  84420000   LH V0, 0(V0)
9D00B790  00402021   ADDU A0, V0, ZERO
9D00B7AC  00402821   ADDU A1, V0, ZERO
9D00B7C8  3043FFFF   ANDI V1, V0, -1
9D00B7E4  3042FFFF   ANDI V0, V0, -1
9D00B7E8  00621021   ADDU V0, V1, V0
9D00B7EC  3042FFFF   ANDI V0, V0, -1
9D00B7F0  7C021620   SEH V0, V0
9D00B7F4  00401821   ADDU V1, V0, ZERO
9D00B810  3046FFFF   ANDI A2, V0, -1
9D00B82C  3042FFFF   ANDI V0, V0, -1
9D00B830  00C21021   ADDU V0, A2, V0
9D00B834  3042FFFF   ANDI V0, V0, -1
9D00B838  7C021620   SEH V0, V0
9D00B83C  24060004   ADDIU A2, ZERO, 4
9D00B840  AFA60010   SW A2, 16(SP)
9D00B844  24060005   ADDIU A2, ZERO, 5
9D00B848  AFA60014   SW A2, 20(SP)
9D00B84C  240600FF   ADDIU A2, ZERO, 255
9D00B850  AFA60018   SW A2, 24(SP)
9D00B854  00603021   ADDU A2, V1, ZERO
9D00B858  00403821   ADDU A3, V0, ZERO
9D00B85C  0F400033   JAL Arc
9D00B860  00000000   NOP
185:                                    CurrentTouchPad[index].y,
9D00B794  8F828200   LW V0, -32256(GP)
9D00B798  87C50020   LH A1, 32(S8)
9D00B79C  24030012   ADDIU V1, ZERO, 18
9D00B7A0  70A31802   MUL V1, A1, V1
9D00B7A4  00431021   ADDU V0, V0, V1
9D00B7A8  84420002   LH V0, 2(V0)
186:                                    CurrentTouchPad[index].x + CurrentTouchPad[index].width,
9D00B7B0  8F828200   LW V0, -32256(GP)
9D00B7B4  87C60020   LH A2, 32(S8)
9D00B7B8  24030012   ADDIU V1, ZERO, 18
9D00B7BC  70C31802   MUL V1, A2, V1
9D00B7C0  00431021   ADDU V0, V0, V1
9D00B7C4  84420000   LH V0, 0(V0)
9D00B7CC  8F828200   LW V0, -32256(GP)
9D00B7D0  87C70020   LH A3, 32(S8)
9D00B7D4  24060012   ADDIU A2, ZERO, 18
9D00B7D8  70E63002   MUL A2, A3, A2
9D00B7DC  00461021   ADDU V0, V0, A2
9D00B7E0  84420004   LH V0, 4(V0)
187:                                    CurrentTouchPad[index].y + CurrentTouchPad[index].height,
9D00B7F8  8F828200   LW V0, -32256(GP)
9D00B7FC  87C70020   LH A3, 32(S8)
9D00B800  24060012   ADDIU A2, ZERO, 18
9D00B804  70E63002   MUL A2, A3, A2
9D00B808  00461021   ADDU V0, V0, A2
9D00B80C  84420002   LH V0, 2(V0)
9D00B814  8F828200   LW V0, -32256(GP)
9D00B818  87C80020   LH T0, 32(S8)
9D00B81C  24070012   ADDIU A3, ZERO, 18
9D00B820  71073802   MUL A3, T0, A3
9D00B824  00471021   ADDU V0, V0, A3
9D00B828  84420006   LH V0, 6(V0)
188:                                     4,5,
189:                                     0xff);
190:                             //Center and print text
191:                             tX = CurrentTouchPad[index].x + (BTN_W/2) - ((FONT_W*strlen(CurrentTouchPad[index].lable))/2);
9D00B864  8F828200   LW V0, -32256(GP)
9D00B868  87C40020   LH A0, 32(S8)
9D00B86C  24030012   ADDIU V1, ZERO, 18
9D00B870  70831802   MUL V1, A0, V1
9D00B874  00431021   ADDU V0, V0, V1
9D00B878  84420000   LH V0, 0(V0)
9D00B87C  3050FFFF   ANDI S0, V0, -1
9D00B880  8F828200   LW V0, -32256(GP)
9D00B884  87C40020   LH A0, 32(S8)
9D00B888  24030012   ADDIU V1, ZERO, 18
9D00B88C  70831802   MUL V1, A0, V1
9D00B890  00431021   ADDU V0, V0, V1
9D00B894  2442000B   ADDIU V0, V0, 11
9D00B898  00402021   ADDU A0, V0, ZERO
9D00B89C  0F405AFD   JAL 0x9D016BF4
9D00B8A0  00000000   NOP
9D00B8A4  00401821   ADDU V1, V0, ZERO
9D00B8A8  2402000C   ADDIU V0, ZERO, 12
9D00B8AC  70621002   MUL V0, V1, V0
9D00B8B0  00021042   SRL V0, V0, 1
9D00B8B4  3042FFFF   ANDI V0, V0, -1
9D00B8B8  02021023   SUBU V0, S0, V0
9D00B8BC  3042FFFF   ANDI V0, V0, -1
9D00B8C0  24420015   ADDIU V0, V0, 21
9D00B8C4  3042FFFF   ANDI V0, V0, -1
9D00B8C8  A7C20022   SH V0, 34(S8)
192:                             tY = CurrentTouchPad[index].y + (BTN_H/2) - (FONT_H/2);
9D00B8CC  8F828200   LW V0, -32256(GP)
9D00B8D0  87C40020   LH A0, 32(S8)
9D00B8D4  24030012   ADDIU V1, ZERO, 18
9D00B8D8  70831802   MUL V1, A0, V1
9D00B8DC  00431021   ADDU V0, V0, V1
9D00B8E0  84420002   LH V0, 2(V0)
9D00B8E4  3042FFFF   ANDI V0, V0, -1
9D00B8E8  24420007   ADDIU V0, V0, 7
9D00B8EC  3042FFFF   ANDI V0, V0, -1
9D00B8F0  A7C20024   SH V0, 36(S8)
193:                             OutTextXY(tX,tY,CurrentTouchPad[index].lable);
9D00B8F4  87C40022   LH A0, 34(S8)
9D00B8F8  87C30024   LH V1, 36(S8)
9D00B8FC  8F828200   LW V0, -32256(GP)
9D00B900  87C60020   LH A2, 32(S8)
9D00B904  24050012   ADDIU A1, ZERO, 18
9D00B908  70C52802   MUL A1, A2, A1
9D00B90C  00451021   ADDU V0, V0, A1
9D00B910  2442000B   ADDIU V0, V0, 11
9D00B914  00602821   ADDU A1, V1, ZERO
9D00B918  00403021   ADDU A2, V0, ZERO
9D00B91C  0F4007F8   JAL OutTextXY
9D00B920  00000000   NOP
194:                 	}while(CurrentTouchPad[index++].moreKeys);// if moreKey != 0 there are more CurrentKeyPad in the array
9D00B924  8F828200   LW V0, -32256(GP)
9D00B928  87C40020   LH A0, 32(S8)
9D00B92C  24030012   ADDIU V1, ZERO, 18
9D00B930  70831802   MUL V1, A0, V1
9D00B934  00431021   ADDU V0, V0, V1
9D00B938  80420010   LB V0, 16(V0)
9D00B93C  0002102B   SLTU V0, ZERO, V0
9D00B940  304200FF   ANDI V0, V0, 255
9D00B944  97C30020   LHU V1, 32(S8)
9D00B948  24630001   ADDIU V1, V1, 1
9D00B94C  A7C30020   SH V1, 32(S8)
9D00B950  1440FF89   BNE V0, ZERO, 0x9D00B778
9D00B954  00000000   NOP
195:                     }
196:                 }
9D00B958  03C0E821   ADDU SP, S8, ZERO
9D00B95C  8FBF0034   LW RA, 52(SP)
9D00B960  8FBE0030   LW S8, 48(SP)
9D00B964  8FB0002C   LW S0, 44(SP)
9D00B968  27BD0038   ADDIU SP, SP, 56
9D00B96C  03E00008   JR RA
9D00B970  00000000   NOP
197:                 
198:                 char* GetTouchPress(char *tP)
199:                 {
9D00B974  27BDFFE0   ADDIU SP, SP, -32
9D00B978  AFBF001C   SW RA, 28(SP)
9D00B97C  AFBE0018   SW S8, 24(SP)
9D00B980  03A0F021   ADDU S8, SP, ZERO
9D00B984  AFC40020   SW A0, 32(S8)
200:                     short index = 0, xCoord, yCoord;
9D00B988  A7C00010   SH ZERO, 16(S8)
201:                     xCoord = LCD_WIDTH - TouchGetX() ;
9D00B98C  0F403C13   JAL TouchGetX
9D00B990  00000000   NOP
9D00B994  3042FFFF   ANDI V0, V0, -1
9D00B998  24030140   ADDIU V1, ZERO, 320
9D00B99C  00621023   SUBU V0, V1, V0
9D00B9A0  3042FFFF   ANDI V0, V0, -1
9D00B9A4  A7C20012   SH V0, 18(S8)
202:                     yCoord = TouchGetY();
9D00B9A8  0F403C35   JAL TouchGetY
9D00B9AC  00000000   NOP
9D00B9B0  A7C20014   SH V0, 20(S8)
203:                     if(CurrentTouchPad != NULL)
9D00B9B4  8F828200   LW V0, -32256(GP)
9D00B9B8  10400053   BEQ V0, ZERO, 0x9D00BB08
9D00B9BC  00000000   NOP
204:                     {
205:                 	do
206:                 	{
207:                             if(xCoord > CurrentTouchPad[index].x)
9D00B9C0  8F828200   LW V0, -32256(GP)
9D00B9C4  87C40010   LH A0, 16(S8)
9D00B9C8  24030012   ADDIU V1, ZERO, 18
9D00B9CC  70831802   MUL V1, A0, V1
9D00B9D0  00431021   ADDU V0, V0, V1
9D00B9D4  84420000   LH V0, 0(V0)
9D00B9D8  87C30012   LH V1, 18(S8)
9D00B9DC  0043102A   SLT V0, V0, V1
9D00B9E0  1040003C   BEQ V0, ZERO, 0x9D00BAD4
9D00B9E4  00000000   NOP
208:                             {
209:                                 if(xCoord < (CurrentTouchPad[index].x + CurrentTouchPad[index].height))
9D00B9E8  87C30012   LH V1, 18(S8)
9D00B9EC  8F828200   LW V0, -32256(GP)
9D00B9F0  87C50010   LH A1, 16(S8)
9D00B9F4  24040012   ADDIU A0, ZERO, 18
9D00B9F8  70A42002   MUL A0, A1, A0
9D00B9FC  00441021   ADDU V0, V0, A0
9D00BA00  84420000   LH V0, 0(V0)
9D00BA04  00402021   ADDU A0, V0, ZERO
9D00BA08  8F828200   LW V0, -32256(GP)
9D00BA0C  87C60010   LH A2, 16(S8)
9D00BA10  24050012   ADDIU A1, ZERO, 18
9D00BA14  70C52802   MUL A1, A2, A1
9D00BA18  00451021   ADDU V0, V0, A1
9D00BA1C  84420006   LH V0, 6(V0)
9D00BA20  00821021   ADDU V0, A0, V0
9D00BA24  0062102A   SLT V0, V1, V0
9D00BA28  1040002A   BEQ V0, ZERO, 0x9D00BAD4
9D00BA2C  00000000   NOP
210:                                 {
211:                                     if(yCoord > CurrentTouchPad[index].y)
9D00BA30  8F828200   LW V0, -32256(GP)
9D00BA34  87C40010   LH A0, 16(S8)
9D00BA38  24030012   ADDIU V1, ZERO, 18
9D00BA3C  70831802   MUL V1, A0, V1
9D00BA40  00431021   ADDU V0, V0, V1
9D00BA44  84420002   LH V0, 2(V0)
9D00BA48  87C30014   LH V1, 20(S8)
9D00BA4C  0043102A   SLT V0, V0, V1
9D00BA50  10400020   BEQ V0, ZERO, 0x9D00BAD4
9D00BA54  00000000   NOP
212:                                     {
213:                                         if(yCoord < (CurrentTouchPad[index].y + CurrentTouchPad[index].width))
9D00BA58  87C30014   LH V1, 20(S8)
9D00BA5C  8F828200   LW V0, -32256(GP)
9D00BA60  87C50010   LH A1, 16(S8)
9D00BA64  24040012   ADDIU A0, ZERO, 18
9D00BA68  70A42002   MUL A0, A1, A0
9D00BA6C  00441021   ADDU V0, V0, A0
9D00BA70  84420002   LH V0, 2(V0)
9D00BA74  00402021   ADDU A0, V0, ZERO
9D00BA78  8F828200   LW V0, -32256(GP)
9D00BA7C  87C60010   LH A2, 16(S8)
9D00BA80  24050012   ADDIU A1, ZERO, 18
9D00BA84  70C52802   MUL A1, A2, A1
9D00BA88  00451021   ADDU V0, V0, A1
9D00BA8C  84420004   LH V0, 4(V0)
9D00BA90  00821021   ADDU V0, A0, V0
9D00BA94  0062102A   SLT V0, V1, V0
9D00BA98  1040000E   BEQ V0, ZERO, 0x9D00BAD4
9D00BA9C  00000000   NOP
214:                                         {
215:                                             strcpy(tP,CurrentTouchPad[index].keyPress);
9D00BAA0  8F828200   LW V0, -32256(GP)
9D00BAA4  87C40010   LH A0, 16(S8)
9D00BAA8  24030012   ADDIU V1, ZERO, 18
9D00BAAC  70831802   MUL V1, A0, V1
9D00BAB0  00431021   ADDU V0, V0, V1
9D00BAB4  24420008   ADDIU V0, V0, 8
9D00BAB8  8FC40020   LW A0, 32(S8)
9D00BABC  00402821   ADDU A1, V0, ZERO
9D00BAC0  0F4057FE   JAL 0x9D015FF8
9D00BAC4  00000000   NOP
216:                                             //tP = ;
217:                                             return tP;
9D00BAC8  8FC20020   LW V0, 32(S8)
9D00BACC  0B402EC4   J 0x9D00BB10
9D00BAD0  00000000   NOP
218:                                         }
219:                                     }
220:                                 }
221:                             }
222:                 	}while(CurrentTouchPad[index++].moreKeys);// if moreKeys != 0 there are more CurrentKeyPad in the array
9D00BAD4  8F828200   LW V0, -32256(GP)
9D00BAD8  87C40010   LH A0, 16(S8)
9D00BADC  24030012   ADDIU V1, ZERO, 18
9D00BAE0  70831802   MUL V1, A0, V1
9D00BAE4  00431021   ADDU V0, V0, V1
9D00BAE8  80420010   LB V0, 16(V0)
9D00BAEC  0002102B   SLTU V0, ZERO, V0
9D00BAF0  304200FF   ANDI V0, V0, 255
9D00BAF4  97C30010   LHU V1, 16(S8)
9D00BAF8  24630001   ADDIU V1, V1, 1
9D00BAFC  A7C30010   SH V1, 16(S8)
9D00BB00  1440FFAF   BNE V0, ZERO, 0x9D00B9C0
9D00BB04  00000000   NOP
223:                     }
224:                     return "";
9D00BB08  3C029D02   LUI V0, -25342
9D00BB0C  244292E8   ADDIU V0, V0, -27928
225:                 }
9D00BB10  03C0E821   ADDU SP, S8, ZERO
9D00BB14  8FBF001C   LW RA, 28(SP)
9D00BB18  8FBE0018   LW S8, 24(SP)
9D00BB1C  27BD0020   ADDIU SP, SP, 32
9D00BB20  03E00008   JR RA
9D00BB24  00000000   NOP
---  C:/MC_XProjects/LIBS/SYS_LIB/SYS_SOURCE/TouchScreen.c  ---------------------------------------------
1:                   /*****************************************************************************
2:                    *
3:                    * Simple 4 wire touch screen driver
4:                    *
5:                    *****************************************************************************
6:                    * FileName:        TouchScreen.c
7:                    * Dependencies:    MainDemo.h
8:                    * Processor:       PIC24, PIC32
9:                    * Compiler:       	MPLAB C30, MPLAB C32
10:                   * Linker:          MPLAB LINK30, MPLAB LINK32
11:                   * Company:         Microchip Technology Incorporated
12:                   *
13:                   * Software License Agreement
14:                   *
15:                   * Copyright © 2008 Microchip Technology Inc.  All rights reserved.
16:                   * Microchip licenses to you the right to use, modify, copy and distribute
17:                   * Software only when embedded on a Microchip microcontroller or digital
18:                   * signal controller, which is integrated into your product or third party
19:                   * product (pursuant to the sublicense terms in the accompanying license
20:                   * agreement).  
21:                   *
22:                   * You should refer to the license agreement accompanying this Software
23:                   * for additional information regarding your rights and obligations.
24:                   *
25:                   * SOFTWARE AND DOCUMENTATION ARE PROVIDED “AS IS” WITHOUT WARRANTY OF ANY
26:                   * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
27:                   * OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
28:                   * PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
29:                   * OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
30:                   * BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                   * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
32:                   * INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
33:                   * COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
34:                   * CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
35:                   * OR OTHER SIMILAR COSTS.
36:                   *
37:                   * Author               Date        Comment
38:                   *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
39:                   * Anton Alkhimenok		01/08/07	...
40:                   * Anton Alkhimenok		06/06/07	Basic calibration and GOL messaging are added
41:                   * Anton Alkhimenok     02/05/08    new PICtail support, portrait orientation is added
42:                   * Sean Justice         02/07/08    PIC32 support
43:                   * Anton Alkhimenok     05/27/08    More robust algorithm
44:                   *****************************************************************************/
45:                  
46:                  #include "Graphics\Graphics.h"
47:                  //#include "Graphics\Beep.h"
48:                  #include "Graphics\TouchScreen.h"
49:                  #include "serialEEPROM.h"
50:                  
51:                  //////////////////////// LOCAL PROTOTYPES ////////////////////////////
52:                  void TouchGetCalPoints(WORD* ax, WORD* ay);
53:                  
54:                  //////////////////////// GLOBAL VARIABLES ////////////////////////////
55:                  #define     SAMPLE_PERIOD      100     // us
56:                  //#define   PRESS_THRESHOULD   556     // between 0-0x03ff than less this value than harder screen must be pressed
57:                  #define     PRESS_THRESHOULD   256     // between 0-0x03ff than less this value than harder screen must be pressed
58:                  
59:                  // Max/Min ADC values for each derection
60:                  volatile WORD _calXMin = XMINCAL;
61:                  volatile WORD _calXMax = XMAXCAL;
62:                  volatile WORD _calYMin = YMINCAL;
63:                  volatile WORD _calYMax = YMAXCAL;
64:                  
65:                  // Current ADC values for X and Y channels
66:                  volatile SHORT adcX     = -1;
67:                  volatile SHORT adcY     = -1;
68:                  volatile SHORT adcPot   = 0;
69:                  
70:                  typedef enum{
71:                  SET_X,
72:                  RUN_X,
73:                  GET_X,
74:                  RUN_CHECK_X,
75:                  CHECK_X,
76:                  SET_Y,
77:                  RUN_Y,
78:                  GET_Y,
79:                  CHECK_Y,
80:                  SET_VALUES,
81:                  GET_POT,
82:                  RUN_POT
83:                  } TOUCH_STATES;
84:                  
85:                  volatile TOUCH_STATES state = SET_X;
86:                  /*********************************************************************
87:                  * Function: Timer3 ISR
88:                  *
89:                  * PreCondition: none
90:                  *
91:                  * Input: none
92:                  *
93:                  * Output: none
94:                  *
95:                  * Side Effects: none
96:                  *
97:                  * Overview: Timer3 ISR provides delay between 2 ADC conversions.
98:                  *           The delay provides debouncing for touch screen.
99:                  *
100:                 * Note: none
101:                 *
102:                 ********************************************************************/
103:                 /*JK remmed out and run out of main
104:                 #ifdef __PIC32MX__
105:                 #define __T3_ISR    __ISR(_TIMER_3_VECTOR, ipl4)
106:                 #else
107:                 #define __T3_ISR    __attribute__((interrupt, shadow, auto_psv))
108:                 #endif
109:                     
110:                 void __T3_ISR _T3Interrupt(void)
111:                 {
112:                 static SHORT tempX, tempY;
113:                 SHORT temp;
114:                 
115:                     switch(state){
116:                 
117:                         case SET_VALUES:
118:                             if(!AD1CON1bits.DONE)
119:                                 break;
120:                 
121:                             if( (WORD)PRESS_THRESHOULD < (WORD)ADC1BUF0 ){
122:                                 adcX = -1; adcY = -1;
123:                             }else{
124:                                 adcX = tempX; adcY = tempY;
125:                             }
126:                             state = RUN_POT;
127:                 
128:                         case RUN_POT:
129:                             AD1CHS = ADC_POT;      // switch ADC channel
130:                             AD1CON1bits.SAMP = 1;  // run conversion
131:                             state = GET_POT;
132:                             break;
133:                         
134:                         case GET_POT:
135:                             if(!AD1CON1bits.DONE)
136:                                 break;
137:                 
138:                             adcPot = ADC1BUF0;
139:                             state  = SET_X;
140:                 
141:                         case SET_X:
142:                             AD1CHS = ADC_XPOS;     // switch ADC channel
143:                 
144:                             ADPCFG_XPOS = 0;       // analog
145:                             ADPCFG_YPOS = 1;       // digital
146:                 
147:                             TRIS_XPOS = 1;
148:                             TRIS_YPOS = 1;
149:                             TRIS_XNEG = 1;
150:                             LAT_YNEG = 0;
151:                             TRIS_YNEG = 0;
152:                 
153:                             AD1CON1bits.SAMP = 1;  // run conversion
154:                             state = CHECK_X;
155:                             break;
156:                 
157:                         case CHECK_X:
158:                             if(!AD1CON1bits.DONE)
159:                                 break;
160:                 
161:                             if( (WORD)PRESS_THRESHOULD > (WORD)ADC1BUF0 ){
162:                                 LAT_YPOS  = 1;
163:                                 TRIS_YPOS = 0;
164:                                 tempX = -1;
165:                                 state = RUN_X;
166:                             }else{
167:                                 adcX = -1; adcY = -1;
168:                                 state = RUN_POT;
169:                                 break;
170:                             }
171:                 
172:                         case RUN_X:
173:                             AD1CON1bits.SAMP = 1;
174:                             state = GET_X;
175:                             break;
176:                 
177:                         case GET_X:
178:                             if(!AD1CON1bits.DONE)
179:                                 break;
180:                 
181:                             temp = ADC1BUF0;
182:                             if(temp != tempX){
183:                                 tempX = temp;
184:                                 state = RUN_X;
185:                                 break;                                
186:                             }
187:                             TRIS_YPOS = 1;
188:                             AD1CON1bits.SAMP = 1;
189:                             state = SET_Y;
190:                             break;
191:                 
192:                         case SET_Y:
193:                             if(!AD1CON1bits.DONE)
194:                                 break;
195:                 
196:                             if( (WORD)PRESS_THRESHOULD < (WORD)ADC1BUF0 ){
197:                                 adcX = -1; adcY = -1;
198:                                 state = RUN_POT;
199:                                 break;
200:                             }
201:                 
202:                             AD1CHS = ADC_YPOS;     // switch ADC channel
203:                 
204:                             ADPCFG_XPOS = 1;       // digital
205:                             ADPCFG_YPOS = 0;       // analog
206:                 
207:                             TRIS_XPOS = 1;
208:                             TRIS_YPOS = 1;
209:                             LAT_XNEG = 0;
210:                             TRIS_XNEG = 0;
211:                             TRIS_YNEG = 1;
212:                 
213:                             AD1CON1bits.SAMP = 1;  // run conversion
214:                             state = CHECK_Y;
215:                             break;
216:                 
217:                         case CHECK_Y:
218:                             if(!AD1CON1bits.DONE)
219:                                 break;
220:                 
221:                             if( (WORD)PRESS_THRESHOULD > (WORD)ADC1BUF0 ){
222:                                 LAT_XPOS  = 1;
223:                                 TRIS_XPOS = 0;
224:                                 tempY = -1;
225:                                 state = RUN_Y;
226:                             }else{
227:                                 adcX = -1; adcY = -1;
228:                                 state = RUN_POT;
229:                                 break;
230:                             }
231:                 
232:                         case RUN_Y:
233:                             AD1CON1bits.SAMP = 1;
234:                             state = GET_Y;
235:                             break;
236:                 
237:                         case GET_Y:
238:                             // Get Y value
239:                             if(!AD1CON1bits.DONE)
240:                                 break;
241:                 
242:                             temp = ADC1BUF0;
243:                             if(temp != tempY){
244:                                 tempY = temp;
245:                                 state = RUN_Y;
246:                                 break;                                
247:                             }
248:                             TRIS_XPOS = 1;
249:                             AD1CON1bits.SAMP = 1;
250:                             state = SET_VALUES;
251:                             break;
252:                 
253:                         default:
254:                             state = SET_X;
255:                     }
256:                     // Clear flag
257:                 #ifdef __PIC32MX__
258:                     mT3ClearIntFlag();
259:                 #else
260:                     IFS0bits.T3IF = 0;
261:                 #endif
262:                 
263:                 }*/
264:                 
265:                 void RunTouchScreen(void)
266:                 {
9D00EA64  27BDFFF0   ADDIU SP, SP, -16
9D00EA68  AFBE000C   SW S8, 12(SP)
9D00EA6C  03A0F021   ADDU S8, SP, ZERO
267:                 static SHORT tempX, tempY;
268:                 SHORT temp;
269:                 
270:                     switch(state)
9D00EA70  8F8280C0   LW V0, -32576(GP)
9D00EA74  2C43000C   SLTIU V1, V0, 12
9D00EA78  10600142   BEQ V1, ZERO, 0x9D00EF84
9D00EA7C  00000000   NOP
9D00EA80  00021880   SLL V1, V0, 2
9D00EA84  3C029D01   LUI V0, -25343
9D00EA88  2442EA9C   ADDIU V0, V0, -5476
9D00EA8C  00621021   ADDU V0, V1, V0
9D00EA90  8C420000   LW V0, 0(V0)
9D00EA94  00400008   JR V0
9D00EA98  00000000   NOP
271:                     {
272:                 
273:                         case SET_VALUES:
274:                             if(!AD1CON1bits.DONE)
9D00EACC  3C02BF81   LUI V0, -16511
9D00EAD0  8C429000   LW V0, -28672(V0)
9D00EAD4  30420001   ANDI V0, V0, 1
9D00EAD8  1040012D   BEQ V0, ZERO, 0x9D00EF90
9D00EADC  00000000   NOP
275:                                 break;
9D00EF90  00000000   NOP
9D00EF94  0B403BF7   J 0x9D00EFDC
9D00EF98  00000000   NOP
276:                 
277:                             if( (WORD)PRESS_THRESHOULD < (WORD)ADC1BUF0 ){
9D00EAE0  3C02BF81   LUI V0, -16511
9D00EAE4  8C429070   LW V0, -28560(V0)
9D00EAE8  3042FFFF   ANDI V0, V0, -1
9D00EAEC  2C420101   SLTIU V0, V0, 257
9D00EAF0  14400007   BNE V0, ZERO, 0x9D00EB10
9D00EAF4  00000000   NOP
278:                                 adcX = -1; adcY = -1;
9D00EAF8  2402FFFF   ADDIU V0, ZERO, -1
9D00EAFC  A7828014   SH V0, -32748(GP)
9D00EB00  2402FFFF   ADDIU V0, ZERO, -1
9D00EB04  A7828016   SH V0, -32746(GP)
9D00EB08  0B403AC8   J 0x9D00EB20
9D00EB0C  00000000   NOP
279:                             }else{
280:                                 adcX = tempX; adcY = tempY;
9D00EB10  878280C4   LH V0, -32572(GP)
9D00EB14  A7828014   SH V0, -32748(GP)
9D00EB18  878280C6   LH V0, -32570(GP)
9D00EB1C  A7828016   SH V0, -32746(GP)
281:                             }
282:                             state = RUN_POT;
9D00EB20  2402000B   ADDIU V0, ZERO, 11
9D00EB24  AF8280C0   SW V0, -32576(GP)
283:                 
284:                         case RUN_POT:
285:                             AD1CHS = ADC_POT;      // switch ADC channel
9D00EB28  3C02BF81   LUI V0, -16511
9D00EB2C  3C030005   LUI V1, 5
9D00EB30  AC439040   SW V1, -28608(V0)
286:                             AD1CON1bits.SAMP = 1;  // run conversion
9D00EB34  3C03BF81   LUI V1, -16511
9D00EB38  8C629000   LW V0, -28672(V1)
9D00EB3C  24040001   ADDIU A0, ZERO, 1
9D00EB40  7C820844   INS V0, A0, 1, 1
9D00EB44  AC629000   SW V0, -28672(V1)
287:                             state = GET_POT;
9D00EB48  2402000A   ADDIU V0, ZERO, 10
9D00EB4C  AF8280C0   SW V0, -32576(GP)
288:                             break;
9D00EB50  0B403BF7   J 0x9D00EFDC
9D00EB54  00000000   NOP
289:                 
290:                         case GET_POT:
291:                             if(!AD1CON1bits.DONE)
9D00EB58  3C02BF81   LUI V0, -16511
9D00EB5C  8C429000   LW V0, -28672(V0)
9D00EB60  30420001   ANDI V0, V0, 1
9D00EB64  1040010D   BEQ V0, ZERO, 0x9D00EF9C
9D00EB68  00000000   NOP
292:                                 break;
9D00EF9C  00000000   NOP
9D00EFA0  0B403BF7   J 0x9D00EFDC
9D00EFA4  00000000   NOP
293:                 
294:                             adcPot = ADC1BUF0;
9D00EB6C  3C02BF81   LUI V0, -16511
9D00EB70  8C429070   LW V0, -28560(V0)
9D00EB74  7C021620   SEH V0, V0
9D00EB78  A78280BC   SH V0, -32580(GP)
295:                             state  = SET_X;
9D00EB7C  AF8080C0   SW ZERO, -32576(GP)
296:                 
297:                         case SET_X:
298:                             AD1CHS = ADC_XPOS;     // switch ADC channel
9D00EB80  3C02BF81   LUI V0, -16511
9D00EB84  3C03000B   LUI V1, 11
9D00EB88  AC439040   SW V1, -28608(V0)
299:                 
300:                             ADPCFG_XPOS = 0;       // analog
9D00EB8C  3C03BF81   LUI V1, -16511
9D00EB90  8C629060   LW V0, -28576(V1)
9D00EB94  7C026B44   INS V0, ZERO, 13, 1
9D00EB98  AC629060   SW V0, -28576(V1)
301:                             ADPCFG_YPOS = 1;       // digital
9D00EB9C  3C03BF81   LUI V1, -16511
9D00EBA0  8C629060   LW V0, -28576(V1)
9D00EBA4  24040001   ADDIU A0, ZERO, 1
9D00EBA8  7C826304   INS V0, A0, 12, 1
9D00EBAC  AC629060   SW V0, -28576(V1)
302:                 
303:                             TRIS_XPOS = 1;
9D00EBB0  3C03BF88   LUI V1, -16504
9D00EBB4  8C626040   LW V0, 24640(V1)
9D00EBB8  24040001   ADDIU A0, ZERO, 1
9D00EBBC  7C826B44   INS V0, A0, 13, 1
9D00EBC0  AC626040   SW V0, 24640(V1)
304:                             TRIS_YPOS = 1;
9D00EBC4  3C03BF88   LUI V1, -16504
9D00EBC8  8C626040   LW V0, 24640(V1)
9D00EBCC  24040001   ADDIU A0, ZERO, 1
9D00EBD0  7C826304   INS V0, A0, 12, 1
9D00EBD4  AC626040   SW V0, 24640(V1)
305:                             TRIS_XNEG = 1;
9D00EBD8  3C03BF88   LUI V1, -16504
9D00EBDC  8C626040   LW V0, 24640(V1)
9D00EBE0  24040001   ADDIU A0, ZERO, 1
9D00EBE4  7C825AC4   INS V0, A0, 11, 1
9D00EBE8  AC626040   SW V0, 24640(V1)
306:                             LAT_YNEG = 0;
9D00EBEC  3C03BF88   LUI V1, -16504
9D00EBF0  8C626060   LW V0, 24672(V1)
9D00EBF4  7C025284   INS V0, ZERO, 10, 1
9D00EBF8  AC626060   SW V0, 24672(V1)
307:                             TRIS_YNEG = 0;
9D00EBFC  3C03BF88   LUI V1, -16504
9D00EC00  8C626040   LW V0, 24640(V1)
9D00EC04  7C025284   INS V0, ZERO, 10, 1
9D00EC08  AC626040   SW V0, 24640(V1)
308:                 
309:                             AD1CON1bits.SAMP = 1;  // run conversion
9D00EC0C  3C03BF81   LUI V1, -16511
9D00EC10  8C629000   LW V0, -28672(V1)
9D00EC14  24040001   ADDIU A0, ZERO, 1
9D00EC18  7C820844   INS V0, A0, 1, 1
9D00EC1C  AC629000   SW V0, -28672(V1)
310:                             state = CHECK_X;
9D00EC20  24020004   ADDIU V0, ZERO, 4
9D00EC24  AF8280C0   SW V0, -32576(GP)
311:                             break;
9D00EC28  0B403BF7   J 0x9D00EFDC
9D00EC2C  00000000   NOP
312:                 
313:                         case CHECK_X:
314:                             if(!AD1CON1bits.DONE)
9D00EC30  3C02BF81   LUI V0, -16511
9D00EC34  8C429000   LW V0, -28672(V0)
9D00EC38  30420001   ANDI V0, V0, 1
9D00EC3C  104000DA   BEQ V0, ZERO, 0x9D00EFA8
9D00EC40  00000000   NOP
315:                                 break;
9D00EFA8  00000000   NOP
9D00EFAC  0B403BF7   J 0x9D00EFDC
9D00EFB0  00000000   NOP
316:                 
317:                             if( (WORD)PRESS_THRESHOULD > (WORD)ADC1BUF0 ){
9D00EC44  3C02BF81   LUI V0, -16511
9D00EC48  8C429070   LW V0, -28560(V0)
9D00EC4C  3042FFFF   ANDI V0, V0, -1
9D00EC50  2C420100   SLTIU V0, V0, 256
9D00EC54  10400010   BEQ V0, ZERO, 0x9D00EC98
9D00EC58  00000000   NOP
318:                                 LAT_YPOS  = 1;
9D00EC5C  3C03BF88   LUI V1, -16504
9D00EC60  8C626060   LW V0, 24672(V1)
9D00EC64  24040001   ADDIU A0, ZERO, 1
9D00EC68  7C826304   INS V0, A0, 12, 1
9D00EC6C  AC626060   SW V0, 24672(V1)
319:                                 TRIS_YPOS = 0;
9D00EC70  3C03BF88   LUI V1, -16504
9D00EC74  8C626040   LW V0, 24640(V1)
9D00EC78  7C026304   INS V0, ZERO, 12, 1
9D00EC7C  AC626040   SW V0, 24640(V1)
320:                                 tempX = -1;
9D00EC80  2402FFFF   ADDIU V0, ZERO, -1
9D00EC84  A78280C4   SH V0, -32572(GP)
321:                                 state = RUN_X;
9D00EC88  24020001   ADDIU V0, ZERO, 1
9D00EC8C  AF8280C0   SW V0, -32576(GP)
9D00EC90  0B403B2E   J 0x9D00ECB8
9D00EC94  00000000   NOP
322:                             }else{
323:                                 adcX = -1; adcY = -1;
9D00EC98  2402FFFF   ADDIU V0, ZERO, -1
9D00EC9C  A7828014   SH V0, -32748(GP)
9D00ECA0  2402FFFF   ADDIU V0, ZERO, -1
9D00ECA4  A7828016   SH V0, -32746(GP)
324:                                 state = RUN_POT;
9D00ECA8  2402000B   ADDIU V0, ZERO, 11
9D00ECAC  AF8280C0   SW V0, -32576(GP)
325:                                 break;
9D00ECB0  0B403BF7   J 0x9D00EFDC
9D00ECB4  00000000   NOP
326:                             }
327:                 
328:                         case RUN_X:
329:                             AD1CON1bits.SAMP = 1;
9D00ECB8  3C03BF81   LUI V1, -16511
9D00ECBC  8C629000   LW V0, -28672(V1)
9D00ECC0  24040001   ADDIU A0, ZERO, 1
9D00ECC4  7C820844   INS V0, A0, 1, 1
9D00ECC8  AC629000   SW V0, -28672(V1)
330:                             state = GET_X;
9D00ECCC  24020002   ADDIU V0, ZERO, 2
9D00ECD0  AF8280C0   SW V0, -32576(GP)
331:                             break;
9D00ECD4  0B403BF7   J 0x9D00EFDC
9D00ECD8  00000000   NOP
332:                 
333:                         case GET_X:
334:                             if(!AD1CON1bits.DONE)
9D00ECDC  3C02BF81   LUI V0, -16511
9D00ECE0  8C429000   LW V0, -28672(V0)
9D00ECE4  30420001   ANDI V0, V0, 1
9D00ECE8  104000B2   BEQ V0, ZERO, 0x9D00EFB4
9D00ECEC  00000000   NOP
335:                                 break;
9D00EFB4  00000000   NOP
9D00EFB8  0B403BF7   J 0x9D00EFDC
9D00EFBC  00000000   NOP
336:                 
337:                             temp = ADC1BUF0;
9D00ECF0  3C02BF81   LUI V0, -16511
9D00ECF4  8C429070   LW V0, -28560(V0)
9D00ECF8  A7C20000   SH V0, 0(S8)
338:                             if(temp != tempX){
9D00ECFC  878280C4   LH V0, -32572(GP)
9D00ED00  87C30000   LH V1, 0(S8)
9D00ED04  10620007   BEQ V1, V0, 0x9D00ED24
9D00ED08  00000000   NOP
339:                                 tempX = temp;
9D00ED0C  97C20000   LHU V0, 0(S8)
9D00ED10  A78280C4   SH V0, -32572(GP)
340:                                 state = RUN_X;
9D00ED14  24020001   ADDIU V0, ZERO, 1
9D00ED18  AF8280C0   SW V0, -32576(GP)
341:                                 break;
9D00ED1C  0B403BF7   J 0x9D00EFDC
9D00ED20  00000000   NOP
342:                             }
343:                             TRIS_YPOS = 1;
9D00ED24  3C03BF88   LUI V1, -16504
9D00ED28  8C626040   LW V0, 24640(V1)
9D00ED2C  24040001   ADDIU A0, ZERO, 1
9D00ED30  7C826304   INS V0, A0, 12, 1
9D00ED34  AC626040   SW V0, 24640(V1)
344:                             AD1CON1bits.SAMP = 1;
9D00ED38  3C03BF81   LUI V1, -16511
9D00ED3C  8C629000   LW V0, -28672(V1)
9D00ED40  24040001   ADDIU A0, ZERO, 1
9D00ED44  7C820844   INS V0, A0, 1, 1
9D00ED48  AC629000   SW V0, -28672(V1)
345:                             state = SET_Y;
9D00ED4C  24020005   ADDIU V0, ZERO, 5
9D00ED50  AF8280C0   SW V0, -32576(GP)
346:                             break;
9D00ED54  0B403BF7   J 0x9D00EFDC
9D00ED58  00000000   NOP
347:                 
348:                         case SET_Y:
349:                             if(!AD1CON1bits.DONE)
9D00ED5C  3C02BF81   LUI V0, -16511
9D00ED60  8C429000   LW V0, -28672(V0)
9D00ED64  30420001   ANDI V0, V0, 1
9D00ED68  10400095   BEQ V0, ZERO, 0x9D00EFC0
9D00ED6C  00000000   NOP
350:                                 break;
9D00EFC0  00000000   NOP
9D00EFC4  0B403BF7   J 0x9D00EFDC
9D00EFC8  00000000   NOP
351:                 
352:                             if( (WORD)PRESS_THRESHOULD < (WORD)ADC1BUF0 ){
9D00ED70  3C02BF81   LUI V0, -16511
9D00ED74  8C429070   LW V0, -28560(V0)
9D00ED78  3042FFFF   ANDI V0, V0, -1
9D00ED7C  2C420101   SLTIU V0, V0, 257
9D00ED80  14400009   BNE V0, ZERO, 0x9D00EDA8
9D00ED84  00000000   NOP
353:                                 adcX = -1; adcY = -1;
9D00ED88  2402FFFF   ADDIU V0, ZERO, -1
9D00ED8C  A7828014   SH V0, -32748(GP)
9D00ED90  2402FFFF   ADDIU V0, ZERO, -1
9D00ED94  A7828016   SH V0, -32746(GP)
354:                                 state = RUN_POT;
9D00ED98  2402000B   ADDIU V0, ZERO, 11
9D00ED9C  AF8280C0   SW V0, -32576(GP)
355:                                 break;
9D00EDA0  0B403BF7   J 0x9D00EFDC
9D00EDA4  00000000   NOP
356:                             }
357:                 
358:                             AD1CHS = ADC_YPOS;     // switch ADC channel
9D00EDA8  3C02BF81   LUI V0, -16511
9D00EDAC  3C03000A   LUI V1, 10
9D00EDB0  AC439040   SW V1, -28608(V0)
359:                 
360:                             ADPCFG_XPOS = 1;       // digital
9D00EDB4  3C03BF81   LUI V1, -16511
9D00EDB8  8C629060   LW V0, -28576(V1)
9D00EDBC  24040001   ADDIU A0, ZERO, 1
9D00EDC0  7C826B44   INS V0, A0, 13, 1
9D00EDC4  AC629060   SW V0, -28576(V1)
361:                             ADPCFG_YPOS = 0;       // analog
9D00EDC8  3C03BF81   LUI V1, -16511
9D00EDCC  8C629060   LW V0, -28576(V1)
9D00EDD0  7C026304   INS V0, ZERO, 12, 1
9D00EDD4  AC629060   SW V0, -28576(V1)
362:                 
363:                             TRIS_XPOS = 1;
9D00EDD8  3C03BF88   LUI V1, -16504
9D00EDDC  8C626040   LW V0, 24640(V1)
9D00EDE0  24040001   ADDIU A0, ZERO, 1
9D00EDE4  7C826B44   INS V0, A0, 13, 1
9D00EDE8  AC626040   SW V0, 24640(V1)
364:                             TRIS_YPOS = 1;
9D00EDEC  3C03BF88   LUI V1, -16504
9D00EDF0  8C626040   LW V0, 24640(V1)
9D00EDF4  24040001   ADDIU A0, ZERO, 1
9D00EDF8  7C826304   INS V0, A0, 12, 1
9D00EDFC  AC626040   SW V0, 24640(V1)
365:                             LAT_XNEG = 0;
9D00EE00  3C03BF88   LUI V1, -16504
9D00EE04  8C626060   LW V0, 24672(V1)
9D00EE08  7C025AC4   INS V0, ZERO, 11, 1
9D00EE0C  AC626060   SW V0, 24672(V1)
366:                             TRIS_XNEG = 0;
9D00EE10  3C03BF88   LUI V1, -16504
9D00EE14  8C626040   LW V0, 24640(V1)
9D00EE18  7C025AC4   INS V0, ZERO, 11, 1
9D00EE1C  AC626040   SW V0, 24640(V1)
367:                             TRIS_YNEG = 1;
9D00EE20  3C03BF88   LUI V1, -16504
9D00EE24  8C626040   LW V0, 24640(V1)
9D00EE28  24040001   ADDIU A0, ZERO, 1
9D00EE2C  7C825284   INS V0, A0, 10, 1
9D00EE30  AC626040   SW V0, 24640(V1)
368:                 
369:                             AD1CON1bits.SAMP = 1;  // run conversion
9D00EE34  3C03BF81   LUI V1, -16511
9D00EE38  8C629000   LW V0, -28672(V1)
9D00EE3C  24040001   ADDIU A0, ZERO, 1
9D00EE40  7C820844   INS V0, A0, 1, 1
9D00EE44  AC629000   SW V0, -28672(V1)
370:                             state = CHECK_Y;
9D00EE48  24020008   ADDIU V0, ZERO, 8
9D00EE4C  AF8280C0   SW V0, -32576(GP)
371:                             break;
9D00EE50  0B403BF7   J 0x9D00EFDC
9D00EE54  00000000   NOP
372:                 
373:                         case CHECK_Y:
374:                             if(!AD1CON1bits.DONE)
9D00EE58  3C02BF81   LUI V0, -16511
9D00EE5C  8C429000   LW V0, -28672(V0)
9D00EE60  30420001   ANDI V0, V0, 1
9D00EE64  10400059   BEQ V0, ZERO, 0x9D00EFCC
9D00EE68  00000000   NOP
375:                                 break;
9D00EFCC  00000000   NOP
9D00EFD0  0B403BF7   J 0x9D00EFDC
9D00EFD4  00000000   NOP
376:                 
377:                             if( (WORD)PRESS_THRESHOULD > (WORD)ADC1BUF0 ){
9D00EE6C  3C02BF81   LUI V0, -16511
9D00EE70  8C429070   LW V0, -28560(V0)
9D00EE74  3042FFFF   ANDI V0, V0, -1
9D00EE78  2C420100   SLTIU V0, V0, 256
9D00EE7C  10400010   BEQ V0, ZERO, 0x9D00EEC0
9D00EE80  00000000   NOP
378:                                 LAT_XPOS  = 1;
9D00EE84  3C03BF88   LUI V1, -16504
9D00EE88  8C626060   LW V0, 24672(V1)
9D00EE8C  24040001   ADDIU A0, ZERO, 1
9D00EE90  7C826B44   INS V0, A0, 13, 1
9D00EE94  AC626060   SW V0, 24672(V1)
379:                                 TRIS_XPOS = 0;
9D00EE98  3C03BF88   LUI V1, -16504
9D00EE9C  8C626040   LW V0, 24640(V1)
9D00EEA0  7C026B44   INS V0, ZERO, 13, 1
9D00EEA4  AC626040   SW V0, 24640(V1)
380:                                 tempY = -1;
9D00EEA8  2402FFFF   ADDIU V0, ZERO, -1
9D00EEAC  A78280C6   SH V0, -32570(GP)
381:                                 state = RUN_Y;
9D00EEB0  24020006   ADDIU V0, ZERO, 6
9D00EEB4  AF8280C0   SW V0, -32576(GP)
9D00EEB8  0B403BB8   J 0x9D00EEE0
9D00EEBC  00000000   NOP
382:                             }else{
383:                                 adcX = -1; adcY = -1;
9D00EEC0  2402FFFF   ADDIU V0, ZERO, -1
9D00EEC4  A7828014   SH V0, -32748(GP)
9D00EEC8  2402FFFF   ADDIU V0, ZERO, -1
9D00EECC  A7828016   SH V0, -32746(GP)
384:                                 state = RUN_POT;
9D00EED0  2402000B   ADDIU V0, ZERO, 11
9D00EED4  AF8280C0   SW V0, -32576(GP)
385:                                 break;
9D00EED8  0B403BF7   J 0x9D00EFDC
9D00EEDC  00000000   NOP
386:                             }
387:                 
388:                         case RUN_Y:
389:                             AD1CON1bits.SAMP = 1;
9D00EEE0  3C03BF81   LUI V1, -16511
9D00EEE4  8C629000   LW V0, -28672(V1)
9D00EEE8  24040001   ADDIU A0, ZERO, 1
9D00EEEC  7C820844   INS V0, A0, 1, 1
9D00EEF0  AC629000   SW V0, -28672(V1)
390:                             state = GET_Y;
9D00EEF4  24020007   ADDIU V0, ZERO, 7
9D00EEF8  AF8280C0   SW V0, -32576(GP)
391:                             break;
9D00EEFC  0B403BF7   J 0x9D00EFDC
9D00EF00  00000000   NOP
392:                 
393:                         case GET_Y:
394:                             // Get Y value
395:                             if(!AD1CON1bits.DONE)
9D00EF04  3C02BF81   LUI V0, -16511
9D00EF08  8C429000   LW V0, -28672(V0)
9D00EF0C  30420001   ANDI V0, V0, 1
9D00EF10  10400031   BEQ V0, ZERO, 0x9D00EFD8
9D00EF14  00000000   NOP
396:                                 break;
9D00EFD8  00000000   NOP
397:                 
398:                             temp = ADC1BUF0;
9D00EF18  3C02BF81   LUI V0, -16511
9D00EF1C  8C429070   LW V0, -28560(V0)
9D00EF20  A7C20000   SH V0, 0(S8)
399:                             if(temp != tempY){
9D00EF24  878280C6   LH V0, -32570(GP)
9D00EF28  87C30000   LH V1, 0(S8)
9D00EF2C  10620007   BEQ V1, V0, 0x9D00EF4C
9D00EF30  00000000   NOP
400:                                 tempY = temp;
9D00EF34  97C20000   LHU V0, 0(S8)
9D00EF38  A78280C6   SH V0, -32570(GP)
401:                                 state = RUN_Y;
9D00EF3C  24020006   ADDIU V0, ZERO, 6
9D00EF40  AF8280C0   SW V0, -32576(GP)
402:                                 break;
9D00EF44  0B403BF7   J 0x9D00EFDC
9D00EF48  00000000   NOP
403:                             }
404:                             TRIS_XPOS = 1;
9D00EF4C  3C03BF88   LUI V1, -16504
9D00EF50  8C626040   LW V0, 24640(V1)
9D00EF54  24040001   ADDIU A0, ZERO, 1
9D00EF58  7C826B44   INS V0, A0, 13, 1
9D00EF5C  AC626040   SW V0, 24640(V1)
405:                             AD1CON1bits.SAMP = 1;
9D00EF60  3C03BF81   LUI V1, -16511
9D00EF64  8C629000   LW V0, -28672(V1)
9D00EF68  24040001   ADDIU A0, ZERO, 1
9D00EF6C  7C820844   INS V0, A0, 1, 1
9D00EF70  AC629000   SW V0, -28672(V1)
406:                             state = SET_VALUES;
9D00EF74  24020009   ADDIU V0, ZERO, 9
9D00EF78  AF8280C0   SW V0, -32576(GP)
407:                             break;
9D00EF7C  0B403BF7   J 0x9D00EFDC
9D00EF80  00000000   NOP
408:                 
409:                         default:
410:                             state = SET_X;
9D00EF84  AF8080C0   SW ZERO, -32576(GP)
9D00EF88  0B403BF7   J 0x9D00EFDC
9D00EF8C  00000000   NOP
411:                     }
412:                     // Clear flag
413:                 //#ifdef __PIC32MX__
414:                    // mT3ClearIntFlag();
415:                 //#else
416:                     //IFS0bits.T3IF = 0;
417:                 //#endif
418:                 
419:                 }
9D00EFDC  03C0E821   ADDU SP, S8, ZERO
9D00EFE0  8FBE000C   LW S8, 12(SP)
9D00EFE4  27BD0010   ADDIU SP, SP, 16
9D00EFE8  03E00008   JR RA
9D00EFEC  00000000   NOP
420:                 /*********************************************************************
421:                 * Function: void TouchInit(void)
422:                 *
423:                 * PreCondition: none
424:                 *
425:                 * Input: none
426:                 *
427:                 * Output: none
428:                 *
429:                 * Side Effects: none
430:                 *
431:                 * Overview: sets ADC 
432:                 *
433:                 * Note: none
434:                 *
435:                 ********************************************************************/
436:                 void TouchInit(void){
9D00EFF0  27BDFFF8   ADDIU SP, SP, -8
9D00EFF4  AFBE0004   SW S8, 4(SP)
9D00EFF8  03A0F021   ADDU S8, SP, ZERO
437:                 //#define TIME_BASE (GetPeripheralClock()*SAMPLE_PERIOD)/4000000
438:                 
439:                     // Initialize ADC
440:                     AD1CON1 = 0x080E0;  // Turn on, auto-convert
9D00EFFC  3C02BF81   LUI V0, -16511
9D00F000  340380E0   ORI V1, ZERO, -32544
9D00F004  AC439000   SW V1, -28672(V0)
441:                     AD1CON2 = 0;        // AVdd, AVss, int every conversion, MUXA only
9D00F008  3C02BF81   LUI V0, -16511
9D00F00C  AC409010   SW ZERO, -28656(V0)
442:                     AD1CON3 = 0x1F80;   // 31 Tad auto-sample, Tad = 5*Tcy
9D00F010  3C02BF81   LUI V0, -16511
9D00F014  24031F80   ADDIU V1, ZERO, 8064
9D00F018  AC439020   SW V1, -28640(V0)
443:                     AD1CHS = ADC_POT;
9D00F01C  3C02BF81   LUI V0, -16511
9D00F020  3C030005   LUI V1, 5
9D00F024  AC439040   SW V1, -28608(V0)
444:                     AD1PCFG = 0;        // All inputs are analog
9D00F028  3C02BF81   LUI V0, -16511
9D00F02C  AC409060   SW ZERO, -28576(V0)
445:                     AD1CSSL = 0;	// No scanned inputs
9D00F030  3C02BF81   LUI V0, -16511
9D00F034  AC409050   SW ZERO, -28592(V0)
446:                    //JK Remmed after changing from T3 interrupt to
447:                    //JK RunTouchScreen() in main
448:                    //JK OpenTimer3(T3_ON | T3_PS_1_8, TIME_BASE);
449:                    //JK ConfigIntTimer3(T3_INT_ON | T3_INT_PRIOR_4);
450:                 
451:                 }
9D00F038  03C0E821   ADDU SP, S8, ZERO
9D00F03C  8FBE0004   LW S8, 4(SP)
9D00F040  27BD0008   ADDIU SP, SP, 8
9D00F044  03E00008   JR RA
9D00F048  00000000   NOP
452:                 
453:                 /*********************************************************************
454:                 * Function: SHORT TouchGetX()
455:                 *
456:                 * PreCondition: none
457:                 *
458:                 * Input: none
459:                 *
460:                 * Output: x coordinate
461:                 *
462:                 * Side Effects: none
463:                 *
464:                 * Overview: returns x coordinate if touch screen is pressed
465:                 *           and -1 if not
466:                 *
467:                 * Note: none
468:                 *
469:                 ********************************************************************/
470:                 short tsResult;
471:                 SHORT TouchGetX(){
9D00F04C  27BDFFF8   ADDIU SP, SP, -8
9D00F050  AFBE0004   SW S8, 4(SP)
9D00F054  03A0F021   ADDU S8, SP, ZERO
472:                 
473:                 
474:                 	#ifdef SWAP_X_AND_Y
475:                 		tsResult = ADCGetY();
476:                 	#else
477:                 		tsResult = ADCGetX();
9D00F058  97828014   LHU V0, -32748(GP)
9D00F05C  7C021620   SEH V0, V0
9D00F060  A78281FC   SH V0, -32260(GP)
478:                 	#endif
479:                 
480:                 	if(tsResult>=0)
9D00F064  878281FC   LH V0, -32260(GP)
9D00F068  04400014   BLTZ V0, 0x9D00F0BC
9D00F06C  00000000   NOP
481:                 	{
482:                                 //GetMaxX() is defined in HX8347.h
483:                 		#ifdef SWAP_X_AND_Y
484:                 			tsResult = (GetMaxX()*(tsResult - _calYMin))/(_calYMax - _calYMin);
485:                 		#else
486:                 			tsResult = (GetMaxX()*(tsResult- _calXMin))/(_calXMax - _calXMin);
9D00F070  878281FC   LH V0, -32260(GP)
9D00F074  00401821   ADDU V1, V0, ZERO
9D00F078  9782800C   LHU V0, -32756(GP)
9D00F07C  3042FFFF   ANDI V0, V0, -1
9D00F080  00621823   SUBU V1, V1, V0
9D00F084  2402013F   ADDIU V0, ZERO, 319
9D00F088  70622002   MUL A0, V1, V0
9D00F08C  9782800E   LHU V0, -32754(GP)
9D00F090  3042FFFF   ANDI V0, V0, -1
9D00F094  00401821   ADDU V1, V0, ZERO
9D00F098  9782800C   LHU V0, -32756(GP)
9D00F09C  3042FFFF   ANDI V0, V0, -1
9D00F0A0  00621023   SUBU V0, V1, V0
9D00F0A4  0082001A   DIV A0, V0
9D00F0A8  004001F4   TEQ V0, ZERO
9D00F0AC  00001810   MFHI V1
9D00F0B0  00001012   MFLO V0
9D00F0B4  7C021620   SEH V0, V0
9D00F0B8  A78281FC   SH V0, -32260(GP)
487:                                         //tsResult -= LCD_X_Pixels; // found in HX8347.h = 320
488:                 		#endif
489:                 		
490:                 		#ifdef FLIP_X
491:                 			tsResult = GetMaxX()- tsResult;
492:                 		#endif
493:                 
494:                     }
495:                     return tsResult;
9D00F0BC  878281FC   LH V0, -32260(GP)
496:                 }
9D00F0C0  03C0E821   ADDU SP, S8, ZERO
9D00F0C4  8FBE0004   LW S8, 4(SP)
9D00F0C8  27BD0008   ADDIU SP, SP, 8
9D00F0CC  03E00008   JR RA
9D00F0D0  00000000   NOP
497:                 
498:                 /*********************************************************************
499:                 * Function: SHORT TouchGetY()
500:                 *
501:                 * PreCondition: none
502:                 *
503:                 * Input: none
504:                 *
505:                 * Output: y coordinate
506:                 *
507:                 * Side Effects: none
508:                 *
509:                 * Overview: returns y coordinate if touch screen is pressed
510:                 *           and -1 if not
511:                 *
512:                 * Note: none
513:                 *
514:                 ********************************************************************/
515:                 
516:                 SHORT TouchGetY()
517:                 {
9D00F0D4  27BDFFF8   ADDIU SP, SP, -8
9D00F0D8  AFBE0004   SW S8, 4(SP)
9D00F0DC  03A0F021   ADDU S8, SP, ZERO
518:                 
519:                 	#ifdef SWAP_X_AND_Y
520:                 	    tsResult = ADCGetX();
521:                 	#else
522:                 	    tsResult = ADCGetY();
9D00F0E0  97828016   LHU V0, -32746(GP)
9D00F0E4  7C021620   SEH V0, V0
9D00F0E8  A78281FC   SH V0, -32260(GP)
523:                 	#endif
524:                 	
525:                 	if(tsResult>=0)
9D00F0EC  878281FC   LH V0, -32260(GP)
9D00F0F0  04400014   BLTZ V0, 0x9D00F144
9D00F0F4  00000000   NOP
526:                 	{
527:                 	
528:                 		#ifdef SWAP_X_AND_Y
529:                 		        tsResult = (GetMaxY()*(tsResult- _calXMin))/(_calXMax - _calXMin);
530:                 		#else
531:                 		        tsResult = (GetMaxY()*(tsResult - _calYMin))/(_calYMax - _calYMin);
9D00F0F8  878281FC   LH V0, -32260(GP)
9D00F0FC  00401821   ADDU V1, V0, ZERO
9D00F100  97828010   LHU V0, -32752(GP)
9D00F104  3042FFFF   ANDI V0, V0, -1
9D00F108  00621823   SUBU V1, V1, V0
9D00F10C  240200EF   ADDIU V0, ZERO, 239
9D00F110  70622002   MUL A0, V1, V0
9D00F114  97828012   LHU V0, -32750(GP)
9D00F118  3042FFFF   ANDI V0, V0, -1
9D00F11C  00401821   ADDU V1, V0, ZERO
9D00F120  97828010   LHU V0, -32752(GP)
9D00F124  3042FFFF   ANDI V0, V0, -1
9D00F128  00621023   SUBU V0, V1, V0
9D00F12C  0082001A   DIV A0, V0
9D00F130  004001F4   TEQ V0, ZERO
9D00F134  00001810   MFHI V1
9D00F138  00001012   MFLO V0
9D00F13C  7C021620   SEH V0, V0
9D00F140  A78281FC   SH V0, -32260(GP)
532:                 		#endif
533:                 		
534:                 		#ifdef FLIP_Y
535:                 		        tsResult = GetMaxY()- tsResult;
536:                 		#endif
537:                 
538:                     }  
539:                     return tsResult;
9D00F144  878281FC   LH V0, -32260(GP)
540:                 }
9D00F148  03C0E821   ADDU SP, S8, ZERO
9D00F14C  8FBE0004   LW S8, 4(SP)
9D00F150  27BD0008   ADDIU SP, SP, 8
9D00F154  03E00008   JR RA
9D00F158  00000000   NOP
541:                 
542:                 /*********************************************************************
543:                 * Function: void TouchGetMsg(GOL_MSG* pMsg)
544:                 *
545:                 * PreCondition: none
546:                 *
547:                 * Input: pointer to the message structure to be populated
548:                 *
549:                 * Output: none
550:                 *
551:                 * Side Effects: none
552:                 *
553:                 * Overview: populates GOL message structure
554:                 *
555:                 * Note: none
556:                 *
557:                 *******************************************************************
558:                 
559:                 void TouchGetMsg(GOL_MSG* pMsg){
560:                 static SHORT prevX = -1;
561:                 static SHORT prevY = -1;
562:                 
563:                 SHORT x,y;
564:                 
565:                     x = TouchGetX();  y = TouchGetY();
566:                     pMsg->type    = TYPE_TOUCHSCREEN;
567:                     pMsg->uiEvent = EVENT_INVALID;
568:                 
569:                     if( x == -1 ){
570:                         y = -1;
571:                     }else{
572:                         if( y == -1 )
573:                             x = -1;
574:                     }
575:                 
576:                     if( (prevX == x) && (prevY == y) )
577:                         return;
578:                 
579:                     if( (prevX != -1) || (prevY != -1) ){
580:                 
581:                         if( (x != -1) && (y != -1) ){
582:                             // Move
583:                             pMsg->uiEvent = EVENT_MOVE;
584:                         }else{
585:                             // Released
586:                             pMsg->uiEvent = EVENT_RELEASE;
587:                             pMsg->param1 = prevX;
588:                             pMsg->param2 = prevY;
589:                             prevX = x;
590:                             prevY = y;
591:                             return;
592:                         }
593:                 
594:                     }else{
595:                 
596:                         if( (x != -1) && (y != -1) ){
597:                             // Pressed
598:                             pMsg->uiEvent = EVENT_PRESS;
599:                         }else{
600:                             // No message
601:                             pMsg->uiEvent = EVENT_INVALID;
602:                         }
603:                 
604:                     }
605:                 
606:                     pMsg->param1 = x;
607:                     pMsg->param2 = y;
608:                     prevX = x;
609:                     prevY = y;
610:                 
611:                 }
612:                 */
613:                 
614:                 
615:                 /*********************************************************************
616:                 * Function: StoreCalFactors(short XMin, short XMax,short YMin, short YMax)
617:                 *
618:                 * PreCondition: EEPROMInit() must be called before
619:                 *
620:                 * Input: none
621:                 *
622:                 * Output: void
623:                 *
624:                 * Side Effects: none
625:                 *
626:                 * Overview: Used by CalibrateTouch() in SYS_LIB/lcd_interface.h
627:                 *
628:                 * Note: none
629:                 *
630:                 ********************************************************************/
631:                 void StoreCalFactors(short XMin, short XMax,short YMin, short YMax)
632:                 {
9D00F15C  27BDFFE8   ADDIU SP, SP, -24
9D00F160  AFBF0014   SW RA, 20(SP)
9D00F164  AFBE0010   SW S8, 16(SP)
9D00F168  03A0F021   ADDU S8, SP, ZERO
9D00F16C  00804021   ADDU T0, A0, ZERO
9D00F170  00A02021   ADDU A0, A1, ZERO
9D00F174  00C01821   ADDU V1, A2, ZERO
9D00F178  00E01021   ADDU V0, A3, ZERO
9D00F17C  A7C80018   SH T0, 24(S8)
9D00F180  A7C4001C   SH A0, 28(S8)
9D00F184  A7C30020   SH V1, 32(S8)
9D00F188  A7C20024   SH V0, 36(S8)
633:                     EEPROMWriteWord(XMin, EEPROM_XMIN);
9D00F18C  97C20018   LHU V0, 24(S8)
9D00F190  00402021   ADDU A0, V0, ZERO
9D00F194  24057FFC   ADDIU A1, ZERO, 32764
9D00F198  0F403D97   JAL EEPROMWriteWord
9D00F19C  00000000   NOP
634:                     EEPROMWriteWord(XMax, EEPROM_XMAX);
9D00F1A0  97C2001C   LHU V0, 28(S8)
9D00F1A4  00402021   ADDU A0, V0, ZERO
9D00F1A8  24057FFA   ADDIU A1, ZERO, 32762
9D00F1AC  0F403D97   JAL EEPROMWriteWord
9D00F1B0  00000000   NOP
635:                     EEPROMWriteWord(YMin, EEPROM_YMIN);
9D00F1B4  97C20020   LHU V0, 32(S8)
9D00F1B8  00402021   ADDU A0, V0, ZERO
9D00F1BC  24057FF8   ADDIU A1, ZERO, 32760
9D00F1C0  0F403D97   JAL EEPROMWriteWord
9D00F1C4  00000000   NOP
636:                     EEPROMWriteWord(YMax, EEPROM_YMAX);
9D00F1C8  97C20024   LHU V0, 36(S8)
9D00F1CC  00402021   ADDU A0, V0, ZERO
9D00F1D0  24057FF6   ADDIU A1, ZERO, 32758
9D00F1D4  0F403D97   JAL EEPROMWriteWord
9D00F1D8  00000000   NOP
637:                 }
9D00F1DC  03C0E821   ADDU SP, S8, ZERO
9D00F1E0  8FBF0014   LW RA, 20(SP)
9D00F1E4  8FBE0010   LW S8, 16(SP)
9D00F1E8  27BD0018   ADDIU SP, SP, 24
9D00F1EC  03E00008   JR RA
9D00F1F0  00000000   NOP
638:                 /*********************************************************************
639:                 * Function: void TouchStoreCalibration(void)
640:                 *
641:                 * PreCondition: EEPROMInit() must be called before
642:                 *
643:                 * Input: none
644:                 *
645:                 * Output: none
646:                 *
647:                 * Side Effects: none
648:                 *
649:                 * Overview: stores calibration parameters into EEPROM
650:                 *
651:                 * Note: none
652:                 *
653:                 ********************************************************************/
654:                 void TouchStoreCalibration(void)
655:                 {
9D00F1F4  27BDFFE8   ADDIU SP, SP, -24
9D00F1F8  AFBF0014   SW RA, 20(SP)
9D00F1FC  AFBE0010   SW S8, 16(SP)
9D00F200  03A0F021   ADDU S8, SP, ZERO
656:                     EEPROMWriteWord(_calXMin, EEPROM_XMIN);
9D00F204  9782800C   LHU V0, -32756(GP)
9D00F208  3042FFFF   ANDI V0, V0, -1
9D00F20C  00402021   ADDU A0, V0, ZERO
9D00F210  24057FFC   ADDIU A1, ZERO, 32764
9D00F214  0F403D97   JAL EEPROMWriteWord
9D00F218  00000000   NOP
657:                     EEPROMWriteWord(_calXMax, EEPROM_XMAX);
9D00F21C  9782800E   LHU V0, -32754(GP)
9D00F220  3042FFFF   ANDI V0, V0, -1
9D00F224  00402021   ADDU A0, V0, ZERO
9D00F228  24057FFA   ADDIU A1, ZERO, 32762
9D00F22C  0F403D97   JAL EEPROMWriteWord
9D00F230  00000000   NOP
658:                     EEPROMWriteWord(_calYMin, EEPROM_YMIN);
9D00F234  97828010   LHU V0, -32752(GP)
9D00F238  3042FFFF   ANDI V0, V0, -1
9D00F23C  00402021   ADDU A0, V0, ZERO
9D00F240  24057FF8   ADDIU A1, ZERO, 32760
9D00F244  0F403D97   JAL EEPROMWriteWord
9D00F248  00000000   NOP
659:                     EEPROMWriteWord(_calYMax, EEPROM_YMAX);
9D00F24C  97828012   LHU V0, -32750(GP)
9D00F250  3042FFFF   ANDI V0, V0, -1
9D00F254  00402021   ADDU A0, V0, ZERO
9D00F258  24057FF6   ADDIU A1, ZERO, 32758
9D00F25C  0F403D97   JAL EEPROMWriteWord
9D00F260  00000000   NOP
660:                 }
9D00F264  03C0E821   ADDU SP, S8, ZERO
9D00F268  8FBF0014   LW RA, 20(SP)
9D00F26C  8FBE0010   LW S8, 16(SP)
9D00F270  27BD0018   ADDIU SP, SP, 24
9D00F274  03E00008   JR RA
9D00F278  00000000   NOP
661:                 
662:                 /*********************************************************************
663:                 * Function: void TouchLoadCalibration(void)
664:                 *
665:                 * PreCondition: EEPROMInit() must be called before
666:                 *
667:                 * Input: none
668:                 *
669:                 * Output: none
670:                 *
671:                 * Side Effects: none
672:                 *
673:                 * Overview: loads calibration parameters from EEPROM
674:                 *
675:                 * Note: none
676:                 *
677:                 ********************************************************************/
678:                 void TouchLoadCalibration(void){
9D00F27C  27BDFFE8   ADDIU SP, SP, -24
9D00F280  AFBF0014   SW RA, 20(SP)
9D00F284  AFBE0010   SW S8, 16(SP)
9D00F288  03A0F021   ADDU S8, SP, ZERO
679:                     _calXMin = EEPROMReadWord(EEPROM_XMIN);
9D00F28C  24047FFC   ADDIU A0, ZERO, 32764
9D00F290  0F403DBF   JAL EEPROMReadWord
9D00F294  00000000   NOP
9D00F298  A782800C   SH V0, -32756(GP)
680:                     _calXMax = EEPROMReadWord(EEPROM_XMAX);
9D00F29C  24047FFA   ADDIU A0, ZERO, 32762
9D00F2A0  0F403DBF   JAL EEPROMReadWord
9D00F2A4  00000000   NOP
9D00F2A8  A782800E   SH V0, -32754(GP)
681:                     _calYMin = EEPROMReadWord(EEPROM_YMIN);
9D00F2AC  24047FF8   ADDIU A0, ZERO, 32760
9D00F2B0  0F403DBF   JAL EEPROMReadWord
9D00F2B4  00000000   NOP
9D00F2B8  A7828010   SH V0, -32752(GP)
682:                     _calYMax = EEPROMReadWord(EEPROM_YMAX);
9D00F2BC  24047FF6   ADDIU A0, ZERO, 32758
9D00F2C0  0F403DBF   JAL EEPROMReadWord
9D00F2C4  00000000   NOP
9D00F2C8  A7828012   SH V0, -32750(GP)
683:                 }
9D00F2CC  03C0E821   ADDU SP, S8, ZERO
9D00F2D0  8FBF0014   LW RA, 20(SP)
9D00F2D4  8FBE0010   LW S8, 16(SP)
9D00F2D8  27BD0018   ADDIU SP, SP, 24
9D00F2DC  03E00008   JR RA
9D00F2E0  00000000   NOP
684:                 
685:                 /*********************************************************************
686:                 * Function:  void TouchCalibration()
687:                 *
688:                 * PreCondition: InitGraph() must be called before
689:                 *
690:                 * Input: none
691:                 *
692:                 * Output: none
693:                 *
694:                 * Side Effects: none
695:                 *
696:                 * Overview: calibrates touch screen
697:                 *
698:                 * Note: none
699:                 *
700:                 ********************************************************************/
701:                 void TouchCalibration(){/*
9D00F2E4  27BDFFF8   ADDIU SP, SP, -8
9D00F2E8  AFBE0004   SW S8, 4(SP)
9D00F2EC  03A0F021   ADDU S8, SP, ZERO
702:                 static const XCHAR scr1StrLn1[] = {'I','M','P','O','R','T','A','N','T','.',0};
703:                 static const XCHAR scr1StrLn2[] = "Now touch screen calibration";
704:                 //static const XCHAR scr1StrLn2[] = {'N','o','w',' ','t','o','u','c','h',' ','s','c','r','e','e','n',' ','c','a','l','i','b','r','a','t','i','o','n',0};
705:                 static const XCHAR scr1StrLn3[] = {'w','i','l','l',' ','b','e',' ','p','e','r','f','o','m','e','d','.','T','o','u','c','h',' ','p','o','i','n','t','s',0};
706:                 static const XCHAR scr1StrLn4[] = {'E','X','A','C','T','L','Y',' ','a','t',' ','t','h','e',' ','p','o','s','i','t','i','o','n','s',0};
707:                 static const XCHAR scr1StrLn5[] = {'s','h','o','w','n',' ','b','y',' ','a','r','r','o','w','s','.',0};
708:                 static const XCHAR scr1StrLn6[] = {'T','o','u','c','h',' ','s','c','r','e','e','n',' ','t','o',' ','c','o','n','t','i','n','u','e','.',0};
709:                 
710:                 static const XCHAR scr2StrLn1[] = {'H','o','l','d',' ','S','3',' ','b','u','t','t','o','n',' ','a','n','d',0};
711:                 static const XCHAR scr2StrLn2[] = {'p','r','e','s','s',' ','M','C','L','R',' ','r','e','s','e','t','(','S','1',')',0};
712:                 static const XCHAR scr2StrLn3[] = {'t','o',' ','R','E','P','E','A','T',' ','t','h','e',' ','c','a','l','i','b','r','a','t','i','o','n',0};
713:                 static const XCHAR scr2StrLn4[] = {'p','r','o','c','e','d','u','r','e','.',0};
714:                 
715:                 
716:                 SHORT counter;
717:                 SHORT x,y;
718:                 WORD  ax[3],ay[3];
719:                 
720:                 SHORT textHeight;
721:                 
722:                     SetFont((void*)&GOLFontDefault);
723:                     textHeight = GetTextHeight((void*)&GOLFontDefault);
724:                 
725:                     SetColor(WHITE);
726:                     ClearDevice();
727:                 
728:                     SetColor(BRIGHTRED);
729:                     OutTextXY(0,0*textHeight, (XCHAR*)scr1StrLn1);
730:                     SetColor(BLACK);
731:                     OutTextXY(0,1*textHeight, (XCHAR*)scr1StrLn2);
732:                     OutTextXY(0,2*textHeight, (XCHAR*)scr1StrLn3);
733:                     OutTextXY(0,3*textHeight, (XCHAR*)scr1StrLn4);
734:                     OutTextXY(0,4*textHeight, (XCHAR*)scr1StrLn5);
735:                     SetColor(BRIGHTRED);
736:                     OutTextXY(0,6*textHeight, (XCHAR*)scr1StrLn6);
737:                 
738:                     // Wait for touch
739:                     do{
740:                         x=ADCGetX(); y=ADCGetY();
741:                     }while((y==-1)||(x==-1));
742:                 
743:                     Beep();
744:                 
745:                     DelayMs(500);
746:                 
747:                     SetColor(WHITE);
748:                     ClearDevice();
749:                 
750:                     SetColor(BRIGHTRED);
751:                 
752:                 #ifdef SWAP_X_AND_Y
753:                 
754:                     Line(GetMaxX()-5,5,GetMaxX()-5,15);
755:                     Line(GetMaxX()-4,5,GetMaxX()-4,15);
756:                     Line(GetMaxX()-6,5,GetMaxX()-6,15);
757:                 
758:                     Line(GetMaxX()-5,5,GetMaxX()-15,5);
759:                     Line(GetMaxX()-5,4,GetMaxX()-15,4);
760:                     Line(GetMaxX()-5,6,GetMaxX()-15,6);
761:                 
762:                     Line(GetMaxX()-5,6,GetMaxX()-15,16);
763:                     Line(GetMaxX()-5,4,GetMaxX()-15,14);
764:                     Line(GetMaxX()-5,5,GetMaxX()-15,15);
765:                 
766:                 #else
767:                 
768:                     Line(5,5,5,15);
769:                     Line(4,5,4,15);
770:                     Line(6,5,6,15);
771:                 
772:                     Line(5,5,15,5);
773:                     Line(5,4,15,4);
774:                     Line(5,6,15,6);
775:                 
776:                     Line(5,6,15,16);
777:                     Line(5,4,15,14);
778:                     Line(5,5,15,15);
779:                 
780:                 #endif
781:                 
782:                     TouchGetCalPoints(ax, ay);
783:                 
784:                 #if (GRAPHICS_PICTAIL_VERSION == 1)
785:                     // Get max X and min Y
786:                     _calXMax = 0;
787:                     _calYMin = 0xFFFF;
788:                     for(counter=0; counter<3; counter++){
789:                         if(_calXMax < ax[counter])
790:                             _calXMax = ax[counter];
791:                 
792:                         if(_calYMin > ay[counter])
793:                             _calYMin = ay[counter];
794:                     }
795:                 #elif (GRAPHICS_PICTAIL_VERSION == 2)
796:                     // Get min X and max Y
797:                     _calYMax = 0;
798:                     _calXMin = 0xFFFF;
799:                     for(counter=0; counter<3; counter++){
800:                         if(_calYMax < ay[counter])
801:                             _calYMax = ay[counter];
802:                 
803:                         if(_calXMin > ax[counter])
804:                             _calXMin = ax[counter];
805:                     }
806:                 #endif
807:                 
808:                     SetColor(WHITE);
809:                     ClearDevice();
810:                 
811:                     SetColor(BRIGHTRED);
812:                 
813:                 #ifdef SWAP_X_AND_Y
814:                 
815:                     Line(5,5,5,15);
816:                     Line(4,5,4,15);
817:                     Line(6,5,6,15);
818:                 
819:                     Line(5,5,15,5);
820:                     Line(5,4,15,4);
821:                     Line(5,6,15,6);
822:                 
823:                     Line(5,6,15,16);
824:                     Line(5,4,15,14);
825:                     Line(5,5,15,15);
826:                 
827:                 #else
828:                 
829:                     Line(5,GetMaxY()-5,5,GetMaxY()-15);
830:                     Line(4,GetMaxY()-5,4,GetMaxY()-15);
831:                     Line(6,GetMaxY()-5,6,GetMaxY()-15);
832:                 
833:                     Line(5,GetMaxY()-5,15,GetMaxY()-5);
834:                     Line(5,GetMaxY()-4,15,GetMaxY()-4);
835:                     Line(5,GetMaxY()-6,15,GetMaxY()-6);
836:                 
837:                     Line(5,GetMaxY()-6,15,GetMaxY()-16);
838:                     Line(5,GetMaxY()-4,15,GetMaxY()-14);
839:                     Line(5,GetMaxY()-5,15,GetMaxY()-15);
840:                 
841:                 #endif
842:                 
843:                     TouchGetCalPoints(ax, ay);
844:                 
845:                 #if (GRAPHICS_PICTAIL_VERSION == 1)
846:                     // Get max Y
847:                     _calYMax = 0;
848:                     for(counter=0; counter<3; counter++){
849:                         if(_calYMax < ay[counter])
850:                             _calYMax = ay[counter];
851:                     }
852:                 #elif (GRAPHICS_PICTAIL_VERSION == 2)
853:                     // Get min Y
854:                     _calYMin = 0xffff;
855:                     for(counter=0; counter<3; counter++){
856:                         if(_calYMin > ay[counter])
857:                             _calYMin = ay[counter];
858:                     }
859:                 #endif
860:                 
861:                     SetColor(WHITE);
862:                     ClearDevice();
863:                 
864:                     SetColor(BRIGHTRED);    
865:                 
866:                 
867:                 #ifdef SWAP_X_AND_Y
868:                 
869:                     Line(GetMaxX()/2-5,GetMaxY()-5,GetMaxX()/2-5,GetMaxY()-15);
870:                     Line(GetMaxX()/2-4,GetMaxY()-5,GetMaxX()/2-4,GetMaxY()-15);
871:                     Line(GetMaxX()/2-6,GetMaxY()-5,GetMaxX()/2-6,GetMaxY()-15);
872:                 
873:                     Line(GetMaxX()/2-5,GetMaxY()-5,GetMaxX()/2-15,GetMaxY()-5);
874:                     Line(GetMaxX()/2-5,GetMaxY()-4,GetMaxX()/2-15,GetMaxY()-4);
875:                     Line(GetMaxX()/2-5,GetMaxY()-6,GetMaxX()/2-15,GetMaxY()-6);
876:                 
877:                     Line(GetMaxX()/2-5,GetMaxY()-6,GetMaxX()/2-15,GetMaxY()-16);
878:                     Line(GetMaxX()/2-5,GetMaxY()-4,GetMaxX()/2-15,GetMaxY()-14);
879:                     Line(GetMaxX()/2-5,GetMaxY()-5,GetMaxX()/2-15,GetMaxY()-15);
880:                 
881:                 #else
882:                 
883:                     Line(GetMaxX()-5,GetMaxY()/2-5,GetMaxX()-5,GetMaxY()/2-15);
884:                     Line(GetMaxX()-4,GetMaxY()/2-5,GetMaxX()-4,GetMaxY()/2-15);
885:                     Line(GetMaxX()-6,GetMaxY()/2-5,GetMaxX()-6,GetMaxY()/2-15);
886:                 
887:                     Line(GetMaxX()-5,GetMaxY()/2-5,GetMaxX()-15,GetMaxY()/2-5);
888:                     Line(GetMaxX()-5,GetMaxY()/2-4,GetMaxX()-15,GetMaxY()/2-4);
889:                     Line(GetMaxX()-5,GetMaxY()/2-6,GetMaxX()-15,GetMaxY()/2-6);
890:                 
891:                     Line(GetMaxX()-5,GetMaxY()/2-6,GetMaxX()-15,GetMaxY()/2-16);
892:                     Line(GetMaxX()-5,GetMaxY()/2-4,GetMaxX()-15,GetMaxY()/2-14);
893:                     Line(GetMaxX()-5,GetMaxY()/2-5,GetMaxX()-15,GetMaxY()/2-15);
894:                 
895:                 #endif
896:                 
897:                     TouchGetCalPoints(ax, ay);
898:                 
899:                 #if (GRAPHICS_PICTAIL_VERSION == 1)
900:                     // Get min X
901:                     _calXMin = 0xFFFF;
902:                     for(counter=0; counter<3; counter++){
903:                         if(_calXMin > ax[counter])
904:                             _calXMin = ax[counter];
905:                     }
906:                 #elif (GRAPHICS_PICTAIL_VERSION == 2)
907:                     // Get max X
908:                     _calXMax = 0;
909:                     for(counter=0; counter<3; counter++){
910:                         if(_calXMax < ax[counter])
911:                             _calXMax = ax[counter];
912:                     }
913:                 #endif
914:                 
915:                 
916:                     SetColor(WHITE);
917:                     ClearDevice();
918:                 
919:                     SetColor(BLACK);
920:                     OutTextXY(10,1*textHeight,(XCHAR*)scr2StrLn1);
921:                     OutTextXY(10,2*textHeight,(XCHAR*)scr2StrLn2);
922:                     OutTextXY(10,3*textHeight,(XCHAR*)scr2StrLn3);
923:                     OutTextXY(10,4*textHeight,(XCHAR*)scr2StrLn4);
924:                     SetColor(BRIGHTRED);
925:                     OutTextXY(10,6*textHeight,(XCHAR*)scr1StrLn6);
926:                 
927:                     // Wait for touch
928:                     do{
929:                         x=ADCGetX(); y=ADCGetY();
930:                     }while((y==-1)||(x==-1));
931:                 
932:                     Beep();
933:                 
934:                     DelayMs(500);
935:                 
936:                     SetColor(BLACK);
937:                     ClearDevice();
938:                 
939:                 }
940:                 */
941:                 /*********************************************************************
942:                 * Function: void TouchGetCalPoints(WORD* ax, WORD* ay)
943:                 *
944:                 * PreCondition: InitGraph() must be called before
945:                 *
946:                 * Input: ax - pointer to array receiving 3 X touch positions
947:                 *        ay - pointer to array receiving 3 Y touch positions
948:                 *
949:                 * Output: none
950:                 *
951:                 * Side Effects: none
952:                 *
953:                 * Overview: gets values for 3 touches
954:                 *
955:                 * Note: none
956:                 *
957:                 ********************************************************************/
958:                 /*TODO: JK remmed out because of lack of refernce to GOLFFontDefault
959:                 void TouchGetCalPoints(WORD* ax, WORD* ay)
960:                 {
961:                 	static const XCHAR calStr[] = {'C','A','L','I','B','R','A','T','I','O','N',0};
962:                 	XCHAR calTouchLeft[] = {'3',' ','t','o','u','c','h','e','s',' ','l','e','f','t',0};
963:                 	SHORT counter;
964:                 	SHORT x,y;
965:                 
966:                     SetFont((void*)&GOLFontDefault);
967:                 
968:                     SetColor(BRIGHTRED);
969:                 
970:                     OutTextXY((GetMaxX()-GetTextWidth((XCHAR*)calStr,(void*)&GOLFontDefault))>>1,
971:                               (GetMaxY()-GetTextHeight((void*)&GOLFontDefault))>>1,
972:                               (XCHAR*)calStr);
973:                 
974:                     for(counter=0; counter<3; counter++){
975:                 
976:                         SetColor(BRIGHTRED);
977:                 
978:                         calTouchLeft[0] = '3' - counter;
979:                 
980:                         OutTextXY((GetMaxX()-GetTextWidth(calTouchLeft,(void*)&GOLFontDefault))>>1,
981:                                   (GetMaxY()+GetTextHeight((void*)&GOLFontDefault))>>1,
982:                                    calTouchLeft);
983:                 
984:                         // Wait for press
985:                         do{
986:                             x=ADCGetX(); y=ADCGetY();
987:                         }while((y==-1)||(x==-1));
988:                 
989:                         //TODO: JK Remmed outBeep();
990:                 
991:                         *(ax+counter) = x; *(ay+counter) = y;
992:                      
993:                         // Wait for release
994:                         do{
995:                             x=ADCGetX(); y=ADCGetY();
996:                         }while((y!=-1)&&(x!=-1));
997:                 
998:                         SetColor(WHITE);
999:                 //TODO: JK remmed out because GOLFont not defined
1000:                        OutTextXY((GetMaxX()-GetTextWidth(calTouchLeft,(void*)&GOLFontDefault))>>1,
1001:                                  (GetMaxY()+GetTextHeight((void*)&GOLFontDefault))>>1,
1002:                                   calTouchLeft);
1003:                
1004:                        DelayMs(500);
1005:                    }*/
1006:                }
9D00F2F0  03C0E821   ADDU SP, S8, ZERO
9D00F2F4  8FBE0004   LW S8, 4(SP)
9D00F2F8  27BD0008   ADDIU SP, SP, 8
9D00F2FC  03E00008   JR RA
9D00F300  00000000   NOP
1007:                
---  C:/MC_XProjects/LIBS/MODBUS_LIB/MODBUS_SOURCE/modbus.c  --------------------------------------------
1:                   #include "../modbus.h"
2:                   
3:                   //#include "uart.h"
4:                   //#include "adc.h"
5:                   
6:                   
7:                   //CRC Tables
8:                    const unsigned char hiCRCbyte[] = {
9:                      0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
10:                     0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0,
11:                     0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01,
12:                     0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41,
13:                     0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81,
14:                     0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0,
15:                     0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01,
16:                     0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40,
17:                     0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
18:                     0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0,
19:                     0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01,
20:                     0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41,
21:                     0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
22:                     0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0,
23:                     0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01,
24:                     0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41,
25:                     0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
26:                     0x40
27:                  } ;
28:                  
29:                  const unsigned char lowCRCbyte[] = {
30:                     0x00, 0xc0, 0xc1, 0x01, 0xc3, 0x03, 0x02, 0xc2, 0xc6, 0x06, 0x07, 0xc7, 0x05, 0xc5, 0xc4,
31:                     0x04, 0xcc, 0x0c, 0x0d, 0xcd, 0x0f, 0xcf, 0xce, 0x0e, 0x0a, 0xca, 0xcb, 0x0b, 0xc9, 0x09,
32:                     0x08, 0xc8, 0xd8, 0x18, 0x19, 0xd9, 0x1b, 0xdb, 0xda, 0x1a, 0x1e, 0xde, 0xdf, 0x1f, 0xdd,
33:                     0x1d, 0x1c, 0xdc, 0x14, 0xd4, 0xd5, 0x15, 0xd7, 0x17, 0x16, 0xd6, 0xd2, 0x12, 0x13, 0xd3,
34:                     0x11, 0xd1, 0xd0, 0x10, 0xf0, 0x30, 0x31, 0xf1, 0x33, 0xf3, 0xf2, 0x32, 0x36, 0xf6, 0xf7,
35:                     0x37, 0xf5, 0x35, 0x34, 0xf4, 0x3c, 0xfc, 0xfd, 0x3d, 0xff, 0x3f, 0x3e, 0xfe, 0xfa, 0x3a,
36:                     0x3b, 0xfb, 0x39, 0xf9, 0xf8, 0x38, 0x28, 0xe8, 0xe9, 0x29, 0xeb, 0x2b, 0x2a, 0xea, 0xee,
37:                     0x2e, 0x2f, 0xef, 0x2d, 0xed, 0xec, 0x2c, 0xe4, 0x24, 0x25, 0xe5, 0x27, 0xe7, 0xe6, 0x26,
38:                     0x22, 0xe2, 0xe3, 0x23, 0xe1, 0x21, 0x20, 0xe0, 0xa0, 0x60, 0x61, 0xa1, 0x63, 0xa3, 0xa2,
39:                     0x62, 0x66, 0xa6, 0xa7, 0x67, 0xa5, 0x65, 0x64, 0xa4, 0x6c, 0xac, 0xad, 0x6d, 0xaf, 0x6f,
40:                     0x6e, 0xae, 0xaa, 0x6a, 0x6b, 0xab, 0x69, 0xa9, 0xa8, 0x68, 0x78, 0xb8, 0xb9, 0x79, 0xbb,
41:                     0x7b, 0x7a, 0xba, 0xbe, 0x7e, 0x7f, 0xbf, 0x7d, 0xbd, 0xbc, 0x7c, 0xb4, 0x74, 0x75, 0xb5,
42:                     0x77, 0xb7, 0xb6, 0x76, 0x72, 0xb2, 0xb3, 0x73, 0xb1, 0x71, 0x70, 0xb0, 0x50, 0x90, 0x91,
43:                     0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9c, 0x5c,
44:                     0x5d, 0x9d, 0x5f, 0x9f, 0x9e, 0x5e, 0x5a, 0x9a, 0x9b, 0x5b, 0x99, 0x59, 0x58, 0x98, 0x88,
45:                     0x48, 0x49, 0x89, 0x4b, 0x8b, 0x8a, 0x4a, 0x4e, 0x8e, 0x8f, 0x4f, 0x8d, 0x4d, 0x4c, 0x8c,
46:                     0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
47:                     0x40
48:                  } ;
49:                  
50:                  /*============================================================================*/
51:                  
52:                  uChar  mbIndex, fIndex,txLength;//uartIndex;
53:                  uShort mbCmdIndex= 0;	//used to parse serial command from master
54:                  uShort mbCommand = 0 ; //Command from serial port
55:                  uShort mbParam1 	= 0; //Param1 from serial port
56:                  uShort mbParam2 	= 0;	// Param2 from serial port
57:                  uShort sParam3 	= 0;	// Param2 from serial port
58:                  uShort sParam4 	= 0;	// Param2 from serial port
59:                  uChar  cmdLength = 0;	// Used by CRC to check and append messages
60:                  uShort MBMem[10];
61:                  uShort MB_Buffer[MB_MEM_SZ];
62:                  
63:                  
64:                  uShort rxBuffIndex = 0 ;
65:                  uChar  lowCRC, highCRC,indexCRC;
66:                  
67:                  //write persistant variable from NV memory at MB Location
68:                  char WriteSysVarFromMBAddress(uShort MBRegNum)
69:                  {
9D009868  27BDFFF0   ADDIU SP, SP, -16
9D00986C  AFBE000C   SW S8, 12(SP)
9D009870  03A0F021   ADDU S8, SP, ZERO
9D009874  00801021   ADDU V0, A0, ZERO
9D009878  A7C20010   SH V0, 16(S8)
70:                      uShort CurrentRegAddress = 0;
9D00987C  A7C00000   SH ZERO, 0(S8)
71:                      uShort RegisterIndex = 0;
9D009880  A7C00002   SH ZERO, 2(S8)
72:                      while(CurrentRegAddress <= MBRegNum)
9D009884  97C30000   LHU V1, 0(S8)
9D009888  97C20010   LHU V0, 16(S8)
9D00988C  0043102B   SLTU V0, V0, V1
9D009890  1040FFFC   BEQ V0, ZERO, 0x9D009884
9D009894  00000000   NOP
73:                      {
74:                          /*
75:                          if(MBRegNum == PersistantMBVars[RegisterIndex].regAddress);
76:                          {
77:                              
78:                              //Go get info from flash
79:                              return 0;
80:                          }
81:                          */
82:                      }
83:                  
84:                  }
9D009898  03C0E821   ADDU SP, S8, ZERO
9D00989C  8FBE000C   LW S8, 12(SP)
9D0098A0  27BD0010   ADDIU SP, SP, 16
9D0098A4  03E00008   JR RA
9D0098A8  00000000   NOP
85:                  //
86:                  char ChangeSysVarAtMBAddress(uShort MBRegNum)
87:                  {
9D0098AC  27BDFFF8   ADDIU SP, SP, -8
9D0098B0  AFBE0004   SW S8, 4(SP)
9D0098B4  03A0F021   ADDU S8, SP, ZERO
9D0098B8  00801021   ADDU V0, A0, ZERO
9D0098BC  A7C20008   SH V0, 8(S8)
88:                  
89:                  }
9D0098C0  03C0E821   ADDU SP, S8, ZERO
9D0098C4  8FBE0004   LW S8, 4(SP)
9D0098C8  27BD0008   ADDIU SP, SP, 8
9D0098CC  03E00008   JR RA
9D0098D0  00000000   NOP
90:                  /*
91:                  char LoadAllSysVarsFromMBMemory(ModbusSysReg *MBAddressArray)
92:                  {
93:                  
94:                  }*/
95:                  /*
96:                  Modbus Register Addresses 0X0001 - 0X01FF: (511 Registers, 1024 bytes) MCU Memory - Non Persistent
97:                  Modbus Register Addresses 0X0200 - 0X7D32: Ramtron(32K chip) Persistent
98:                  Modbus Register Addresses 0X7D33 - 0X200000: Atmel 32K Flash memory for files
99:                  */
100:                 void LoadTestData()
101:                 {
9D0098D4  27BDFFF8   ADDIU SP, SP, -8
9D0098D8  AFBE0004   SW S8, 4(SP)
9D0098DC  03A0F021   ADDU S8, SP, ZERO
102:                     
103:                 	MBMem[0] = 1000;//jk dummy data		
9D0098E0  3C02A000   LUI V0, -24576
9D0098E4  240303E8   ADDIU V1, ZERO, 1000
9D0098E8  A4430390   SH V1, 912(V0)
104:                 	MBMem[1] = 11;//jk dummy data	
9D0098EC  3C02A000   LUI V0, -24576
9D0098F0  24420390   ADDIU V0, V0, 912
9D0098F4  2403000B   ADDIU V1, ZERO, 11
9D0098F8  A4430002   SH V1, 2(V0)
105:                 	MBMem[2] = 222;//jk dummy data	
9D0098FC  3C02A000   LUI V0, -24576
9D009900  24420390   ADDIU V0, V0, 912
9D009904  240300DE   ADDIU V1, ZERO, 222
9D009908  A4430004   SH V1, 4(V0)
106:                 	MBMem[3] = 3333;//jk dummy data
9D00990C  3C02A000   LUI V0, -24576
9D009910  24420390   ADDIU V0, V0, 912
9D009914  24030D05   ADDIU V1, ZERO, 3333
9D009918  A4430006   SH V1, 6(V0)
107:                 	MBMem[4] = 41444;//jk dummy data
9D00991C  3C02A000   LUI V0, -24576
9D009920  24420390   ADDIU V0, V0, 912
9D009924  2403A1E4   ADDIU V1, ZERO, -24092
9D009928  A4430008   SH V1, 8(V0)
108:                 	MBMem[5] = 5555;
9D00992C  3C02A000   LUI V0, -24576
9D009930  24420390   ADDIU V0, V0, 912
9D009934  240315B3   ADDIU V1, ZERO, 5555
9D009938  A443000A   SH V1, 10(V0)
109:                 	MBMem[6] = 666;				
9D00993C  3C02A000   LUI V0, -24576
9D009940  24420390   ADDIU V0, V0, 912
9D009944  2403029A   ADDIU V1, ZERO, 666
9D009948  A443000C   SH V1, 12(V0)
110:                 	MBMem[7] = 777;			
9D00994C  3C02A000   LUI V0, -24576
9D009950  24420390   ADDIU V0, V0, 912
9D009954  24030309   ADDIU V1, ZERO, 777
9D009958  A443000E   SH V1, 14(V0)
111:                 	MBMem[8] = 888;
9D00995C  3C02A000   LUI V0, -24576
9D009960  24420390   ADDIU V0, V0, 912
9D009964  24030378   ADDIU V1, ZERO, 888
9D009968  A4430010   SH V1, 16(V0)
112:                 	MBMem[9] = 999;				
9D00996C  3C02A000   LUI V0, -24576
9D009970  24420390   ADDIU V0, V0, 912
9D009974  240303E7   ADDIU V1, ZERO, 999
9D009978  A4430012   SH V1, 18(V0)
113:                 	MBMem[10] = 1010;	
9D00997C  3C02A000   LUI V0, -24576
9D009980  24420390   ADDIU V0, V0, 912
9D009984  240303F2   ADDIU V1, ZERO, 1010
9D009988  A4430014   SH V1, 20(V0)
114:                 
115:                 }
9D00998C  03C0E821   ADDU SP, S8, ZERO
9D009990  8FBE0004   LW S8, 4(SP)
9D009994  27BD0008   ADDIU SP, SP, 8
9D009998  03E00008   JR RA
9D00999C  00000000   NOP
116:                 /****************************************************************************
117:                 *   FUNCTION:       ProcessMBCommand(void)                                   *
118:                 *                                                                           *
119:                 *   DESCRIPTION:    Looks at the MBBUff char array. Does not extract ID 
120:                  *                  Because that has already been qualified in uart.c.
121:                  *                  Extracts the command and the two parameters if msgState 
122:                  *                  is less than one. Runs the command though a switch, if
123:                  *                  the command does not need more bytes, it will process
124:                  *                  the command otherwise the function returns the number of 
125:                  *                  bytes required.  If ProcessMBCommand is run with msgState
126:                  *                  non-zero, the capture command and the capture parameters
127:                  *                  skipped.  The switch is run and the appropriate command
128:                  *                  extracts the rest of the required bytes and runs the command 
129:                 *                                             *
130:                 *   PARAMETERS:     cmdBuffer(uChar) - any char buffer but uart.c uses mbBuff
131:                  *                  BytesToFinishCmd(uChar) - if zero, assumes 8 bytes have been
132:                  *                  captured. If not zero, function assumes that the number in
133:                  *                  BytesToFinishCmd + 8 is the number total captured to that
134:                  *                  point and compares that to the number of bytes required
135:                  *                  to implement the command.                                            *
136:                 *   
137:                  * WARNING:         The process of extracting and running a MB command is not
138:                  *                  to start with less then 8 bytes.  When msgState is zero,
139:                  *                  the function assumes 8 bytes have been captured.  Any not
140:                  *                  zero number is the number of bytes needed to finish the 
141:                  *                  command, including the CRC check.  If mis-handled, the CRC
142:                  *                  numbers will not end up going to the CRC check.
143:                  *                  to b                                                                         *
144:                 *   RETURNS:        Zero if there were enough bytes to implement command, else
145:                  *                  returns the num of bytes to finish command. Returns zero if
146:                  *                  there were eneough bytes to implement command but there was
147:                  *                  an error.  Errors are loged though another module
148:                  *  
149:                  *                  1 if unitID found but in row are found then returns 1 *
150:                 *                                                                           *
151:                 *   REVISION:  0    v1.0                DATE:  12/10/2012            *
152:                                                                    *
153:                 ****************************************************************************/
154:                 uShort ProcessMBCommand(uChar* CmdBuffer, uChar BytesToFinishCmd, uChar UnitID)
155:                 {	
9D0099A0  27BDFFE8   ADDIU SP, SP, -24
9D0099A4  AFBF0014   SW RA, 20(SP)
9D0099A8  AFBE0010   SW S8, 16(SP)
9D0099AC  03A0F021   ADDU S8, SP, ZERO
9D0099B0  AFC40018   SW A0, 24(S8)
9D0099B4  00A01821   ADDU V1, A1, ZERO
9D0099B8  00C01021   ADDU V0, A2, ZERO
9D0099BC  A3C3001C   SB V1, 28(S8)
9D0099C0  A3C20020   SB V0, 32(S8)
156:                 	
157:                     if(BytesToFinishCmd <= 0)
9D0099C4  93C2001C   LBU V0, 28(S8)
9D0099C8  1440003C   BNE V0, ZERO, 0x9D009ABC
9D0099CC  00000000   NOP
158:                     {
159:                         mbCmdIndex = 1;	//Skip unit ID
9D0099D0  24020001   ADDIU V0, ZERO, 1
9D0099D4  A782809C   SH V0, -32612(GP)
160:                 	//Log Command
161:                 	mbCommand = CmdBuffer[mbCmdIndex++];
9D0099D8  9782809C   LHU V0, -32612(GP)
9D0099DC  00401821   ADDU V1, V0, ZERO
9D0099E0  8FC40018   LW A0, 24(S8)
9D0099E4  00831821   ADDU V1, A0, V1
9D0099E8  90630000   LBU V1, 0(V1)
9D0099EC  A783809E   SH V1, -32610(GP)
9D0099F0  24420001   ADDIU V0, V0, 1
9D0099F4  3042FFFF   ANDI V0, V0, -1
9D0099F8  A782809C   SH V0, -32612(GP)
162:                 	// Log Param1
163:                 	mbParam1 =  CmdBuffer[mbCmdIndex++]<<8;
9D0099FC  9782809C   LHU V0, -32612(GP)
9D009A00  00401821   ADDU V1, V0, ZERO
9D009A04  8FC40018   LW A0, 24(S8)
9D009A08  00831821   ADDU V1, A0, V1
9D009A0C  90630000   LBU V1, 0(V1)
9D009A10  00031A00   SLL V1, V1, 8
9D009A14  3063FFFF   ANDI V1, V1, -1
9D009A18  A78380A0   SH V1, -32608(GP)
9D009A1C  24420001   ADDIU V0, V0, 1
9D009A20  3042FFFF   ANDI V0, V0, -1
9D009A24  A782809C   SH V0, -32612(GP)
164:                 	mbParam1 += CmdBuffer[mbCmdIndex++]&0x00FF;
9D009A28  9782809C   LHU V0, -32612(GP)
9D009A2C  00401821   ADDU V1, V0, ZERO
9D009A30  8FC40018   LW A0, 24(S8)
9D009A34  00831821   ADDU V1, A0, V1
9D009A38  90630000   LBU V1, 0(V1)
9D009A3C  00602021   ADDU A0, V1, ZERO
9D009A40  978380A0   LHU V1, -32608(GP)
9D009A44  00831821   ADDU V1, A0, V1
9D009A48  3063FFFF   ANDI V1, V1, -1
9D009A4C  A78380A0   SH V1, -32608(GP)
9D009A50  24420001   ADDIU V0, V0, 1
9D009A54  3042FFFF   ANDI V0, V0, -1
9D009A58  A782809C   SH V0, -32612(GP)
165:                 	// Log Param2
166:                 	mbParam2 = CmdBuffer[mbCmdIndex++]<<8;
9D009A5C  9782809C   LHU V0, -32612(GP)
9D009A60  00401821   ADDU V1, V0, ZERO
9D009A64  8FC40018   LW A0, 24(S8)
9D009A68  00831821   ADDU V1, A0, V1
9D009A6C  90630000   LBU V1, 0(V1)
9D009A70  00031A00   SLL V1, V1, 8
9D009A74  3063FFFF   ANDI V1, V1, -1
9D009A78  A78380A2   SH V1, -32606(GP)
9D009A7C  24420001   ADDIU V0, V0, 1
9D009A80  3042FFFF   ANDI V0, V0, -1
9D009A84  A782809C   SH V0, -32612(GP)
167:                 	mbParam2 += CmdBuffer[mbCmdIndex++]&0x00FF;
9D009A88  9782809C   LHU V0, -32612(GP)
9D009A8C  00401821   ADDU V1, V0, ZERO
9D009A90  8FC40018   LW A0, 24(S8)
9D009A94  00831821   ADDU V1, A0, V1
9D009A98  90630000   LBU V1, 0(V1)
9D009A9C  00602021   ADDU A0, V1, ZERO
9D009AA0  978380A2   LHU V1, -32606(GP)
9D009AA4  00831821   ADDU V1, A0, V1
9D009AA8  3063FFFF   ANDI V1, V1, -1
9D009AAC  A78380A2   SH V1, -32606(GP)
9D009AB0  24420001   ADDIU V0, V0, 1
9D009AB4  3042FFFF   ANDI V0, V0, -1
9D009AB8  A782809C   SH V0, -32612(GP)
168:                 	//Start building response
169:                     }
170:                     switch(mbCommand)
9D009ABC  9782809E   LHU V0, -32610(GP)
9D009AC0  2C430073   SLTIU V1, V0, 115
9D009AC4  10600147   BEQ V1, ZERO, 0x9D009FE4
9D009AC8  00000000   NOP
9D009ACC  00021880   SLL V1, V0, 2
9D009AD0  3C029D01   LUI V0, -25343
9D009AD4  24429AE8   ADDIU V0, V0, -25880
9D009AD8  00621021   ADDU V0, V1, V0
9D009ADC  8C420000   LW V0, 0(V0)
9D009AE0  00400008   JR V0
9D009AE4  00000000   NOP
171:                     {	
172:                         case 1:
173:                 
174:                                 break;
9D00A008  00000000   NOP
9D00A00C  0B402806   J 0x9D00A018
9D00A010  00000000   NOP
175:                         case 2:
176:                 
177:                                 break;
178:                         case mbREAD_HOLDINGREGS: //0x03, 3 Reads and returns a number of holding registers
179:                             //Will use either SRAM or Ramtron memory based on address requested
180:                             if(rxCRCCheck(CmdBuffer,MIN_MB_MSG_SZ) == 1)//This command is always 8 bytes including CRC check
9D009CB4  8FC40018   LW A0, 24(S8)
9D009CB8  24050008   ADDIU A1, ZERO, 8
9D009CBC  0F4028C7   JAL rxCRCCheck
9D009CC0  00000000   NOP
9D009CC4  00401821   ADDU V1, V0, ZERO
9D009CC8  24020001   ADDIU V0, ZERO, 1
9D009CCC  146200D1   BNE V1, V0, 0x9D00A014
9D009CD0  00000000   NOP
181:                             {
182:                                     txLength = 0;
9D009CD4  A38081EA   SB ZERO, -32278(GP)
183:                                     CmdBuffer[txLength++] = CmdBuffer[0];//Send Back Unit ID
9D009CD8  938281EA   LBU V0, -32278(GP)
9D009CDC  00401821   ADDU V1, V0, ZERO
9D009CE0  8FC40018   LW A0, 24(S8)
9D009CE4  00831821   ADDU V1, A0, V1
9D009CE8  8FC40018   LW A0, 24(S8)
9D009CEC  90840000   LBU A0, 0(A0)
9D009CF0  A0640000   SB A0, 0(V1)
9D009CF4  24420001   ADDIU V0, V0, 1
9D009CF8  304200FF   ANDI V0, V0, 255
9D009CFC  A38281EA   SB V0, -32278(GP)
184:                                     CmdBuffer[txLength++] = CmdBuffer[1];//Send back command
9D009D00  938281EA   LBU V0, -32278(GP)
9D009D04  00401821   ADDU V1, V0, ZERO
9D009D08  8FC40018   LW A0, 24(S8)
9D009D0C  00831821   ADDU V1, A0, V1
9D009D10  8FC40018   LW A0, 24(S8)
9D009D14  24840001   ADDIU A0, A0, 1
9D009D18  90840000   LBU A0, 0(A0)
9D009D1C  A0640000   SB A0, 0(V1)
9D009D20  24420001   ADDIU V0, V0, 1
9D009D24  304200FF   ANDI V0, V0, 255
9D009D28  A38281EA   SB V0, -32278(GP)
185:                                     CmdBuffer[txLength++] = mbParam2;//Send Back num reg's to read
9D009D2C  938281EA   LBU V0, -32278(GP)
9D009D30  00401821   ADDU V1, V0, ZERO
9D009D34  8FC40018   LW A0, 24(S8)
9D009D38  00831821   ADDU V1, A0, V1
9D009D3C  978480A2   LHU A0, -32606(GP)
9D009D40  308400FF   ANDI A0, A0, 255
9D009D44  A0640000   SB A0, 0(V1)
9D009D48  24420001   ADDIU V0, V0, 1
9D009D4C  304200FF   ANDI V0, V0, 255
9D009D50  A38281EA   SB V0, -32278(GP)
186:                                     /*
187:                                     if(mbParam1 >= LOWER_NV_MEM_ADDRESS)//Use the ramtron
188:                                     {
189:                                             //Is this read all within the Ramtron ?
190:                                             if(mbParam1 + (mbParam2 * 2) > MAXRAMTRONADDRS)//If not send error
191:                                             {
192:                                                     SendErrorResponse(CmdBuffer,mbBAD_ADDRESS, UnitID); //bad address
193:                                                     return 0;//no need to get more of rxBuff
194:                                             }
195:                                             //txLength += ReadRTChars(mbParam1,mbParam2 * 2, &CmdBuffer[txLength]);
196:                                             TXMODBUS("Return Ramtron",14);
197:                                             //TXMODBUS(CmdBuffer,txLength);
198:                                     }
199:                                     // Does this read stay within the MCU memory?
200:                                     if(mbParam1 + (mbParam2 * 2) > MAXRAMTRONADDRS)//0X7D32(32,050)Num Reg go beyond memory size
201:                                     {
202:                                             SendErrorResponse(CmdBuffer,mbBAD_ADDRESS,UnitID); //bad address
203:                                     }
204:                                     //txLength += ReadMBArray2Chars(mbParam1,mbParam2,&CmdBuffer[txLength]);
205:                                     //txLength = AppendCRC(CmdBuffer, txLength);
206:                                     //TXMODBUS(CmdBuffer, txLength);
207:                                     //TXMODBUS("Return Not Ramtron",17);
208:                                      **/
209:                                      return 0;
9D009D54  00001021   ADDU V0, ZERO, ZERO
9D009D58  0B402807   J 0x9D00A01C
9D009D5C  00000000   NOP
210:                             }   
211:                             break;
9D00A014  00000000   NOP
212:                         case mbWRITE_REGISTER: //0x06 - Write then return single register
213:                             /*
214:                             if((mbParam1 + (mbParam2 * 2)) > MB_MEM_SZ) // Are you requesting more registers than memory
215:                             {
216:                                 SendErrorResponse(CmdBuffer,mbBAD_ADDRESS,UnitID); //2 = error code for address not ok
217:                               return 0;              
218:                             }
219:                             else
220:                             {
221:                                     //if(NumBytesCaptured < 8) return 8;//Get remaining bytes
222:                                     mbCmdIndex = 0;
223:                                     if(rxCRCCheck(CmdBuffer, mbParam2 * 2) == 1)
224:                                     {
225:                                             if((mbParam1 + mbParam2) > MB_MEM_SZ)
226:                                             {
227:                                                     CmdBuffer[1] = 83;//Send back error notification
228:                                                     CmdBuffer[2] = 2;// Error in address or quantity of registers
229:                                                     txLength = 3;
230:                                             }
231:                                             else
232:                                             {
233:                                                     MBMem[mbParam1 - 1] = mbParam2;
234:                                                     CmdBuffer[mbCmdIndex] = MBMem[mbParam1 - 1]>>8;
235:                                                     CmdBuffer[mbCmdIndex] = MBMem[mbParam1 - 1] & 0XFF;
236:                                             }
237:                                             txLength = AppendCRC(CmdBuffer, mbCmdIndex);
238:                                             TXMODBUS(CmdBuffer,8); // Just respond with the same message
239:                                     }	//
240:                             }
241:                             */
242:                             break;
243:                         case mbDIAGNOS_SERIAL:
244:                 
245:                             break;
246:                         case mbWRITE_MULTI_REGS://(0X10)Write Multiple Registers. Return Cmd, Start Addrss, NumRegs
247:                             if(BytesToFinishCmd <= 0)
9D009D60  93C2001C   LBU V0, 28(S8)
9D009D64  1440000B   BNE V0, ZERO, 0x9D009D94
9D009D68  00000000   NOP
248:                             {
249:                                 //The '9' is for single uChar ByteCount param plus the 8 bytes in the command
250:                                 if(mbParam2 > 0 ) return (mbParam2 * 2) + 9;//Num bytes needed to finish msg
9D009D6C  978280A2   LHU V0, -32606(GP)
9D009D70  10400008   BEQ V0, ZERO, 0x9D009D94
9D009D74  00000000   NOP
9D009D78  978280A2   LHU V0, -32606(GP)
9D009D7C  00021040   SLL V0, V0, 1
9D009D80  3042FFFF   ANDI V0, V0, -1
9D009D84  24420009   ADDIU V0, V0, 9
9D009D88  3042FFFF   ANDI V0, V0, -1
9D009D8C  0B402807   J 0x9D00A01C
9D009D90  00000000   NOP
251:                             }
252:                 
253:                 
254:                             if(rxCRCCheck(CmdBuffer,(mbParam2 * 2) + MIN_MB_MSG_SZ) == 1)
9D009D94  978280A2   LHU V0, -32606(GP)
9D009D98  24420004   ADDIU V0, V0, 4
9D009D9C  3042FFFF   ANDI V0, V0, -1
9D009DA0  00021040   SLL V0, V0, 1
9D009DA4  3042FFFF   ANDI V0, V0, -1
9D009DA8  8FC40018   LW A0, 24(S8)
9D009DAC  00402821   ADDU A1, V0, ZERO
9D009DB0  0F4028C7   JAL rxCRCCheck
9D009DB4  00000000   NOP
9D009DB8  00401821   ADDU V1, V0, ZERO
9D009DBC  24020001   ADDIU V0, ZERO, 1
9D009DC0  14620082   BNE V1, V0, 0x9D009FCC
9D009DC4  00000000   NOP
255:                             {
256:                                 txLength = rxBuffIndex = 0; //Start prepairing response
9D009DC8  A78080AA   SH ZERO, -32598(GP)
9D009DCC  A38081EA   SB ZERO, -32278(GP)
257:                                 CmdBuffer[txLength++] = CmdBuffer[rxBuffIndex++];//Send Back Unit ID
9D009DD0  938381EA   LBU V1, -32278(GP)
9D009DD4  00601021   ADDU V0, V1, ZERO
9D009DD8  8FC40018   LW A0, 24(S8)
9D009DDC  00822021   ADDU A0, A0, V0
9D009DE0  978280AA   LHU V0, -32598(GP)
9D009DE4  00402821   ADDU A1, V0, ZERO
9D009DE8  8FC60018   LW A2, 24(S8)
9D009DEC  00C52821   ADDU A1, A2, A1
9D009DF0  90A50000   LBU A1, 0(A1)
9D009DF4  A0850000   SB A1, 0(A0)
9D009DF8  24630001   ADDIU V1, V1, 1
9D009DFC  306300FF   ANDI V1, V1, 255
9D009E00  A38381EA   SB V1, -32278(GP)
9D009E04  24420001   ADDIU V0, V0, 1
9D009E08  3042FFFF   ANDI V0, V0, -1
9D009E0C  A78280AA   SH V0, -32598(GP)
258:                                 CmdBuffer[txLength++] = CmdBuffer[rxBuffIndex++];//Send Back command
9D009E10  938381EA   LBU V1, -32278(GP)
9D009E14  00601021   ADDU V0, V1, ZERO
9D009E18  8FC40018   LW A0, 24(S8)
9D009E1C  00822021   ADDU A0, A0, V0
9D009E20  978280AA   LHU V0, -32598(GP)
9D009E24  00402821   ADDU A1, V0, ZERO
9D009E28  8FC60018   LW A2, 24(S8)
9D009E2C  00C52821   ADDU A1, A2, A1
9D009E30  90A50000   LBU A1, 0(A1)
9D009E34  A0850000   SB A1, 0(A0)
9D009E38  24630001   ADDIU V1, V1, 1
9D009E3C  306300FF   ANDI V1, V1, 255
9D009E40  A38381EA   SB V1, -32278(GP)
9D009E44  24420001   ADDIU V0, V0, 1
9D009E48  3042FFFF   ANDI V0, V0, -1
9D009E4C  A78280AA   SH V0, -32598(GP)
259:                                 CmdBuffer[txLength++] = CmdBuffer[rxBuffIndex++];//Send High byte of Address
9D009E50  938381EA   LBU V1, -32278(GP)
9D009E54  00601021   ADDU V0, V1, ZERO
9D009E58  8FC40018   LW A0, 24(S8)
9D009E5C  00822021   ADDU A0, A0, V0
9D009E60  978280AA   LHU V0, -32598(GP)
9D009E64  00402821   ADDU A1, V0, ZERO
9D009E68  8FC60018   LW A2, 24(S8)
9D009E6C  00C52821   ADDU A1, A2, A1
9D009E70  90A50000   LBU A1, 0(A1)
9D009E74  A0850000   SB A1, 0(A0)
9D009E78  24630001   ADDIU V1, V1, 1
9D009E7C  306300FF   ANDI V1, V1, 255
9D009E80  A38381EA   SB V1, -32278(GP)
9D009E84  24420001   ADDIU V0, V0, 1
9D009E88  3042FFFF   ANDI V0, V0, -1
9D009E8C  A78280AA   SH V0, -32598(GP)
260:                                 CmdBuffer[txLength++] = CmdBuffer[rxBuffIndex++];//Send low byte of address
9D009E90  938381EA   LBU V1, -32278(GP)
9D009E94  00601021   ADDU V0, V1, ZERO
9D009E98  8FC40018   LW A0, 24(S8)
9D009E9C  00822021   ADDU A0, A0, V0
9D009EA0  978280AA   LHU V0, -32598(GP)
9D009EA4  00402821   ADDU A1, V0, ZERO
9D009EA8  8FC60018   LW A2, 24(S8)
9D009EAC  00C52821   ADDU A1, A2, A1
9D009EB0  90A50000   LBU A1, 0(A1)
9D009EB4  A0850000   SB A1, 0(A0)
9D009EB8  24630001   ADDIU V1, V1, 1
9D009EBC  306300FF   ANDI V1, V1, 255
9D009EC0  A38381EA   SB V1, -32278(GP)
9D009EC4  24420001   ADDIU V0, V0, 1
9D009EC8  3042FFFF   ANDI V0, V0, -1
9D009ECC  A78280AA   SH V0, -32598(GP)
261:                                 CmdBuffer[txLength++] = CmdBuffer[rxBuffIndex++];//Send High byte of num regs
9D009ED0  938381EA   LBU V1, -32278(GP)
9D009ED4  00601021   ADDU V0, V1, ZERO
9D009ED8  8FC40018   LW A0, 24(S8)
9D009EDC  00822021   ADDU A0, A0, V0
9D009EE0  978280AA   LHU V0, -32598(GP)
9D009EE4  00402821   ADDU A1, V0, ZERO
9D009EE8  8FC60018   LW A2, 24(S8)
9D009EEC  00C52821   ADDU A1, A2, A1
9D009EF0  90A50000   LBU A1, 0(A1)
9D009EF4  A0850000   SB A1, 0(A0)
9D009EF8  24630001   ADDIU V1, V1, 1
9D009EFC  306300FF   ANDI V1, V1, 255
9D009F00  A38381EA   SB V1, -32278(GP)
9D009F04  24420001   ADDIU V0, V0, 1
9D009F08  3042FFFF   ANDI V0, V0, -1
9D009F0C  A78280AA   SH V0, -32598(GP)
262:                                 CmdBuffer[txLength++] = CmdBuffer[rxBuffIndex++];//Send low byte of num regs
9D009F10  938381EA   LBU V1, -32278(GP)
9D009F14  00601021   ADDU V0, V1, ZERO
9D009F18  8FC40018   LW A0, 24(S8)
9D009F1C  00822021   ADDU A0, A0, V0
9D009F20  978280AA   LHU V0, -32598(GP)
9D009F24  00402821   ADDU A1, V0, ZERO
9D009F28  8FC60018   LW A2, 24(S8)
9D009F2C  00C52821   ADDU A1, A2, A1
9D009F30  90A50000   LBU A1, 0(A1)
9D009F34  A0850000   SB A1, 0(A0)
9D009F38  24630001   ADDIU V1, V1, 1
9D009F3C  306300FF   ANDI V1, V1, 255
9D009F40  A38381EA   SB V1, -32278(GP)
9D009F44  24420001   ADDIU V0, V0, 1
9D009F48  3042FFFF   ANDI V0, V0, -1
9D009F4C  A78280AA   SH V0, -32598(GP)
263:                                 /*
264:                                 if(mbParam1 >= LOWER_NV_MEM_ADDRESS)//Write to Ramtron
265:                                 {
266:                                         if((mbParam1 + (mbParam2 * 2)) > MAXRAMTRONADDRS)//Is the write within RT memory bounds?
267:                                         {
268:                                                 //if not send error
269:                                                 SendErrorResponse(CmdBuffer,2,UnitID); //bad address
270:                                                 return 0;
271:                                         }
272:                                         mbParam1 -= 1; //Internal MB memory is zero indexed
273:                                         rxBuffIndex++;//Skip over byte count
274:                                        // WriteRTChars(mbParam1 - OFFSET2RAMTRON, mbParam2*2, &CmdBuffer[rxBuffIndex]);
275:                                         txLength = AppendCRC(CmdBuffer, txLength);
276:                                         TXMODBUS(CmdBuffer,txLength); // Just respond with the same message
277:                                         return 0;
278:                                 }
279:                                 if((mbParam1 + (mbParam2 * 2)) > LOWER_NV_MEM_ADDRESS)//Is the write within MBMem memory bounds?
280:                                 {
281:                                         //if not send error
282:                                         SendErrorResponse(CmdBuffer, 2,UnitID); //bad address
283:                                         return 0;
284:                                 }*/
285:                                 //Write to MBMem
286:                                 mbParam1 -= 1; //Internal MB memory is zero indexed
9D009F50  978280A0   LHU V0, -32608(GP)
9D009F54  2442FFFF   ADDIU V0, V0, -1
9D009F58  3042FFFF   ANDI V0, V0, -1
9D009F5C  A78280A0   SH V0, -32608(GP)
287:                                 mbParam2 += mbParam1; //Normalize the num of regs to write
9D009F60  978380A2   LHU V1, -32606(GP)
9D009F64  978280A0   LHU V0, -32608(GP)
9D009F68  00621021   ADDU V0, V1, V0
9D009F6C  3042FFFF   ANDI V0, V0, -1
9D009F70  A78280A2   SH V0, -32606(GP)
288:                                 rxBuffIndex++;//Skip over byte count
9D009F74  978280AA   LHU V0, -32598(GP)
9D009F78  24420001   ADDIU V0, V0, 1
9D009F7C  3042FFFF   ANDI V0, V0, -1
9D009F80  A78280AA   SH V0, -32598(GP)
289:                                 while(mbParam1 < mbParam2)
9D009F84  00000000   NOP
9D009F88  978380A0   LHU V1, -32608(GP)
9D009F8C  978280A2   LHU V0, -32606(GP)
9D009F90  0062102B   SLTU V0, V1, V0
9D009F94  1440FFFC   BNE V0, ZERO, 0x9D009F88
9D009F98  00000000   NOP
290:                                 {/*
291:                                         MBMem[mbParam1] = CmdBuffer[rxBuffIndex++] << 8;
292:                                         MBMem[mbParam1++] += CmdBuffer[rxBuffIndex++];
293:                                   */
294:                                 }
295:                                 txLength = AppendCRC(CmdBuffer,txLength);
9D009F9C  938281EA   LBU V0, -32278(GP)
9D009FA0  8FC40018   LW A0, 24(S8)
9D009FA4  00402821   ADDU A1, V0, ZERO
9D009FA8  0F402882   JAL AppendCRC
9D009FAC  00000000   NOP
9D009FB0  A38281EA   SB V0, -32278(GP)
296:                                 TXMODBUS(CmdBuffer,txLength); // Just respond with the same message
9D009FB4  8FC30018   LW V1, 24(S8)
9D009FB8  938281EA   LBU V0, -32278(GP)
9D009FBC  00602021   ADDU A0, V1, ZERO
9D009FC0  00402821   ADDU A1, V0, ZERO
9D009FC4  0F402516   JAL WriteCharsU1
9D009FC8  00000000   NOP
297:                             }
298:                             return 0;
9D009FCC  00001021   ADDU V0, ZERO, ZERO
9D009FD0  0B402807   J 0x9D00A01C
9D009FD4  00000000   NOP
299:                             break;
300:                         case mbRDWR_MULTI_REGS:
301:                             return 2;
9D009FD8  24020002   ADDIU V0, ZERO, 2
9D009FDC  0B402807   J 0x9D00A01C
9D009FE0  00000000   NOP
302:                             break;
303:                         case cmdREADINTS: //0x64(100)   Read waveforms
304:                             //ReadInts(WvFmIn1,sParam1);
305:                             break;
306:                         case cmdWRITEINTS://0x66, 102
307:                             //WriteInts(x1,2);
308:                             break;
309:                         case cmdWRITECHARS://0x67, 103
310:                             //Sprintf(txAppBuff,"Param1 is %d, Param2 is %d\n\r",sParam1,sParam2);
311:                             //WriteChars(charData, sParam1);//txAppBuff, strlen(txAppBuff))
312:                             //TransmitInts(x1,2);
313:                             break;
314:                         case cmdRW_WVFM://0x68, 104
315:                                 //ReadAIN5(sParam1,sParam2);
316:                                 break;
317:                         case 112:
318:                         //	sprintf(txAppBuff,"Param1 is %d, Param2 is %d\n\r",sParam1,sParam2);
319:                             //TransmitChars("HelloJK\n",8);//txAppBuff, strlen(txAppBuff));
320:                             //MachineState != s_RXCMPLETE;
321:                             break;
322:                         case cmdRW_CHARS://0x69, 105
323:                 
324:                             //ReadChars(charData,sParam1);
325:                             //WriteChars(charData,sParam1);
326:                             //sprintf(txAppBuff,"Param1 is %d, Param2 is %d\n\r",sParam1,sParam2);
327:                             ////WriteChars("HelloJK\n",8);//txAppBuff, strlen(txAppBuff))
328:                 
329:                             //TransmitInts(x1,2);
330:                             break;
331:                         case cmdRDCHVLT:
332:                                 //ReadChannelVoltage(sParam1);
333:                                 break;
334:                         default:
335:                                 SendErrorResponse(CmdBuffer,1,UnitID); //Command not supported
9D009FE4  93C20020   LBU V0, 32(S8)
9D009FE8  8FC40018   LW A0, 24(S8)
9D009FEC  24050001   ADDIU A1, ZERO, 1
9D009FF0  00403021   ADDU A2, V0, ZERO
9D009FF4  0F40283D   JAL SendErrorResponse
9D009FF8  00000000   NOP
336:                                 return 0;
9D009FFC  00001021   ADDU V0, ZERO, ZERO
9D00A000  0B402807   J 0x9D00A01C
9D00A004  00000000   NOP
337:                                 break;
338:                     }
339:                 
340:                     return 0;
9D00A018  00001021   ADDU V0, ZERO, ZERO
341:                 }
9D00A01C  03C0E821   ADDU SP, S8, ZERO
9D00A020  8FBF0014   LW RA, 20(SP)
9D00A024  8FBE0010   LW S8, 16(SP)
9D00A028  27BD0018   ADDIU SP, SP, 24
9D00A02C  03E00008   JR RA
9D00A030  00000000   NOP
342:                 //Once process Modus command has finished and CRC checks out, 
343:                 //then run ImplementModbusCommand() which returns the index to the next
344:                 //txBuff location.
345:                 // Code saving function used by every command
346:                 //7/6/2011 finding that there are enough differences in commands to 
347:                 //make the function below unnecessary
348:                 uChar BuildResponseHeader(uChar *CmdBuffer, uShort CmdResponse, uChar UnitID)
349:                 {
9D00A034  27BDFFF0   ADDIU SP, SP, -16
9D00A038  AFBE000C   SW S8, 12(SP)
9D00A03C  03A0F021   ADDU S8, SP, ZERO
9D00A040  AFC40010   SW A0, 16(S8)
9D00A044  00A01821   ADDU V1, A1, ZERO
9D00A048  00C01021   ADDU V0, A2, ZERO
9D00A04C  A7C30014   SH V1, 20(S8)
9D00A050  A3C20018   SB V0, 24(S8)
350:                 	uChar mbCmdIndex = 0;
9D00A054  A3C00000   SB ZERO, 0(S8)
351:                 	CmdBuffer[mbCmdIndex++] = UnitID;//Send unit ID
9D00A058  93C20000   LBU V0, 0(S8)
9D00A05C  8FC30010   LW V1, 16(S8)
9D00A060  00621021   ADDU V0, V1, V0
9D00A064  93C30018   LBU V1, 24(S8)
9D00A068  A0430000   SB V1, 0(V0)
9D00A06C  93C20000   LBU V0, 0(S8)
9D00A070  24420001   ADDIU V0, V0, 1
9D00A074  A3C20000   SB V0, 0(S8)
352:                 	CmdBuffer[mbCmdIndex++] = mbCommand;//Send Command
9D00A078  93C20000   LBU V0, 0(S8)
9D00A07C  8FC30010   LW V1, 16(S8)
9D00A080  00621021   ADDU V0, V1, V0
9D00A084  9783809E   LHU V1, -32610(GP)
9D00A088  306300FF   ANDI V1, V1, 255
9D00A08C  A0430000   SB V1, 0(V0)
9D00A090  93C20000   LBU V0, 0(S8)
9D00A094  24420001   ADDIU V0, V0, 1
9D00A098  A3C20000   SB V0, 0(S8)
353:                 	CmdBuffer[mbCmdIndex++] = CmdResponse << 8;//Send high byte of response
9D00A09C  93C20000   LBU V0, 0(S8)
9D00A0A0  8FC30010   LW V1, 16(S8)
9D00A0A4  00621021   ADDU V0, V1, V0
9D00A0A8  A0400000   SB ZERO, 0(V0)
9D00A0AC  93C20000   LBU V0, 0(S8)
9D00A0B0  24420001   ADDIU V0, V0, 1
9D00A0B4  A3C20000   SB V0, 0(S8)
354:                 	CmdBuffer[mbCmdIndex++] = CmdResponse & 0X00FF;//Send low byte of response
9D00A0B8  93C20000   LBU V0, 0(S8)
9D00A0BC  8FC30010   LW V1, 16(S8)
9D00A0C0  00621021   ADDU V0, V1, V0
9D00A0C4  97C30014   LHU V1, 20(S8)
9D00A0C8  306300FF   ANDI V1, V1, 255
9D00A0CC  A0430000   SB V1, 0(V0)
9D00A0D0  93C20000   LBU V0, 0(S8)
9D00A0D4  24420001   ADDIU V0, V0, 1
9D00A0D8  A3C20000   SB V0, 0(S8)
355:                 	return mbCmdIndex;//returns 4
9D00A0DC  93C20000   LBU V0, 0(S8)
356:                 }
9D00A0E0  03C0E821   ADDU SP, S8, ZERO
9D00A0E4  8FBE000C   LW S8, 12(SP)
9D00A0E8  27BD0010   ADDIU SP, SP, 16
9D00A0EC  03E00008   JR RA
9D00A0F0  00000000   NOP
357:                 
358:                 void SendErrorResponse(uChar *CmdBuffer,uChar ErrorCode, uChar UnitID)
359:                 {
9D00A0F4  27BDFFE8   ADDIU SP, SP, -24
9D00A0F8  AFBF0014   SW RA, 20(SP)
9D00A0FC  AFBE0010   SW S8, 16(SP)
9D00A100  03A0F021   ADDU S8, SP, ZERO
9D00A104  AFC40018   SW A0, 24(S8)
9D00A108  00A01821   ADDU V1, A1, ZERO
9D00A10C  00C01021   ADDU V0, A2, ZERO
9D00A110  A3C3001C   SB V1, 28(S8)
9D00A114  A3C20020   SB V0, 32(S8)
360:                 	mbCmdIndex = 0;
9D00A118  A780809C   SH ZERO, -32612(GP)
361:                 	CmdBuffer[mbCmdIndex] = UnitID;//Send unit ID
9D00A11C  9782809C   LHU V0, -32612(GP)
9D00A120  8FC30018   LW V1, 24(S8)
9D00A124  00621021   ADDU V0, V1, V0
9D00A128  93C30020   LBU V1, 32(S8)
9D00A12C  A0430000   SB V1, 0(V0)
362:                 	mbCmdIndex++;	
9D00A130  9782809C   LHU V0, -32612(GP)
9D00A134  24420001   ADDIU V0, V0, 1
9D00A138  3042FFFF   ANDI V0, V0, -1
9D00A13C  A782809C   SH V0, -32612(GP)
363:                 	CmdBuffer[mbCmdIndex] = CmdBuffer[mbCmdIndex]+0X80;//Send Command plus error offset
9D00A140  9782809C   LHU V0, -32612(GP)
9D00A144  8FC30018   LW V1, 24(S8)
9D00A148  00621021   ADDU V0, V1, V0
9D00A14C  9783809C   LHU V1, -32612(GP)
9D00A150  8FC40018   LW A0, 24(S8)
9D00A154  00831821   ADDU V1, A0, V1
9D00A158  90630000   LBU V1, 0(V1)
9D00A15C  2463FF80   ADDIU V1, V1, -128
9D00A160  306300FF   ANDI V1, V1, 255
9D00A164  A0430000   SB V1, 0(V0)
364:                 	mbCmdIndex++;	
9D00A168  9782809C   LHU V0, -32612(GP)
9D00A16C  24420001   ADDIU V0, V0, 1
9D00A170  3042FFFF   ANDI V0, V0, -1
9D00A174  A782809C   SH V0, -32612(GP)
365:                 	CmdBuffer[mbCmdIndex++] = 0;//Send high byte of starting address
9D00A178  9782809C   LHU V0, -32612(GP)
9D00A17C  00401821   ADDU V1, V0, ZERO
9D00A180  8FC40018   LW A0, 24(S8)
9D00A184  00831821   ADDU V1, A0, V1
9D00A188  A0600000   SB ZERO, 0(V1)
9D00A18C  24420001   ADDIU V0, V0, 1
9D00A190  3042FFFF   ANDI V0, V0, -1
9D00A194  A782809C   SH V0, -32612(GP)
366:                 	CmdBuffer[mbCmdIndex++] = ErrorCode;//Send low byte of starting addres
9D00A198  9782809C   LHU V0, -32612(GP)
9D00A19C  00401821   ADDU V1, V0, ZERO
9D00A1A0  8FC40018   LW A0, 24(S8)
9D00A1A4  00831821   ADDU V1, A0, V1
9D00A1A8  93C4001C   LBU A0, 28(S8)
9D00A1AC  A0640000   SB A0, 0(V1)
9D00A1B0  24420001   ADDIU V0, V0, 1
9D00A1B4  3042FFFF   ANDI V0, V0, -1
9D00A1B8  A782809C   SH V0, -32612(GP)
367:                 	mbCmdIndex = AppendCRC(CmdBuffer,mbCmdIndex);
9D00A1BC  9782809C   LHU V0, -32612(GP)
9D00A1C0  304200FF   ANDI V0, V0, 255
9D00A1C4  8FC40018   LW A0, 24(S8)
9D00A1C8  00402821   ADDU A1, V0, ZERO
9D00A1CC  0F402882   JAL AppendCRC
9D00A1D0  00000000   NOP
9D00A1D4  A782809C   SH V0, -32612(GP)
368:                 	TXMODBUS(CmdBuffer,mbCmdIndex);
9D00A1D8  8FC30018   LW V1, 24(S8)
9D00A1DC  9782809C   LHU V0, -32612(GP)
9D00A1E0  00602021   ADDU A0, V1, ZERO
9D00A1E4  00402821   ADDU A1, V0, ZERO
9D00A1E8  0F402516   JAL WriteCharsU1
9D00A1EC  00000000   NOP
369:                 }	
9D00A1F0  03C0E821   ADDU SP, S8, ZERO
9D00A1F4  8FBF0014   LW RA, 20(SP)
9D00A1F8  8FBE0010   LW S8, 16(SP)
9D00A1FC  27BD0018   ADDIU SP, SP, 24
9D00A200  03E00008   JR RA
9D00A204  00000000   NOP
370:                 /* This is marked for future deletion
371:                 void RunPendingCommand()
372:                 {
373:                 	if(sCommand == 0) return;
374:                 	switch(sCommand)
375:                 	{		
376:                 		case 1:
377:                 
378:                 			break;		
379:                 		case 2:
380:                 
381:                 			break;		
382:                 		case mbREAD_IREGISTERS: //0x04, 4
383:                 			
384:                 			break;
385:                 		case mbWRITE_REGISTER: //0x06
386:                 		
387:                 			break;
388:                 		default:
389:                 			//bad command
390:                 			break;
391:                 		sCommand = 0;
392:                 	}
393:                 }
394:                 
395:                 */
396:                 //Takes the current txIndex number and calculate the CRC
397:                 // on the array up to that point.
398:                 //Returns msLen + 2
399:                 uChar AppendCRC(uChar *cmdBuffer, uChar msgLen)
400:                 {
9D00A208  27BDFFF8   ADDIU SP, SP, -8
9D00A20C  AFBE0004   SW S8, 4(SP)
9D00A210  03A0F021   ADDU S8, SP, ZERO
9D00A214  AFC40008   SW A0, 8(S8)
9D00A218  00A01021   ADDU V0, A1, ZERO
9D00A21C  A3C2000C   SB V0, 12(S8)
401:                 
402:                 	lowCRC = 0xFF ; // high byte of CRC initialized 
9D00A220  2402FFFF   ADDIU V0, ZERO, -1
9D00A224  A38281ED   SB V0, -32275(GP)
403:                 	highCRC = 0xFF ; // low byte of CRC initialized
9D00A228  2402FFFF   ADDIU V0, ZERO, -1
9D00A22C  A38281EB   SB V0, -32277(GP)
404:                 	for(fIndex=0; fIndex<msgLen; fIndex++) /* pass through message buffer */
9D00A230  A38081E9   SB ZERO, -32279(GP)
9D00A234  0B4028AC   J 0x9D00A2B0
9D00A238  00000000   NOP
9D00A2A0  938281E9   LBU V0, -32279(GP)
9D00A2A4  24420001   ADDIU V0, V0, 1
9D00A2A8  304200FF   ANDI V0, V0, 255
9D00A2AC  A38281E9   SB V0, -32279(GP)
9D00A2B0  938281E9   LBU V0, -32279(GP)
9D00A2B4  93C3000C   LBU V1, 12(S8)
9D00A2B8  0043102B   SLTU V0, V0, V1
9D00A2BC  1440FFDF   BNE V0, ZERO, 0x9D00A23C
9D00A2C0  00000000   NOP
405:                 	{
406:                 		indexCRC = lowCRC ^ cmdBuffer[fIndex] ; /* calculate the CRC */
9D00A23C  938281E9   LBU V0, -32279(GP)
9D00A240  8FC30008   LW V1, 8(S8)
9D00A244  00621021   ADDU V0, V1, V0
9D00A248  90430000   LBU V1, 0(V0)
9D00A24C  938281ED   LBU V0, -32275(GP)
9D00A250  00621026   XOR V0, V1, V0
9D00A254  304200FF   ANDI V0, V0, 255
9D00A258  A38281E8   SB V0, -32280(GP)
407:                 		lowCRC = highCRC ^ hiCRCbyte[indexCRC ] ;
9D00A25C  938281E8   LBU V0, -32280(GP)
9D00A260  00401821   ADDU V1, V0, ZERO
9D00A264  3C029D01   LUI V0, -25343
9D00A268  2442535C   ADDIU V0, V0, 21340
9D00A26C  00621021   ADDU V0, V1, V0
9D00A270  90430000   LBU V1, 0(V0)
9D00A274  938281EB   LBU V0, -32277(GP)
9D00A278  00621026   XOR V0, V1, V0
9D00A27C  304200FF   ANDI V0, V0, 255
9D00A280  A38281ED   SB V0, -32275(GP)
408:                 		highCRC = lowCRCbyte[indexCRC];
9D00A284  938281E8   LBU V0, -32280(GP)
9D00A288  00401821   ADDU V1, V0, ZERO
9D00A28C  3C029D01   LUI V0, -25343
9D00A290  2442545C   ADDIU V0, V0, 21596
9D00A294  00621021   ADDU V0, V1, V0
9D00A298  90420000   LBU V0, 0(V0)
9D00A29C  A38281EB   SB V0, -32277(GP)
409:                 	}
410:                 	cmdBuffer[msgLen++] = lowCRC;
9D00A2C4  93C2000C   LBU V0, 12(S8)
9D00A2C8  8FC30008   LW V1, 8(S8)
9D00A2CC  00621021   ADDU V0, V1, V0
9D00A2D0  938381ED   LBU V1, -32275(GP)
9D00A2D4  A0430000   SB V1, 0(V0)
9D00A2D8  93C2000C   LBU V0, 12(S8)
9D00A2DC  24420001   ADDIU V0, V0, 1
9D00A2E0  A3C2000C   SB V0, 12(S8)
411:                 	cmdBuffer[msgLen++] = highCRC;
9D00A2E4  93C2000C   LBU V0, 12(S8)
9D00A2E8  8FC30008   LW V1, 8(S8)
9D00A2EC  00621021   ADDU V0, V1, V0
9D00A2F0  938381EB   LBU V1, -32277(GP)
9D00A2F4  A0430000   SB V1, 0(V0)
9D00A2F8  93C2000C   LBU V0, 12(S8)
9D00A2FC  24420001   ADDIU V0, V0, 1
9D00A300  A3C2000C   SB V0, 12(S8)
412:                 	return msgLen;
9D00A304  93C2000C   LBU V0, 12(S8)
413:                 }
9D00A308  03C0E821   ADDU SP, S8, ZERO
9D00A30C  8FBE0004   LW S8, 4(SP)
9D00A310  27BD0008   ADDIU SP, SP, 8
9D00A314  03E00008   JR RA
9D00A318  00000000   NOP
414:                 
415:                 
416:                 //Check CRC msgLength includes CRC
417:                 uChar rxCRCCheck(uChar * mbCmdBuff, uShort msgLength)
418:                 {
9D00A31C  27BDFFF8   ADDIU SP, SP, -8
9D00A320  AFBE0004   SW S8, 4(SP)
9D00A324  03A0F021   ADDU S8, SP, ZERO
9D00A328  AFC40008   SW A0, 8(S8)
9D00A32C  00A01021   ADDU V0, A1, ZERO
9D00A330  A7C2000C   SH V0, 12(S8)
419:                 	lowCRC = 0xFF ; /* high byte of CRC initialized */
9D00A334  2402FFFF   ADDIU V0, ZERO, -1
9D00A338  A38281ED   SB V0, -32275(GP)
420:                 	highCRC = 0xFF ; /* low byte of CRC initialized*/
9D00A33C  2402FFFF   ADDIU V0, ZERO, -1
9D00A340  A38281EB   SB V0, -32277(GP)
421:                 	for(fIndex = 0; fIndex < msgLength-2; fIndex++) //Do not include CRC
9D00A344  A38081E9   SB ZERO, -32279(GP)
9D00A348  0B4028F1   J 0x9D00A3C4
9D00A34C  00000000   NOP
9D00A3B4  938281E9   LBU V0, -32279(GP)
9D00A3B8  24420001   ADDIU V0, V0, 1
9D00A3BC  304200FF   ANDI V0, V0, 255
9D00A3C0  A38281E9   SB V0, -32279(GP)
9D00A3C4  938281E9   LBU V0, -32279(GP)
9D00A3C8  00401821   ADDU V1, V0, ZERO
9D00A3CC  97C2000C   LHU V0, 12(S8)
9D00A3D0  2442FFFE   ADDIU V0, V0, -2
9D00A3D4  0062102A   SLT V0, V1, V0
9D00A3D8  1440FFDD   BNE V0, ZERO, 0x9D00A350
9D00A3DC  00000000   NOP
422:                 	{
423:                 		indexCRC = lowCRC ^ mbCmdBuff[fIndex]; /* calculate the CRC */
9D00A350  938281E9   LBU V0, -32279(GP)
9D00A354  8FC30008   LW V1, 8(S8)
9D00A358  00621021   ADDU V0, V1, V0
9D00A35C  90430000   LBU V1, 0(V0)
9D00A360  938281ED   LBU V0, -32275(GP)
9D00A364  00621026   XOR V0, V1, V0
9D00A368  304200FF   ANDI V0, V0, 255
9D00A36C  A38281E8   SB V0, -32280(GP)
424:                 		lowCRC = highCRC ^ hiCRCbyte[indexCRC] ;
9D00A370  938281E8   LBU V0, -32280(GP)
9D00A374  00401821   ADDU V1, V0, ZERO
9D00A378  3C029D01   LUI V0, -25343
9D00A37C  2442535C   ADDIU V0, V0, 21340
9D00A380  00621021   ADDU V0, V1, V0
9D00A384  90430000   LBU V1, 0(V0)
9D00A388  938281EB   LBU V0, -32277(GP)
9D00A38C  00621026   XOR V0, V1, V0
9D00A390  304200FF   ANDI V0, V0, 255
9D00A394  A38281ED   SB V0, -32275(GP)
425:                 		highCRC = lowCRCbyte[indexCRC];
9D00A398  938281E8   LBU V0, -32280(GP)
9D00A39C  00401821   ADDU V1, V0, ZERO
9D00A3A0  3C029D01   LUI V0, -25343
9D00A3A4  2442545C   ADDIU V0, V0, 21596
9D00A3A8  00621021   ADDU V0, V1, V0
9D00A3AC  90420000   LBU V0, 0(V0)
9D00A3B0  A38281EB   SB V0, -32277(GP)
426:                 	}
427:                 	if(mbCmdBuff[fIndex++] == lowCRC)
9D00A3E0  938281E9   LBU V0, -32279(GP)
9D00A3E4  00401821   ADDU V1, V0, ZERO
9D00A3E8  8FC40008   LW A0, 8(S8)
9D00A3EC  00831821   ADDU V1, A0, V1
9D00A3F0  90640000   LBU A0, 0(V1)
9D00A3F4  938381ED   LBU V1, -32275(GP)
9D00A3F8  00831826   XOR V1, A0, V1
9D00A3FC  2C630001   SLTIU V1, V1, 1
9D00A400  306300FF   ANDI V1, V1, 255
9D00A404  24420001   ADDIU V0, V0, 1
9D00A408  304200FF   ANDI V0, V0, 255
9D00A40C  A38281E9   SB V0, -32279(GP)
9D00A410  1060000B   BEQ V1, ZERO, 0x9D00A440
9D00A414  00000000   NOP
428:                 	{
429:                 		if(mbCmdBuff[fIndex] == highCRC)
9D00A418  938281E9   LBU V0, -32279(GP)
9D00A41C  8FC30008   LW V1, 8(S8)
9D00A420  00621021   ADDU V0, V1, V0
9D00A424  90430000   LBU V1, 0(V0)
9D00A428  938281EB   LBU V0, -32277(GP)
9D00A42C  14620004   BNE V1, V0, 0x9D00A440
9D00A430  00000000   NOP
430:                 		{
431:                 			return 1;	
9D00A434  24020001   ADDIU V0, ZERO, 1
9D00A438  0B402911   J 0x9D00A444
9D00A43C  00000000   NOP
432:                 		}
433:                 	}
434:                 	return 0;
9D00A440  00001021   ADDU V0, ZERO, ZERO
435:                 	
436:                 }
9D00A444  03C0E821   ADDU SP, S8, ZERO
9D00A448  8FBE0004   LW S8, 4(SP)
9D00A44C  27BD0008   ADDIU SP, SP, 8
9D00A450  03E00008   JR RA
9D00A454  00000000   NOP
437:                 void SendReg(int RegNum)
438:                 {
9D00A458  27BDFFF8   ADDIU SP, SP, -8
9D00A45C  AFBE0004   SW S8, 4(SP)
9D00A460  03A0F021   ADDU S8, SP, ZERO
9D00A464  AFC40008   SW A0, 8(S8)
439:                 	
440:                 }
9D00A468  03C0E821   ADDU SP, S8, ZERO
9D00A46C  8FBE0004   LW S8, 4(SP)
9D00A470  27BD0008   ADDIU SP, SP, 8
9D00A474  03E00008   JR RA
9D00A478  00000000   NOP
441:                 void SendStrReg(char *Msg, int RegNum)
442:                 {
9D00A47C  27BDFFF8   ADDIU SP, SP, -8
9D00A480  AFBE0004   SW S8, 4(SP)
9D00A484  03A0F021   ADDU S8, SP, ZERO
9D00A488  AFC40008   SW A0, 8(S8)
9D00A48C  AFC5000C   SW A1, 12(S8)
443:                 	
444:                 }
9D00A490  03C0E821   ADDU SP, S8, ZERO
9D00A494  8FBE0004   LW S8, 4(SP)
9D00A498  27BD0008   ADDIU SP, SP, 8
9D00A49C  03E00008   JR RA
9D00A4A0  00000000   NOP
445:                 //Reads NumRegisters Modbus register(s) starting at start address 
446:                 /*/Returns the number of bytes added to the txBuffer
447:                 uChar ReadMCUMemory(uShort StartAddress, uChar NumRegisters, uChar TXLength)
448:                 {
449:                 	NumRegisters += StartAddress - 1;
450:                 	for(mbIndex = StartAddress - 1; mbIndex<NumRegisters; mbIndex++)
451:                 	{
452:                 		cmdBuffer[TXLength++] = MBMem[mbIndex] >> 8;
453:                 		cmdBuffer[TXLength++] = MBMem[mbIndex] & 0X00FF;
454:                 	}
455:                 	return TXLength;
456:                 }
457:                 uChar WriteMBMemory(uShort StartAddress, uChar NumRegisters, uChar TXLength)
458:                 {
459:                 	NumRegisters += StartAddress - 1;
460:                 	for(mbIndex = StartAddress - 1; mbIndex<NumRegisters; mbIndex++)
461:                 	{
462:                 		MBMem[mbIndex] = cmdBuffer[TXLength++] << 8;
463:                 		MBMem[mbIndex] += cmdBuffer[TXLength++];
464:                 	}
465:                 	return TXLength;
466:                 }
467:                 */
468:                 
---  C:/MC_XProjects/LIBS/MENUS_LIB/MENU_SOURCE/tMenus.c  -----------------------------------------------
1:                   
2:                   /****************************************************************************
3:                      CREATED BY: 	Stillbright Managment LLC
4:                   *					Copyright 2012
5:                   *
6:                   *   FILE:           tMenus.c
7:                   *
8:                   *   DESCRIPTION:    Menu System for displaying to and interacting with users
9:                   *	through a hypertermal or TTY type interface.
10:                  	OVERVIEW:	The System is based on a menu state machine that changes state based on the
11:                  	operation to be performed, some examples of different states are, menu navigation, SetIntConfig,
12:                  	SetUintConfig, SetStringConfig, SetBinaryConfig.  The different states control and verify
13:                  	the input requirements and restriction of each type of parameter that needs to be configured.
14:                  	All function fall into two main catagories, navigation and configuration.  While navagation
15:                  	funtions can have depth, allowing users to go up and down a menu tree. Configuration function
16:                  	are one deep.  This means that a user can go done several levels to select a parameter to
17:                  	change and  once the change is made the system will automatically return the user back to the
18:                  	previous menu that called the configuration function. Both groups of funtions have simular
19:                  	structure.  Both can return a char pointer and take a char pointer as the first argument.  The
20:                  	second argument is specific to the type of parameter to be changed; menu keypress, int,
21:                  	unsigned int, string, binary, ect.  Both types of functions also have a default string that
22:                  	is use to communcate options and actions to the user.
23:                  
24:                  	The menu system starts with the main menu function found in tmenu.c.
25:                  					char* MainMenu(char* cBuff, char keyPress)
26:                  	This function holds the default string discribing the start of the menu tree and the options
27:                  	avaiable within.  The MainMenu function is a templet for all other functions.  It contains
28:                   *      a switch that will do one of three things.
29:                   *          1. If <0 Return a string discribing what options are available
30:                   *          2. 0 to 9 - Call SetMenuPage and assign a funtion that will call another menu function
31:                   *          3. 0 to 9 - call SetxxxConfig and assign a function that config an int, float, string, etc. function
32:                  	Menu type functions will only recognize a single keypress of zero to 9 or other
33:                   *      control key char.
34:                   *      Configuration functions are called from a menu function by using a SetXXXConfig function.  A
35:                   *      SetXXXConfig function takes a function pointer as its single argument.  The structure
36:                  	of any particular function is defined in tmenu.h.
37:                  
38:                  	The system is set up so that menu navigation and configuration settings can broken out and contained
39:                  	within the files associated with the periphereal.  The setting to
40:                  
41:                  *
42:                  *   CREATED:		Feb 24 2012
43:                  *   REVISION:   v0.1 - Define operation and functions
44:                  *   3/8/2012    tMenus_old0.h abandoned for a function pointer system
45:                  *   4/2/2012    Moved uart function over to c_uart.h.  Exposed CONFIG_FUNCTION,
46:                   *              and all function pointers to other files, so that thier menu confiuration
47:                   *              function can control tmenu.
48:                   * 4/14/2012    Undid work done on 4/2, created SetXXXConfig functions that
49:                   *              will change the state of the CONFIG_FUNCTION to the apporiate
50:                   *              type of parameter to be configured and also take the supplied 
51:                   *              function pointer, and set it to the appropriate menu function pointer
52:                   * 12/16/12     Changed code to exit menu system if esc is received while in main
53:                   *              menu screen.
54:                  ****************************************************************************/
55:                  
56:                  #include <stdio.h>
57:                  #include <stdlib.h>
58:                  #include <string.h>
59:                  #include "../../SYS_LIB/sysglobals.h"
60:                  #include "../../../LIBS/SYS_LIB/c_uart.h"
61:                  #include "../../../Microhip/Include/Graphics/Graphics.h"
62:                  #include "../../../LIBS/SYS_LIB/lcd_interface.h"
63:                  #include "../tMenus.h"
64:                  
65:                  
66:                  uChar	uBuffIndex = 0,
67:                          aBufferIndex = 0;
68:                  
69:                  char	ScreenBuff[MENUBUFF_SZ],
70:                          *mBuff,
71:                          rtnCount = 0,
72:                          notZeroFlag = 0, //this flag is set to show user sent something other then zero 
73:                          negSymbolExists = 0, // This flag limits input to one negative symbol
74:                          decimalExists = 0,  //User gets one decimal place.
75:                          menuSelection = 0,
76:                          menuExitFlag = 0,
77:                          alphaBuff[8];// alpha number buffer for atoi function
78:                  uInt    tempuInt = 0;
79:                  int     tempInt = 0;
80:                  long    tempLong = 0;
81:                  int     param1Int = 0;//Hold a parameter used when doing configuration
82:                  float	tempFloat = 0;	//Holds atof conversion 
83:                  //uChar rxIndex = 0; //For building string arrays of ints, floats and strings
84:                  char* (*MenuHomePage)(char*, char);
85:                  char* (*CurrentMenuPtr)(char*, char);
86:                  char* (*IntFunctionPtr)(char*, int);
87:                  char* (*uIntFunctionPtr)(char*, uInt);
88:                  char* (*LongFunctionPtr)(char*, double);
89:                  char* (*StrFunctionPtr)(char*, uInt);
90:                  char* (*FloatFunctionPtr)(char*, float);
91:                  char* (*MenuHistory[5])(char*, char); 
92:                  char    keyBuff[5],//Holds the history of keys pressed in menu history
93:                          menuIndex = 0,
94:                          mainMenuFlag = 0;//menu history index
95:                  //TODO set null pointers to SetXXXConfig to see how they are handled
96:                  //TODO make sure all SetXXXConfigs handle '-' and '.' properly
97:                  void ResetMenu(void)
98:                  {
9D004790  27BDFFF8   ADDIU SP, SP, -8
9D004794  AFBE0004   SW S8, 4(SP)
9D004798  03A0F021   ADDU S8, SP, ZERO
99:                      menuExitFlag = 0;
9D00479C  A380807B   SB ZERO, -32645(GP)
100:                     MENU_ACTION = MENU_INACTIVE;
9D0047A0  AF808070   SW ZERO, -32656(GP)
101:                     menuIndex = 0;
9D0047A4  A3808090   SB ZERO, -32624(GP)
102:                 }
9D0047A8  03C0E821   ADDU SP, S8, ZERO
9D0047AC  8FBE0004   LW S8, 4(SP)
9D0047B0  27BD0008   ADDIU SP, SP, 8
9D0047B4  03E00008   JR RA
9D0047B8  00000000   NOP
103:                 char* RunMenu(char *cBuff)
104:                 {
9D0047BC  27BDFFD8   ADDIU SP, SP, -40
9D0047C0  AFBF0024   SW RA, 36(SP)
9D0047C4  AFBE0020   SW S8, 32(SP)
9D0047C8  AFB0001C   SW S0, 28(SP)
9D0047CC  03A0F021   ADDU S8, SP, ZERO
9D0047D0  AFC40028   SW A0, 40(S8)
105:                     
106:                     uBuffIndex = 0x00;
9D0047D4  A3808074   SB ZERO, -32652(GP)
107:                     //Limit the number of of key inputs to one
108:                     char keyPress  = cBuff[0];
9D0047D8  8FC20028   LW V0, 40(S8)
9D0047DC  90420000   LBU V0, 0(V0)
9D0047E0  A3C20010   SB V0, 16(S8)
109:                     
110:                     //INT_INPUT stores chars from user until CR then converts to int
111:                     //then takes int and uses it to set pre selected variable of
112:                     //pre-selected object.
113:                     if(MENU_ACTION == INPUT_INT)
9D0047E4  8F838070   LW V1, -32656(GP)
9D0047E8  24020003   ADDIU V0, ZERO, 3
9D0047EC  146200DB   BNE V1, V0, 0x9D004B5C
9D0047F0  00000000   NOP
114:                     {
115:                         if(IntFunctionPtr == NULL )//Be sure your pointing at something
9D0047F4  8F8281B4   LW V0, -32332(GP)
9D0047F8  14400013   BNE V0, ZERO, 0x9D004848
9D0047FC  00000000   NOP
116:                         {
117:                             sprintf(cBuff,"Null Pointer Error \r\n ");
9D004800  8FC40028   LW A0, 40(S8)
9D004804  3C029D01   LUI V0, -25343
9D004808  24457D30   ADDIU A1, V0, 32048
9D00480C  24060017   ADDIU A2, ZERO, 23
9D004810  0F405AA3   JAL 0x9D016A8C
9D004814  00000000   NOP
118:                             CurrentMenuPtr(&cBuff[23],-1);//Re Run last menu;
9D004818  8F8281E4   LW V0, -32284(GP)
9D00481C  8FC30028   LW V1, 40(S8)
9D004820  24630017   ADDIU V1, V1, 23
9D004824  00602021   ADDU A0, V1, ZERO
9D004828  2405FFFF   ADDIU A1, ZERO, -1
9D00482C  0040F809   JALR V0
9D004830  00000000   NOP
119:                             MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D004834  24020002   ADDIU V0, ZERO, 2
9D004838  AF828070   SW V0, -32656(GP)
120:                             return cBuff;
9D00483C  8FC20028   LW V0, 40(S8)
9D004840  0B401700   J 0x9D005C00
9D004844  00000000   NOP
121:                         }
122:                         if(cBuff[0] == 0x00) return IntFunctionPtr(cBuff, 0); // RunMenu
9D004848  8FC20028   LW V0, 40(S8)
9D00484C  80420000   LB V0, 0(V0)
9D004850  144000B5   BNE V0, ZERO, 0x9D004B28
9D004854  00000000   NOP
9D004858  8F8281B4   LW V0, -32332(GP)
9D00485C  8FC40028   LW A0, 40(S8)
9D004860  00002821   ADDU A1, ZERO, ZERO
9D004864  0040F809   JALR V0
9D004868  00000000   NOP
9D00486C  0B401700   J 0x9D005C00
9D004870  00000000   NOP
123:                         while(cBuff[uBuffIndex] != 0x00)
9D004B28  00000000   NOP
9D004B2C  93828074   LBU V0, -32652(GP)
9D004B30  8FC30028   LW V1, 40(S8)
9D004B34  00621021   ADDU V0, V1, V0
9D004B38  80420000   LB V0, 0(V0)
9D004B3C  1440FF4D   BNE V0, ZERO, 0x9D004874
9D004B40  00000000   NOP
124:                         {
125:                             // bound input to numbers and negative symbol. Exclude '.' and '/'
126:                             if((cBuff[uBuffIndex] == 45)&&(negSymbolExists != 0)) //capture negative symbol
9D004874  93828074   LBU V0, -32652(GP)
9D004878  8FC30028   LW V1, 40(S8)
9D00487C  00621021   ADDU V0, V1, V0
9D004880  80430000   LB V1, 0(V0)
9D004884  2402002D   ADDIU V0, ZERO, 45
9D004888  14620016   BNE V1, V0, 0x9D0048E4
9D00488C  00000000   NOP
9D004890  83828078   LB V0, -32648(GP)
9D004894  10400013   BEQ V0, ZERO, 0x9D0048E4
9D004898  00000000   NOP
127:                             {
128:                                 negSymbolExists = 1; // user only gets one negative symbol
9D00489C  24020001   ADDIU V0, ZERO, 1
9D0048A0  A3828078   SB V0, -32648(GP)
129:                                 alphaBuff[aBufferIndex++] = cBuff[uBuffIndex++];
9D0048A4  93838075   LBU V1, -32651(GP)
9D0048A8  00603021   ADDU A2, V1, ZERO
9D0048AC  93828074   LBU V0, -32652(GP)
9D0048B0  00402021   ADDU A0, V0, ZERO
9D0048B4  8FC50028   LW A1, 40(S8)
9D0048B8  00A42021   ADDU A0, A1, A0
9D0048BC  80850000   LB A1, 0(A0)
9D0048C0  278481CC   ADDIU A0, GP, -32308
9D0048C4  00C42021   ADDU A0, A2, A0
9D0048C8  A0850000   SB A1, 0(A0)
9D0048CC  24630001   ADDIU V1, V1, 1
9D0048D0  306300FF   ANDI V1, V1, 255
9D0048D4  A3838075   SB V1, -32651(GP)
9D0048D8  24420001   ADDIU V0, V0, 1
9D0048DC  304200FF   ANDI V0, V0, 255
9D0048E0  A3828074   SB V0, -32652(GP)
130:                             }
131:                             if((cBuff[uBuffIndex] > 47) && (cBuff[uBuffIndex] <= 57))
9D0048E4  93828074   LBU V0, -32652(GP)
9D0048E8  8FC30028   LW V1, 40(S8)
9D0048EC  00621021   ADDU V0, V1, V0
9D0048F0  80420000   LB V0, 0(V0)
9D0048F4  28420030   SLTI V0, V0, 48
9D0048F8  14400038   BNE V0, ZERO, 0x9D0049DC
9D0048FC  00000000   NOP
9D004900  93828074   LBU V0, -32652(GP)
9D004904  8FC30028   LW V1, 40(S8)
9D004908  00621021   ADDU V0, V1, V0
9D00490C  80420000   LB V0, 0(V0)
9D004910  2842003A   SLTI V0, V0, 58
9D004914  10400031   BEQ V0, ZERO, 0x9D0049DC
9D004918  00000000   NOP
132:                             {
133:                                 while(cBuff[uBuffIndex] > 47 && cBuff[uBuffIndex] <= 57)//Get everything in buffer
9D00491C  0B401260   J 0x9D004980
9D004920  00000000   NOP
9D004980  93828074   LBU V0, -32652(GP)
9D004984  8FC30028   LW V1, 40(S8)
9D004988  00621021   ADDU V0, V1, V0
9D00498C  80420000   LB V0, 0(V0)
9D004990  28420030   SLTI V0, V0, 48
9D004994  14400008   BNE V0, ZERO, 0x9D0049B8
9D004998  00000000   NOP
9D00499C  93828074   LBU V0, -32652(GP)
9D0049A0  8FC30028   LW V1, 40(S8)
9D0049A4  00621021   ADDU V0, V1, V0
9D0049A8  80420000   LB V0, 0(V0)
9D0049AC  2842003A   SLTI V0, V0, 58
9D0049B0  1440FFDC   BNE V0, ZERO, 0x9D004924
9D0049B4  00000000   NOP
134:                                 {
135:                                     notZeroFlag = 1;
9D004924  24020001   ADDIU V0, ZERO, 1
9D004928  A3828077   SB V0, -32649(GP)
136:                                     alphaBuff[aBufferIndex + 1] = 0x00;
9D00492C  93828075   LBU V0, -32651(GP)
9D004930  24430001   ADDIU V1, V0, 1
9D004934  278281CC   ADDIU V0, GP, -32308
9D004938  00621021   ADDU V0, V1, V0
9D00493C  A0400000   SB ZERO, 0(V0)
137:                                     alphaBuff[aBufferIndex++]=cBuff[uBuffIndex++];
9D004940  93838075   LBU V1, -32651(GP)
9D004944  00603021   ADDU A2, V1, ZERO
9D004948  93828074   LBU V0, -32652(GP)
9D00494C  00402021   ADDU A0, V0, ZERO
9D004950  8FC50028   LW A1, 40(S8)
9D004954  00A42021   ADDU A0, A1, A0
9D004958  80850000   LB A1, 0(A0)
9D00495C  278481CC   ADDIU A0, GP, -32308
9D004960  00C42021   ADDU A0, A2, A0
9D004964  A0850000   SB A1, 0(A0)
9D004968  24630001   ADDIU V1, V1, 1
9D00496C  306300FF   ANDI V1, V1, 255
9D004970  A3838075   SB V1, -32651(GP)
9D004974  24420001   ADDIU V0, V0, 1
9D004978  304200FF   ANDI V0, V0, 255
9D00497C  A3828074   SB V0, -32652(GP)
138:                                 }
139:                                 if(cBuff[uBuffIndex] == 0x00)return cBuff;
9D0049B8  93828074   LBU V0, -32652(GP)
9D0049BC  8FC30028   LW V1, 40(S8)
9D0049C0  00621021   ADDU V0, V1, V0
9D0049C4  80420000   LB V0, 0(V0)
9D0049C8  14400004   BNE V0, ZERO, 0x9D0049DC
9D0049CC  00000000   NOP
9D0049D0  8FC20028   LW V0, 40(S8)
9D0049D4  0B401700   J 0x9D005C00
9D0049D8  00000000   NOP
140:                             }
141:                             if(cBuff[uBuffIndex] == 0x0D)//Input complete, process string
9D0049DC  93828074   LBU V0, -32652(GP)
9D0049E0  8FC30028   LW V1, 40(S8)
9D0049E4  00621021   ADDU V0, V1, V0
9D0049E8  80430000   LB V1, 0(V0)
9D0049EC  2402000D   ADDIU V0, ZERO, 13
9D0049F0  1462002E   BNE V1, V0, 0x9D004AAC
9D0049F4  00000000   NOP
142:                             {
143:                                 aBufferIndex = 0; //Reset index
9D0049F8  A3808075   SB ZERO, -32651(GP)
144:                                 //if(tempInt != NULL) (*tempInt)(int);
145:                                 cBuff[0] = 1; //Being non zero supresses menu
9D0049FC  8FC20028   LW V0, 40(S8)
9D004A00  24030001   ADDIU V1, ZERO, 1
9D004A04  A0430000   SB V1, 0(V0)
146:                                 tempInt = atoi(alphaBuff);//Check bounds
9D004A08  278481CC   ADDIU A0, GP, -32308
9D004A0C  0F406558   JAL atoi
9D004A10  00000000   NOP
9D004A14  AF828080   SW V0, -32640(GP)
147:                                 if((tempInt == 0)&& notZeroFlag)
9D004A18  8F828080   LW V0, -32640(GP)
9D004A1C  14400014   BNE V0, ZERO, 0x9D004A70
9D004A20  00000000   NOP
9D004A24  83828077   LB V0, -32649(GP)
9D004A28  10400011   BEQ V0, ZERO, 0x9D004A70
9D004A2C  00000000   NOP
148:                                 {
149:                                   cBuff[0] = -1;
9D004A30  8FC20028   LW V0, 40(S8)
9D004A34  2403FFFF   ADDIU V1, ZERO, -1
9D004A38  A0430000   SB V1, 0(V0)
150:                                   sprintf(cBuff,"\x1B[1D\x1B[K Number to large or too small");
9D004A3C  8FC40028   LW A0, 40(S8)
9D004A40  3C029D01   LUI V0, -25343
9D004A44  24457D48   ADDIU A1, V0, 32072
9D004A48  24060025   ADDIU A2, ZERO, 37
9D004A4C  0F405AA3   JAL 0x9D016A8C
9D004A50  00000000   NOP
151:                                   return IntFunctionPtr(cBuff, -1); //Display menu which shows bounds
9D004A54  8F8281B4   LW V0, -32332(GP)
9D004A58  8FC40028   LW A0, 40(S8)
9D004A5C  2405FFFF   ADDIU A1, ZERO, -1
9D004A60  0040F809   JALR V0
9D004A64  00000000   NOP
9D004A68  0B401700   J 0x9D005C00
9D004A6C  00000000   NOP
152:                                 }
153:                                 IntFunctionPtr(cBuff, tempInt);//atoi(alphaBuff));
9D004A70  8F8281B4   LW V0, -32332(GP)
9D004A74  8F838080   LW V1, -32640(GP)
9D004A78  8FC40028   LW A0, 40(S8)
9D004A7C  00602821   ADDU A1, V1, ZERO
9D004A80  0040F809   JALR V0
9D004A84  00000000   NOP
154:                                 MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D004A88  24020002   ADDIU V0, ZERO, 2
9D004A8C  AF828070   SW V0, -32656(GP)
155:                                 return CurrentMenuPtr(cBuff, -1);
9D004A90  8F8281E4   LW V0, -32284(GP)
9D004A94  8FC40028   LW A0, 40(S8)
9D004A98  2405FFFF   ADDIU A1, ZERO, -1
9D004A9C  0040F809   JALR V0
9D004AA0  00000000   NOP
9D004AA4  0B401700   J 0x9D005C00
9D004AA8  00000000   NOP
156:                 
157:                             }
158:                             if(cBuff[uBuffIndex] == 0x08)//if there is a back space erase last number
9D004AAC  93828074   LBU V0, -32652(GP)
9D004AB0  8FC30028   LW V1, 40(S8)
9D004AB4  00621021   ADDU V0, V1, V0
9D004AB8  80430000   LB V1, 0(V0)
9D004ABC  24020008   ADDIU V0, ZERO, 8
9D004AC0  14620013   BNE V1, V0, 0x9D004B10
9D004AC4  00000000   NOP
159:                             {
160:                                 alphaBuff[--aBufferIndex] = 0x00; // erase last number
9D004AC8  93828075   LBU V0, -32651(GP)
9D004ACC  2442FFFF   ADDIU V0, V0, -1
9D004AD0  304200FF   ANDI V0, V0, 255
9D004AD4  A3828075   SB V0, -32651(GP)
9D004AD8  93828075   LBU V0, -32651(GP)
9D004ADC  00401821   ADDU V1, V0, ZERO
9D004AE0  278281CC   ADDIU V0, GP, -32308
9D004AE4  00621021   ADDU V0, V1, V0
9D004AE8  A0400000   SB ZERO, 0(V0)
161:                                 sprintf(cBuff,"\x1B[1D\x1B[K");
9D004AEC  8FC40028   LW A0, 40(S8)
9D004AF0  3C029D01   LUI V0, -25343
9D004AF4  24457D70   ADDIU A1, V0, 32112
9D004AF8  24060008   ADDIU A2, ZERO, 8
9D004AFC  0F405AA3   JAL 0x9D016A8C
9D004B00  00000000   NOP
162:                                 return cBuff;
9D004B04  8FC20028   LW V0, 40(S8)
9D004B08  0B401700   J 0x9D005C00
9D004B0C  00000000   NOP
163:                             }
164:                             uBuffIndex++;
9D004B10  93828074   LBU V0, -32652(GP)
9D004B14  24420001   ADDIU V0, V0, 1
9D004B18  304200FF   ANDI V0, V0, 255
9D004B1C  A3828074   SB V0, -32652(GP)
9D004B20  0B4012CB   J 0x9D004B2C
9D004B24  00000000   NOP
165:                         }
166:                         uBuffIndex = 0;
9D004B44  A3808074   SB ZERO, -32652(GP)
167:                         cBuff[0] = 0x00;
9D004B48  8FC20028   LW V0, 40(S8)
9D004B4C  A0400000   SB ZERO, 0(V0)
168:                         return cBuff;
9D004B50  8FC20028   LW V0, 40(S8)
9D004B54  0B401700   J 0x9D005C00
9D004B58  00000000   NOP
169:                     }
170:                     if(MENU_ACTION == INPUT_UINT)
9D004B5C  8F838070   LW V1, -32656(GP)
9D004B60  24020004   ADDIU V0, ZERO, 4
9D004B64  146200BF   BNE V1, V0, 0x9D004E64
9D004B68  00000000   NOP
171:                     {
172:                         if(uIntFunctionPtr == NULL )//Be sure your pointing at something
9D004B6C  8F8281DC   LW V0, -32292(GP)
9D004B70  14400013   BNE V0, ZERO, 0x9D004BC0
9D004B74  00000000   NOP
173:                         {
174:                             sprintf(cBuff,"Null Pointer Error \r\n ");
9D004B78  8FC40028   LW A0, 40(S8)
9D004B7C  3C029D01   LUI V0, -25343
9D004B80  24457D30   ADDIU A1, V0, 32048
9D004B84  24060017   ADDIU A2, ZERO, 23
9D004B88  0F405AA3   JAL 0x9D016A8C
9D004B8C  00000000   NOP
175:                             CurrentMenuPtr(&cBuff[23],-1);//Re Run last menu;
9D004B90  8F8281E4   LW V0, -32284(GP)
9D004B94  8FC30028   LW V1, 40(S8)
9D004B98  24630017   ADDIU V1, V1, 23
9D004B9C  00602021   ADDU A0, V1, ZERO
9D004BA0  2405FFFF   ADDIU A1, ZERO, -1
9D004BA4  0040F809   JALR V0
9D004BA8  00000000   NOP
176:                             MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D004BAC  24020002   ADDIU V0, ZERO, 2
9D004BB0  AF828070   SW V0, -32656(GP)
177:                             return cBuff;
9D004BB4  8FC20028   LW V0, 40(S8)
9D004BB8  0B401700   J 0x9D005C00
9D004BBC  00000000   NOP
178:                         }
179:                         if(cBuff[0] == 0x00) return uIntFunctionPtr(cBuff, 0); // RunMenu
9D004BC0  8FC20028   LW V0, 40(S8)
9D004BC4  80420000   LB V0, 0(V0)
9D004BC8  14400099   BNE V0, ZERO, 0x9D004E30
9D004BCC  00000000   NOP
9D004BD0  8F8281DC   LW V0, -32292(GP)
9D004BD4  8FC40028   LW A0, 40(S8)
9D004BD8  00002821   ADDU A1, ZERO, ZERO
9D004BDC  0040F809   JALR V0
9D004BE0  00000000   NOP
9D004BE4  0B401700   J 0x9D005C00
9D004BE8  00000000   NOP
180:                         while(cBuff[uBuffIndex] != 0x00)
9D004E30  00000000   NOP
9D004E34  93828074   LBU V0, -32652(GP)
9D004E38  8FC30028   LW V1, 40(S8)
9D004E3C  00621021   ADDU V0, V1, V0
9D004E40  80420000   LB V0, 0(V0)
9D004E44  1440FF69   BNE V0, ZERO, 0x9D004BEC
9D004E48  00000000   NOP
181:                         {
182:                             // bound input to numbers.
183:                             if((cBuff[uBuffIndex] > 47) && (cBuff[uBuffIndex] <= 57))// if input is a number
9D004BEC  93828074   LBU V0, -32652(GP)
9D004BF0  8FC30028   LW V1, 40(S8)
9D004BF4  00621021   ADDU V0, V1, V0
9D004BF8  80420000   LB V0, 0(V0)
9D004BFC  28420030   SLTI V0, V0, 48
9D004C00  14400038   BNE V0, ZERO, 0x9D004CE4
9D004C04  00000000   NOP
9D004C08  93828074   LBU V0, -32652(GP)
9D004C0C  8FC30028   LW V1, 40(S8)
9D004C10  00621021   ADDU V0, V1, V0
9D004C14  80420000   LB V0, 0(V0)
9D004C18  2842003A   SLTI V0, V0, 58
9D004C1C  10400031   BEQ V0, ZERO, 0x9D004CE4
9D004C20  00000000   NOP
184:                             {
185:                                 while(cBuff[uBuffIndex] > 47 && cBuff[uBuffIndex] <= 57)//Get everything in buffer
9D004C24  0B401322   J 0x9D004C88
9D004C28  00000000   NOP
9D004C88  93828074   LBU V0, -32652(GP)
9D004C8C  8FC30028   LW V1, 40(S8)
9D004C90  00621021   ADDU V0, V1, V0
9D004C94  80420000   LB V0, 0(V0)
9D004C98  28420030   SLTI V0, V0, 48
9D004C9C  14400008   BNE V0, ZERO, 0x9D004CC0
9D004CA0  00000000   NOP
9D004CA4  93828074   LBU V0, -32652(GP)
9D004CA8  8FC30028   LW V1, 40(S8)
9D004CAC  00621021   ADDU V0, V1, V0
9D004CB0  80420000   LB V0, 0(V0)
9D004CB4  2842003A   SLTI V0, V0, 58
9D004CB8  1440FFDC   BNE V0, ZERO, 0x9D004C2C
9D004CBC  00000000   NOP
186:                                 {
187:                                     notZeroFlag = 1;
9D004C2C  24020001   ADDIU V0, ZERO, 1
9D004C30  A3828077   SB V0, -32649(GP)
188:                                     alphaBuff[aBufferIndex + 1] = 0x00;
9D004C34  93828075   LBU V0, -32651(GP)
9D004C38  24430001   ADDIU V1, V0, 1
9D004C3C  278281CC   ADDIU V0, GP, -32308
9D004C40  00621021   ADDU V0, V1, V0
9D004C44  A0400000   SB ZERO, 0(V0)
189:                                     alphaBuff[aBufferIndex++]=cBuff[uBuffIndex++];
9D004C48  93838075   LBU V1, -32651(GP)
9D004C4C  00603021   ADDU A2, V1, ZERO
9D004C50  93828074   LBU V0, -32652(GP)
9D004C54  00402021   ADDU A0, V0, ZERO
9D004C58  8FC50028   LW A1, 40(S8)
9D004C5C  00A42021   ADDU A0, A1, A0
9D004C60  80850000   LB A1, 0(A0)
9D004C64  278481CC   ADDIU A0, GP, -32308
9D004C68  00C42021   ADDU A0, A2, A0
9D004C6C  A0850000   SB A1, 0(A0)
9D004C70  24630001   ADDIU V1, V1, 1
9D004C74  306300FF   ANDI V1, V1, 255
9D004C78  A3838075   SB V1, -32651(GP)
9D004C7C  24420001   ADDIU V0, V0, 1
9D004C80  304200FF   ANDI V0, V0, 255
9D004C84  A3828074   SB V0, -32652(GP)
190:                                 }
191:                                 if(cBuff[uBuffIndex] == 0x00)return cBuff;
9D004CC0  93828074   LBU V0, -32652(GP)
9D004CC4  8FC30028   LW V1, 40(S8)
9D004CC8  00621021   ADDU V0, V1, V0
9D004CCC  80420000   LB V0, 0(V0)
9D004CD0  14400004   BNE V0, ZERO, 0x9D004CE4
9D004CD4  00000000   NOP
9D004CD8  8FC20028   LW V0, 40(S8)
9D004CDC  0B401700   J 0x9D005C00
9D004CE0  00000000   NOP
192:                             }
193:                             if(cBuff[uBuffIndex] == 0x0D)//Input complete, process string
9D004CE4  93828074   LBU V0, -32652(GP)
9D004CE8  8FC30028   LW V1, 40(S8)
9D004CEC  00621021   ADDU V0, V1, V0
9D004CF0  80430000   LB V1, 0(V0)
9D004CF4  2402000D   ADDIU V0, ZERO, 13
9D004CF8  1462002E   BNE V1, V0, 0x9D004DB4
9D004CFC  00000000   NOP
194:                             {
195:                                 aBufferIndex = 0; //Reset index
9D004D00  A3808075   SB ZERO, -32651(GP)
196:                                 //if(tempInt != NULL) (*tempInt)(int);
197:                                 cBuff[0] = 1; //Being non zero supresses menu
9D004D04  8FC20028   LW V0, 40(S8)
9D004D08  24030001   ADDIU V1, ZERO, 1
9D004D0C  A0430000   SB V1, 0(V0)
198:                                 tempInt = atol(alphaBuff);//Check bounds
9D004D10  278481CC   ADDIU A0, GP, -32308
9D004D14  0F406560   JAL atol
9D004D18  00000000   NOP
9D004D1C  AF828080   SW V0, -32640(GP)
199:                                 if((tempInt == 0) && notZeroFlag)
9D004D20  8F828080   LW V0, -32640(GP)
9D004D24  14400014   BNE V0, ZERO, 0x9D004D78
9D004D28  00000000   NOP
9D004D2C  83828077   LB V0, -32649(GP)
9D004D30  10400011   BEQ V0, ZERO, 0x9D004D78
9D004D34  00000000   NOP
200:                                 {
201:                                   cBuff[0] = -1;
9D004D38  8FC20028   LW V0, 40(S8)
9D004D3C  2403FFFF   ADDIU V1, ZERO, -1
9D004D40  A0430000   SB V1, 0(V0)
202:                                   sprintf(cBuff,"\x1B[1D\x1B[K Number to large or too small");
9D004D44  8FC40028   LW A0, 40(S8)
9D004D48  3C029D01   LUI V0, -25343
9D004D4C  24457D48   ADDIU A1, V0, 32072
9D004D50  24060025   ADDIU A2, ZERO, 37
9D004D54  0F405AA3   JAL 0x9D016A8C
9D004D58  00000000   NOP
203:                                   return uIntFunctionPtr(cBuff, -1); //Display menu which shows bounds
9D004D5C  8F8281DC   LW V0, -32292(GP)
9D004D60  8FC40028   LW A0, 40(S8)
9D004D64  2405FFFF   ADDIU A1, ZERO, -1
9D004D68  0040F809   JALR V0
9D004D6C  00000000   NOP
9D004D70  0B401700   J 0x9D005C00
9D004D74  00000000   NOP
204:                                 }
205:                                 uIntFunctionPtr(cBuff,tempInt);//atoi(alphaBuff));
9D004D78  8F8281DC   LW V0, -32292(GP)
9D004D7C  8F838080   LW V1, -32640(GP)
9D004D80  8FC40028   LW A0, 40(S8)
9D004D84  00602821   ADDU A1, V1, ZERO
9D004D88  0040F809   JALR V0
9D004D8C  00000000   NOP
206:                                 MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D004D90  24020002   ADDIU V0, ZERO, 2
9D004D94  AF828070   SW V0, -32656(GP)
207:                                 return CurrentMenuPtr(cBuff, -1);
9D004D98  8F8281E4   LW V0, -32284(GP)
9D004D9C  8FC40028   LW A0, 40(S8)
9D004DA0  2405FFFF   ADDIU A1, ZERO, -1
9D004DA4  0040F809   JALR V0
9D004DA8  00000000   NOP
9D004DAC  0B401700   J 0x9D005C00
9D004DB0  00000000   NOP
208:                             }
209:                             if(cBuff[uBuffIndex] == 0x08)//if there is a back space erase last number
9D004DB4  93828074   LBU V0, -32652(GP)
9D004DB8  8FC30028   LW V1, 40(S8)
9D004DBC  00621021   ADDU V0, V1, V0
9D004DC0  80430000   LB V1, 0(V0)
9D004DC4  24020008   ADDIU V0, ZERO, 8
9D004DC8  14620013   BNE V1, V0, 0x9D004E18
9D004DCC  00000000   NOP
210:                             {
211:                                 alphaBuff[--aBufferIndex] = 0x00; // erase last number
9D004DD0  93828075   LBU V0, -32651(GP)
9D004DD4  2442FFFF   ADDIU V0, V0, -1
9D004DD8  304200FF   ANDI V0, V0, 255
9D004DDC  A3828075   SB V0, -32651(GP)
9D004DE0  93828075   LBU V0, -32651(GP)
9D004DE4  00401821   ADDU V1, V0, ZERO
9D004DE8  278281CC   ADDIU V0, GP, -32308
9D004DEC  00621021   ADDU V0, V1, V0
9D004DF0  A0400000   SB ZERO, 0(V0)
212:                                 sprintf(cBuff,"\x1B[1D\x1B[K");
9D004DF4  8FC40028   LW A0, 40(S8)
9D004DF8  3C029D01   LUI V0, -25343
9D004DFC  24457D70   ADDIU A1, V0, 32112
9D004E00  24060008   ADDIU A2, ZERO, 8
9D004E04  0F405AA3   JAL 0x9D016A8C
9D004E08  00000000   NOP
213:                                 return cBuff;
9D004E0C  8FC20028   LW V0, 40(S8)
9D004E10  0B401700   J 0x9D005C00
9D004E14  00000000   NOP
214:                             }
215:                             uBuffIndex++;
9D004E18  93828074   LBU V0, -32652(GP)
9D004E1C  24420001   ADDIU V0, V0, 1
9D004E20  304200FF   ANDI V0, V0, 255
9D004E24  A3828074   SB V0, -32652(GP)
9D004E28  0B40138D   J 0x9D004E34
9D004E2C  00000000   NOP
216:                         }
217:                         uBuffIndex = 0;
9D004E4C  A3808074   SB ZERO, -32652(GP)
218:                         cBuff[0] = 0x00;
9D004E50  8FC20028   LW V0, 40(S8)
9D004E54  A0400000   SB ZERO, 0(V0)
219:                         return cBuff;
9D004E58  8FC20028   LW V0, 40(S8)
9D004E5C  0B401700   J 0x9D005C00
9D004E60  00000000   NOP
220:                     }
221:                 //TODO : finish double input
222:                     if(MENU_ACTION == INPUT_LONG)
9D004E64  8F838070   LW V1, -32656(GP)
9D004E68  24020006   ADDIU V0, ZERO, 6
9D004E6C  146200FD   BNE V1, V0, 0x9D005264
9D004E70  00000000   NOP
223:                     {
224:                          if(LongFunctionPtr == NULL )//Be sure your pointing at something
9D004E74  8F8281D8   LW V0, -32296(GP)
9D004E78  14400013   BNE V0, ZERO, 0x9D004EC8
9D004E7C  00000000   NOP
225:                         {
226:                             sprintf(cBuff,"Null Pointer Error \r\n ");
9D004E80  8FC40028   LW A0, 40(S8)
9D004E84  3C029D01   LUI V0, -25343
9D004E88  24457D30   ADDIU A1, V0, 32048
9D004E8C  24060017   ADDIU A2, ZERO, 23
9D004E90  0F405AA3   JAL 0x9D016A8C
9D004E94  00000000   NOP
227:                             CurrentMenuPtr(&cBuff[23],-1);//Re Run last menu;
9D004E98  8F8281E4   LW V0, -32284(GP)
9D004E9C  8FC30028   LW V1, 40(S8)
9D004EA0  24630017   ADDIU V1, V1, 23
9D004EA4  00602021   ADDU A0, V1, ZERO
9D004EA8  2405FFFF   ADDIU A1, ZERO, -1
9D004EAC  0040F809   JALR V0
9D004EB0  00000000   NOP
228:                             MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D004EB4  24020002   ADDIU V0, ZERO, 2
9D004EB8  AF828070   SW V0, -32656(GP)
229:                             return cBuff;
9D004EBC  8FC20028   LW V0, 40(S8)
9D004EC0  0B401700   J 0x9D005C00
9D004EC4  00000000   NOP
230:                         }
231:                         if(cBuff[0] == 0x00) return LongFunctionPtr(cBuff, 0); // RunMenu
9D004EC8  8FC20028   LW V0, 40(S8)
9D004ECC  80420000   LB V0, 0(V0)
9D004ED0  144000D7   BNE V0, ZERO, 0x9D005230
9D004ED4  00000000   NOP
9D004ED8  8F8281D8   LW V0, -32296(GP)
9D004EDC  8FC40028   LW A0, 40(S8)
9D004EE0  00002821   ADDU A1, ZERO, ZERO
9D004EE4  0040F809   JALR V0
9D004EE8  00000000   NOP
9D004EEC  0B401700   J 0x9D005C00
9D004EF0  00000000   NOP
232:                         while(cBuff[uBuffIndex] != 0x00)
9D005230  00000000   NOP
9D005234  93828074   LBU V0, -32652(GP)
9D005238  8FC30028   LW V1, 40(S8)
9D00523C  00621021   ADDU V0, V1, V0
9D005240  80420000   LB V0, 0(V0)
9D005244  1440FF2B   BNE V0, ZERO, 0x9D004EF4
9D005248  00000000   NOP
233:                         {
234:                             // bound input to numbers and negative symbol. Exclude '/'
235:                             if((cBuff[uBuffIndex] == 45)&&(negSymbolExists != 0)) //capture negative symbol
9D004EF4  93828074   LBU V0, -32652(GP)
9D004EF8  8FC30028   LW V1, 40(S8)
9D004EFC  00621021   ADDU V0, V1, V0
9D004F00  80430000   LB V1, 0(V0)
9D004F04  2402002D   ADDIU V0, ZERO, 45
9D004F08  14620019   BNE V1, V0, 0x9D004F70
9D004F0C  00000000   NOP
9D004F10  83828078   LB V0, -32648(GP)
9D004F14  10400016   BEQ V0, ZERO, 0x9D004F70
9D004F18  00000000   NOP
236:                             {
237:                                 if(decimalExists == 0) // Cannot but neg symbor behind decimal
9D004F1C  83828079   LB V0, -32647(GP)
9D004F20  14400013   BNE V0, ZERO, 0x9D004F70
9D004F24  00000000   NOP
238:                                 {
239:                                     negSymbolExists = 1; // user only gets one negative symbol
9D004F28  24020001   ADDIU V0, ZERO, 1
9D004F2C  A3828078   SB V0, -32648(GP)
240:                                     alphaBuff[aBufferIndex++] = cBuff[uBuffIndex++];
9D004F30  93838075   LBU V1, -32651(GP)
9D004F34  00603021   ADDU A2, V1, ZERO
9D004F38  93828074   LBU V0, -32652(GP)
9D004F3C  00402021   ADDU A0, V0, ZERO
9D004F40  8FC50028   LW A1, 40(S8)
9D004F44  00A42021   ADDU A0, A1, A0
9D004F48  80850000   LB A1, 0(A0)
9D004F4C  278481CC   ADDIU A0, GP, -32308
9D004F50  00C42021   ADDU A0, A2, A0
9D004F54  A0850000   SB A1, 0(A0)
9D004F58  24630001   ADDIU V1, V1, 1
9D004F5C  306300FF   ANDI V1, V1, 255
9D004F60  A3838075   SB V1, -32651(GP)
9D004F64  24420001   ADDIU V0, V0, 1
9D004F68  304200FF   ANDI V0, V0, 255
9D004F6C  A3828074   SB V0, -32652(GP)
241:                                 }
242:                             }
243:                             if((cBuff[uBuffIndex] == 46)&&(decimalExists == 0))  //capture decimal
9D004F70  93828074   LBU V0, -32652(GP)
9D004F74  8FC30028   LW V1, 40(S8)
9D004F78  00621021   ADDU V0, V1, V0
9D004F7C  80430000   LB V1, 0(V0)
9D004F80  2402002E   ADDIU V0, ZERO, 46
9D004F84  14620016   BNE V1, V0, 0x9D004FE0
9D004F88  00000000   NOP
9D004F8C  83828079   LB V0, -32647(GP)
9D004F90  14400013   BNE V0, ZERO, 0x9D004FE0
9D004F94  00000000   NOP
244:                             {
245:                                 decimalExists = 1; // no more decimal places
9D004F98  24020001   ADDIU V0, ZERO, 1
9D004F9C  A3828079   SB V0, -32647(GP)
246:                                 alphaBuff[aBufferIndex++] = cBuff[uBuffIndex++];
9D004FA0  93838075   LBU V1, -32651(GP)
9D004FA4  00603021   ADDU A2, V1, ZERO
9D004FA8  93828074   LBU V0, -32652(GP)
9D004FAC  00402021   ADDU A0, V0, ZERO
9D004FB0  8FC50028   LW A1, 40(S8)
9D004FB4  00A42021   ADDU A0, A1, A0
9D004FB8  80850000   LB A1, 0(A0)
9D004FBC  278481CC   ADDIU A0, GP, -32308
9D004FC0  00C42021   ADDU A0, A2, A0
9D004FC4  A0850000   SB A1, 0(A0)
9D004FC8  24630001   ADDIU V1, V1, 1
9D004FCC  306300FF   ANDI V1, V1, 255
9D004FD0  A3838075   SB V1, -32651(GP)
9D004FD4  24420001   ADDIU V0, V0, 1
9D004FD8  304200FF   ANDI V0, V0, 255
9D004FDC  A3828074   SB V0, -32652(GP)
247:                             }
248:                             if((cBuff[uBuffIndex] > 47) && (cBuff[uBuffIndex] <= 57))// if input is a number
9D004FE0  93828074   LBU V0, -32652(GP)
9D004FE4  8FC30028   LW V1, 40(S8)
9D004FE8  00621021   ADDU V0, V1, V0
9D004FEC  80420000   LB V0, 0(V0)
9D004FF0  28420030   SLTI V0, V0, 48
9D004FF4  14400038   BNE V0, ZERO, 0x9D0050D8
9D004FF8  00000000   NOP
9D004FFC  93828074   LBU V0, -32652(GP)
9D005000  8FC30028   LW V1, 40(S8)
9D005004  00621021   ADDU V0, V1, V0
9D005008  80420000   LB V0, 0(V0)
9D00500C  2842003A   SLTI V0, V0, 58
9D005010  10400031   BEQ V0, ZERO, 0x9D0050D8
9D005014  00000000   NOP
249:                             {   //Just in case there's more than one number
250:                                 while(cBuff[uBuffIndex] > 47 && cBuff[uBuffIndex] <= 57)
9D005018  0B40141F   J 0x9D00507C
9D00501C  00000000   NOP
9D00507C  93828074   LBU V0, -32652(GP)
9D005080  8FC30028   LW V1, 40(S8)
9D005084  00621021   ADDU V0, V1, V0
9D005088  80420000   LB V0, 0(V0)
9D00508C  28420030   SLTI V0, V0, 48
9D005090  14400008   BNE V0, ZERO, 0x9D0050B4
9D005094  00000000   NOP
9D005098  93828074   LBU V0, -32652(GP)
9D00509C  8FC30028   LW V1, 40(S8)
9D0050A0  00621021   ADDU V0, V1, V0
9D0050A4  80420000   LB V0, 0(V0)
9D0050A8  2842003A   SLTI V0, V0, 58
9D0050AC  1440FFDC   BNE V0, ZERO, 0x9D005020
9D0050B0  00000000   NOP
251:                                 {
252:                                     notZeroFlag = 1;
9D005020  24020001   ADDIU V0, ZERO, 1
9D005024  A3828077   SB V0, -32649(GP)
253:                                     alphaBuff[aBufferIndex + 1] = 0x00;//Make sure alphaBuff is NULL terminated
9D005028  93828075   LBU V0, -32651(GP)
9D00502C  24430001   ADDIU V1, V0, 1
9D005030  278281CC   ADDIU V0, GP, -32308
9D005034  00621021   ADDU V0, V1, V0
9D005038  A0400000   SB ZERO, 0(V0)
254:                                     alphaBuff[aBufferIndex++]=cBuff[uBuffIndex++]; // capture and number
9D00503C  93838075   LBU V1, -32651(GP)
9D005040  00603021   ADDU A2, V1, ZERO
9D005044  93828074   LBU V0, -32652(GP)
9D005048  00402021   ADDU A0, V0, ZERO
9D00504C  8FC50028   LW A1, 40(S8)
9D005050  00A42021   ADDU A0, A1, A0
9D005054  80850000   LB A1, 0(A0)
9D005058  278481CC   ADDIU A0, GP, -32308
9D00505C  00C42021   ADDU A0, A2, A0
9D005060  A0850000   SB A1, 0(A0)
9D005064  24630001   ADDIU V1, V1, 1
9D005068  306300FF   ANDI V1, V1, 255
9D00506C  A3838075   SB V1, -32651(GP)
9D005070  24420001   ADDIU V0, V0, 1
9D005074  304200FF   ANDI V0, V0, 255
9D005078  A3828074   SB V0, -32652(GP)
255:                                 }
256:                                 if(cBuff[uBuffIndex] == 0x00)return cBuff; //Go back and wait for more
9D0050B4  93828074   LBU V0, -32652(GP)
9D0050B8  8FC30028   LW V1, 40(S8)
9D0050BC  00621021   ADDU V0, V1, V0
9D0050C0  80420000   LB V0, 0(V0)
9D0050C4  14400004   BNE V0, ZERO, 0x9D0050D8
9D0050C8  00000000   NOP
9D0050CC  8FC20028   LW V0, 40(S8)
9D0050D0  0B401700   J 0x9D005C00
9D0050D4  00000000   NOP
257:                             }
258:                             if(cBuff[uBuffIndex] == 0x0D)//Input complete, process string
9D0050D8  93828074   LBU V0, -32652(GP)
9D0050DC  8FC30028   LW V1, 40(S8)
9D0050E0  00621021   ADDU V0, V1, V0
9D0050E4  80430000   LB V1, 0(V0)
9D0050E8  2402000D   ADDIU V0, ZERO, 13
9D0050EC  14620031   BNE V1, V0, 0x9D0051B4
9D0050F0  00000000   NOP
259:                             {
260:                                 aBufferIndex = 0; //Reset index
9D0050F4  A3808075   SB ZERO, -32651(GP)
261:                                 //if(tempInt != NULL) (*tempInt)(int);
262:                                 cBuff[0] = 1; //Being non zero supresses menu
9D0050F8  8FC20028   LW V0, 40(S8)
9D0050FC  24030001   ADDIU V1, ZERO, 1
9D005100  A0430000   SB V1, 0(V0)
263:                                 tempLong = atol(alphaBuff);//Check bounds
9D005104  278481CC   ADDIU A0, GP, -32308
9D005108  0F406560   JAL atol
9D00510C  00000000   NOP
9D005110  AF828084   SW V0, -32636(GP)
264:                                 if((tempInt == 0)&& notZeroFlag)
9D005114  8F828080   LW V0, -32640(GP)
9D005118  14400014   BNE V0, ZERO, 0x9D00516C
9D00511C  00000000   NOP
9D005120  83828077   LB V0, -32649(GP)
9D005124  10400011   BEQ V0, ZERO, 0x9D00516C
9D005128  00000000   NOP
265:                                 {
266:                                   cBuff[0] = -1;
9D00512C  8FC20028   LW V0, 40(S8)
9D005130  2403FFFF   ADDIU V1, ZERO, -1
9D005134  A0430000   SB V1, 0(V0)
267:                                   sprintf(cBuff,"\x1B[1D\x1B[K Number to large or too small");
9D005138  8FC40028   LW A0, 40(S8)
9D00513C  3C029D01   LUI V0, -25343
9D005140  24457D48   ADDIU A1, V0, 32072
9D005144  24060025   ADDIU A2, ZERO, 37
9D005148  0F405AA3   JAL 0x9D016A8C
9D00514C  00000000   NOP
268:                                   return uIntFunctionPtr(cBuff, -1); //Display menu which shows bounds
9D005150  8F8281DC   LW V0, -32292(GP)
9D005154  8FC40028   LW A0, 40(S8)
9D005158  2405FFFF   ADDIU A1, ZERO, -1
9D00515C  0040F809   JALR V0
9D005160  00000000   NOP
9D005164  0B401700   J 0x9D005C00
9D005168  00000000   NOP
269:                                 }
270:                                 LongFunctionPtr(cBuff,tempLong);//atoi(alphaBuff));
9D00516C  8F9081D8   LW S0, -32296(GP)
9D005170  8F828084   LW V0, -32636(GP)
9D005174  00402021   ADDU A0, V0, ZERO
9D005178  0F4039F4   JAL litofp
9D00517C  00000000   NOP
9D005180  8FC40028   LW A0, 40(S8)
9D005184  00402821   ADDU A1, V0, ZERO
9D005188  0200F809   JALR S0
9D00518C  00000000   NOP
271:                                 MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D005190  24020002   ADDIU V0, ZERO, 2
9D005194  AF828070   SW V0, -32656(GP)
272:                                 return CurrentMenuPtr(cBuff, -1);
9D005198  8F8281E4   LW V0, -32284(GP)
9D00519C  8FC40028   LW A0, 40(S8)
9D0051A0  2405FFFF   ADDIU A1, ZERO, -1
9D0051A4  0040F809   JALR V0
9D0051A8  00000000   NOP
9D0051AC  0B401700   J 0x9D005C00
9D0051B0  00000000   NOP
273:                             }
274:                             if(cBuff[uBuffIndex] == 0x08)//if there is a back space erase last number
9D0051B4  93828074   LBU V0, -32652(GP)
9D0051B8  8FC30028   LW V1, 40(S8)
9D0051BC  00621021   ADDU V0, V1, V0
9D0051C0  80430000   LB V1, 0(V0)
9D0051C4  24020008   ADDIU V0, ZERO, 8
9D0051C8  14620013   BNE V1, V0, 0x9D005218
9D0051CC  00000000   NOP
275:                             {
276:                                 alphaBuff[--aBufferIndex] = 0x00; // erase last number
9D0051D0  93828075   LBU V0, -32651(GP)
9D0051D4  2442FFFF   ADDIU V0, V0, -1
9D0051D8  304200FF   ANDI V0, V0, 255
9D0051DC  A3828075   SB V0, -32651(GP)
9D0051E0  93828075   LBU V0, -32651(GP)
9D0051E4  00401821   ADDU V1, V0, ZERO
9D0051E8  278281CC   ADDIU V0, GP, -32308
9D0051EC  00621021   ADDU V0, V1, V0
9D0051F0  A0400000   SB ZERO, 0(V0)
277:                                 sprintf(cBuff,"\x1B[1D\x1B[K");
9D0051F4  8FC40028   LW A0, 40(S8)
9D0051F8  3C029D01   LUI V0, -25343
9D0051FC  24457D70   ADDIU A1, V0, 32112
9D005200  24060008   ADDIU A2, ZERO, 8
9D005204  0F405AA3   JAL 0x9D016A8C
9D005208  00000000   NOP
278:                                 return cBuff;
9D00520C  8FC20028   LW V0, 40(S8)
9D005210  0B401700   J 0x9D005C00
9D005214  00000000   NOP
279:                             }
280:                             uBuffIndex++;
9D005218  93828074   LBU V0, -32652(GP)
9D00521C  24420001   ADDIU V0, V0, 1
9D005220  304200FF   ANDI V0, V0, 255
9D005224  A3828074   SB V0, -32652(GP)
9D005228  0B40148D   J 0x9D005234
9D00522C  00000000   NOP
281:                         }
282:                         uBuffIndex = 0;
9D00524C  A3808074   SB ZERO, -32652(GP)
283:                         cBuff[0] = 0x00;
9D005250  8FC20028   LW V0, 40(S8)
9D005254  A0400000   SB ZERO, 0(V0)
284:                         return cBuff;
9D005258  8FC20028   LW V0, 40(S8)
9D00525C  0B401700   J 0x9D005C00
9D005260  00000000   NOP
285:                     }
286:                     if(MENU_ACTION == INPUT_FLOAT)
9D005264  8F838070   LW V1, -32656(GP)
9D005268  24020005   ADDIU V0, ZERO, 5
9D00526C  14620100   BNE V1, V0, 0x9D005670
9D005270  00000000   NOP
287:                     {
288:                         if(FloatFunctionPtr == NULL )//Be sure your pointing at something
9D005274  8F8281C0   LW V0, -32320(GP)
9D005278  14400013   BNE V0, ZERO, 0x9D0052C8
9D00527C  00000000   NOP
289:                         {
290:                             sprintf(cBuff,"Null Pointer Error \r\n ");
9D005280  8FC40028   LW A0, 40(S8)
9D005284  3C029D01   LUI V0, -25343
9D005288  24457D30   ADDIU A1, V0, 32048
9D00528C  24060017   ADDIU A2, ZERO, 23
9D005290  0F405AA3   JAL 0x9D016A8C
9D005294  00000000   NOP
291:                             CurrentMenuPtr(&cBuff[23],-1);//Re Run last menu;
9D005298  8F8281E4   LW V0, -32284(GP)
9D00529C  8FC30028   LW V1, 40(S8)
9D0052A0  24630017   ADDIU V1, V1, 23
9D0052A4  00602021   ADDU A0, V1, ZERO
9D0052A8  2405FFFF   ADDIU A1, ZERO, -1
9D0052AC  0040F809   JALR V0
9D0052B0  00000000   NOP
292:                             MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D0052B4  24020002   ADDIU V0, ZERO, 2
9D0052B8  AF828070   SW V0, -32656(GP)
293:                             return cBuff;
9D0052BC  8FC20028   LW V0, 40(S8)
9D0052C0  0B401700   J 0x9D005C00
9D0052C4  00000000   NOP
294:                         }
295:                         if(cBuff[0] == 0x00) return FloatFunctionPtr(cBuff, 0); // RunMenu
9D0052C8  8FC20028   LW V0, 40(S8)
9D0052CC  80420000   LB V0, 0(V0)
9D0052D0  144000DA   BNE V0, ZERO, 0x9D00563C
9D0052D4  00000000   NOP
9D0052D8  8F8281C0   LW V0, -32320(GP)
9D0052DC  8FC40028   LW A0, 40(S8)
9D0052E0  00002821   ADDU A1, ZERO, ZERO
9D0052E4  0040F809   JALR V0
9D0052E8  00000000   NOP
9D0052EC  0B401700   J 0x9D005C00
9D0052F0  00000000   NOP
296:                         while(cBuff[uBuffIndex] != 0x00)
9D00563C  00000000   NOP
9D005640  93828074   LBU V0, -32652(GP)
9D005644  8FC30028   LW V1, 40(S8)
9D005648  00621021   ADDU V0, V1, V0
9D00564C  80420000   LB V0, 0(V0)
9D005650  1440FF28   BNE V0, ZERO, 0x9D0052F4
9D005654  00000000   NOP
297:                         {
298:                 //TODO 's: Handle atoxx's returning 0 on error
299:                             if((cBuff[uBuffIndex] >= 45) && (cBuff[uBuffIndex] <= 57))// if input is a  real number
9D0052F4  93828074   LBU V0, -32652(GP)
9D0052F8  8FC30028   LW V1, 40(S8)
9D0052FC  00621021   ADDU V0, V1, V0
9D005300  80420000   LB V0, 0(V0)
9D005304  2842002D   SLTI V0, V0, 45
9D005308  14400079   BNE V0, ZERO, 0x9D0054F0
9D00530C  00000000   NOP
9D005310  93828074   LBU V0, -32652(GP)
9D005314  8FC30028   LW V1, 40(S8)
9D005318  00621021   ADDU V0, V1, V0
9D00531C  80420000   LB V0, 0(V0)
9D005320  2842003A   SLTI V0, V0, 58
9D005324  10400072   BEQ V0, ZERO, 0x9D0054F0
9D005328  00000000   NOP
300:                             {
301:                                 if((cBuff[uBuffIndex] == 45)&&(negSymbolExists != 0)) //capture negative symbol
9D00532C  93828074   LBU V0, -32652(GP)
9D005330  8FC30028   LW V1, 40(S8)
9D005334  00621021   ADDU V0, V1, V0
9D005338  80430000   LB V1, 0(V0)
9D00533C  2402002D   ADDIU V0, ZERO, 45
9D005340  14620019   BNE V1, V0, 0x9D0053A8
9D005344  00000000   NOP
9D005348  83828078   LB V0, -32648(GP)
9D00534C  10400016   BEQ V0, ZERO, 0x9D0053A8
9D005350  00000000   NOP
302:                                 {
303:                                     if(decimalExists == 0) // Cannot but neg symbor behind decimal
9D005354  83828079   LB V0, -32647(GP)
9D005358  14400013   BNE V0, ZERO, 0x9D0053A8
9D00535C  00000000   NOP
304:                                     {
305:                                         negSymbolExists = 1; // user only gets one negative symbol
9D005360  24020001   ADDIU V0, ZERO, 1
9D005364  A3828078   SB V0, -32648(GP)
306:                                         alphaBuff[aBufferIndex++] = cBuff[uBuffIndex++];
9D005368  93838075   LBU V1, -32651(GP)
9D00536C  00603021   ADDU A2, V1, ZERO
9D005370  93828074   LBU V0, -32652(GP)
9D005374  00402021   ADDU A0, V0, ZERO
9D005378  8FC50028   LW A1, 40(S8)
9D00537C  00A42021   ADDU A0, A1, A0
9D005380  80850000   LB A1, 0(A0)
9D005384  278481CC   ADDIU A0, GP, -32308
9D005388  00C42021   ADDU A0, A2, A0
9D00538C  A0850000   SB A1, 0(A0)
9D005390  24630001   ADDIU V1, V1, 1
9D005394  306300FF   ANDI V1, V1, 255
9D005398  A3838075   SB V1, -32651(GP)
9D00539C  24420001   ADDIU V0, V0, 1
9D0053A0  304200FF   ANDI V0, V0, 255
9D0053A4  A3828074   SB V0, -32652(GP)
307:                                     }
308:                                 }
309:                                 if((cBuff[uBuffIndex] == 46)&&(decimalExists == 0))  //capture decimal
9D0053A8  93828074   LBU V0, -32652(GP)
9D0053AC  8FC30028   LW V1, 40(S8)
9D0053B0  00621021   ADDU V0, V1, V0
9D0053B4  80430000   LB V1, 0(V0)
9D0053B8  2402002E   ADDIU V0, ZERO, 46
9D0053BC  14620031   BNE V1, V0, 0x9D005484
9D0053C0  00000000   NOP
9D0053C4  83828079   LB V0, -32647(GP)
9D0053C8  14400031   BNE V0, ZERO, 0x9D005490
9D0053CC  00000000   NOP
310:                                 {
311:                                     decimalExists = 1; // no more decimal places
9D0053D0  24020001   ADDIU V0, ZERO, 1
9D0053D4  A3828079   SB V0, -32647(GP)
312:                                     alphaBuff[aBufferIndex++] = cBuff[uBuffIndex++];
9D0053D8  93838075   LBU V1, -32651(GP)
9D0053DC  00603021   ADDU A2, V1, ZERO
9D0053E0  93828074   LBU V0, -32652(GP)
9D0053E4  00402021   ADDU A0, V0, ZERO
9D0053E8  8FC50028   LW A1, 40(S8)
9D0053EC  00A42021   ADDU A0, A1, A0
9D0053F0  80850000   LB A1, 0(A0)
9D0053F4  278481CC   ADDIU A0, GP, -32308
9D0053F8  00C42021   ADDU A0, A2, A0
9D0053FC  A0850000   SB A1, 0(A0)
9D005400  24630001   ADDIU V1, V1, 1
9D005404  306300FF   ANDI V1, V1, 255
9D005408  A3838075   SB V1, -32651(GP)
9D00540C  24420001   ADDIU V0, V0, 1
9D005410  304200FF   ANDI V0, V0, 255
9D005414  A3828074   SB V0, -32652(GP)
313:                                 }
314:                 
315:                                 //Just in case there's more than one number
316:                                 while(cBuff[uBuffIndex] > 47 && cBuff[uBuffIndex] <= 57)
9D005418  0B401525   J 0x9D005494
9D00541C  00000000   NOP
9D005484  00000000   NOP
9D005488  0B401525   J 0x9D005494
9D00548C  00000000   NOP
9D005490  00000000   NOP
9D005494  93828074   LBU V0, -32652(GP)
9D005498  8FC30028   LW V1, 40(S8)
9D00549C  00621021   ADDU V0, V1, V0
9D0054A0  80420000   LB V0, 0(V0)
9D0054A4  28420030   SLTI V0, V0, 48
9D0054A8  14400008   BNE V0, ZERO, 0x9D0054CC
9D0054AC  00000000   NOP
9D0054B0  93828074   LBU V0, -32652(GP)
9D0054B4  8FC30028   LW V1, 40(S8)
9D0054B8  00621021   ADDU V0, V1, V0
9D0054BC  80420000   LB V0, 0(V0)
9D0054C0  2842003A   SLTI V0, V0, 58
9D0054C4  1440FFD6   BNE V0, ZERO, 0x9D005420
9D0054C8  00000000   NOP
317:                                 {
318:                                     notZeroFlag = 1;
9D005420  24020001   ADDIU V0, ZERO, 1
9D005424  A3828077   SB V0, -32649(GP)
319:                                     alphaBuff[aBufferIndex + 1] = 0x00;//Make sure alphaBuff is NULL terminated
9D005428  93828075   LBU V0, -32651(GP)
9D00542C  24430001   ADDIU V1, V0, 1
9D005430  278281CC   ADDIU V0, GP, -32308
9D005434  00621021   ADDU V0, V1, V0
9D005438  A0400000   SB ZERO, 0(V0)
320:                                     alphaBuff[aBufferIndex++]=cBuff[uBuffIndex++]; // capture and number
9D00543C  93838075   LBU V1, -32651(GP)
9D005440  00603021   ADDU A2, V1, ZERO
9D005444  93828074   LBU V0, -32652(GP)
9D005448  00402021   ADDU A0, V0, ZERO
9D00544C  8FC50028   LW A1, 40(S8)
9D005450  00A42021   ADDU A0, A1, A0
9D005454  80850000   LB A1, 0(A0)
9D005458  278481CC   ADDIU A0, GP, -32308
9D00545C  00C42021   ADDU A0, A2, A0
9D005460  A0850000   SB A1, 0(A0)
9D005464  24630001   ADDIU V1, V1, 1
9D005468  306300FF   ANDI V1, V1, 255
9D00546C  A3838075   SB V1, -32651(GP)
9D005470  24420001   ADDIU V0, V0, 1
9D005474  304200FF   ANDI V0, V0, 255
9D005478  A3828074   SB V0, -32652(GP)
9D00547C  0B401525   J 0x9D005494
9D005480  00000000   NOP
321:                                 }
322:                                 if(cBuff[uBuffIndex] == 0x00)return cBuff; //Go back and wait for more
9D0054CC  93828074   LBU V0, -32652(GP)
9D0054D0  8FC30028   LW V1, 40(S8)
9D0054D4  00621021   ADDU V0, V1, V0
9D0054D8  80420000   LB V0, 0(V0)
9D0054DC  14400004   BNE V0, ZERO, 0x9D0054F0
9D0054E0  00000000   NOP
9D0054E4  8FC20028   LW V0, 40(S8)
9D0054E8  0B401700   J 0x9D005C00
9D0054EC  00000000   NOP
323:                             }
324:                             if(cBuff[uBuffIndex] == 0x0D)//Input complete, process string
9D0054F0  93828074   LBU V0, -32652(GP)
9D0054F4  8FC30028   LW V1, 40(S8)
9D0054F8  00621021   ADDU V0, V1, V0
9D0054FC  80430000   LB V1, 0(V0)
9D005500  2402000D   ADDIU V0, ZERO, 13
9D005504  1462002E   BNE V1, V0, 0x9D0055C0
9D005508  00000000   NOP
325:                             {
326:                                 aBufferIndex = 0; //Reset index
9D00550C  A3808075   SB ZERO, -32651(GP)
327:                                 //if(tempInt != NULL) (*tempInt)(int);
328:                                 cBuff[0] = 1; //Being non zero supresses menu
9D005510  8FC20028   LW V0, 40(S8)
9D005514  24030001   ADDIU V1, ZERO, 1
9D005518  A0430000   SB V1, 0(V0)
329:                                 tempFloat = atof(alphaBuff);//Check bounds
9D00551C  278481CC   ADDIU A0, GP, -32308
9D005520  0F406550   JAL atof
9D005524  00000000   NOP
9D005528  AF82808C   SW V0, -32628(GP)
330:                                 if((tempInt == 0)&& notZeroFlag)
9D00552C  8F828080   LW V0, -32640(GP)
9D005530  14400014   BNE V0, ZERO, 0x9D005584
9D005534  00000000   NOP
9D005538  83828077   LB V0, -32649(GP)
9D00553C  10400011   BEQ V0, ZERO, 0x9D005584
9D005540  00000000   NOP
331:                                 {
332:                                   cBuff[0] = -1;
9D005544  8FC20028   LW V0, 40(S8)
9D005548  2403FFFF   ADDIU V1, ZERO, -1
9D00554C  A0430000   SB V1, 0(V0)
333:                                   sprintf(cBuff,"\x1B[1D\x1B[1K Number to large or too small");
9D005550  8FC40028   LW A0, 40(S8)
9D005554  3C029D01   LUI V0, -25343
9D005558  24457D78   ADDIU A1, V0, 32120
9D00555C  24060026   ADDIU A2, ZERO, 38
9D005560  0F405AA3   JAL 0x9D016A8C
9D005564  00000000   NOP
334:                                   return uIntFunctionPtr(cBuff, -1); //Display menu which shows bounds
9D005568  8F8281DC   LW V0, -32292(GP)
9D00556C  8FC40028   LW A0, 40(S8)
9D005570  2405FFFF   ADDIU A1, ZERO, -1
9D005574  0040F809   JALR V0
9D005578  00000000   NOP
9D00557C  0B401700   J 0x9D005C00
9D005580  00000000   NOP
335:                                 }
336:                                 FloatFunctionPtr(cBuff,tempFloat);//atoi(alphaBuff));
9D005584  8F8281C0   LW V0, -32320(GP)
9D005588  8F83808C   LW V1, -32628(GP)
9D00558C  8FC40028   LW A0, 40(S8)
9D005590  00602821   ADDU A1, V1, ZERO
9D005594  0040F809   JALR V0
9D005598  00000000   NOP
337:                                 MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D00559C  24020002   ADDIU V0, ZERO, 2
9D0055A0  AF828070   SW V0, -32656(GP)
338:                                 return CurrentMenuPtr(cBuff, -1);
9D0055A4  8F8281E4   LW V0, -32284(GP)
9D0055A8  8FC40028   LW A0, 40(S8)
9D0055AC  2405FFFF   ADDIU A1, ZERO, -1
9D0055B0  0040F809   JALR V0
9D0055B4  00000000   NOP
9D0055B8  0B401700   J 0x9D005C00
9D0055BC  00000000   NOP
339:                             }
340:                             if(cBuff[uBuffIndex] == 0x08)//if there is a back space erase last number
9D0055C0  93828074   LBU V0, -32652(GP)
9D0055C4  8FC30028   LW V1, 40(S8)
9D0055C8  00621021   ADDU V0, V1, V0
9D0055CC  80430000   LB V1, 0(V0)
9D0055D0  24020008   ADDIU V0, ZERO, 8
9D0055D4  14620013   BNE V1, V0, 0x9D005624
9D0055D8  00000000   NOP
341:                             {
342:                                 alphaBuff[--aBufferIndex] = 0x00; // erase last number
9D0055DC  93828075   LBU V0, -32651(GP)
9D0055E0  2442FFFF   ADDIU V0, V0, -1
9D0055E4  304200FF   ANDI V0, V0, 255
9D0055E8  A3828075   SB V0, -32651(GP)
9D0055EC  93828075   LBU V0, -32651(GP)
9D0055F0  00401821   ADDU V1, V0, ZERO
9D0055F4  278281CC   ADDIU V0, GP, -32308
9D0055F8  00621021   ADDU V0, V1, V0
9D0055FC  A0400000   SB ZERO, 0(V0)
343:                                 sprintf(cBuff,"\x1B[1D\x1B[K");
9D005600  8FC40028   LW A0, 40(S8)
9D005604  3C029D01   LUI V0, -25343
9D005608  24457D70   ADDIU A1, V0, 32112
9D00560C  24060008   ADDIU A2, ZERO, 8
9D005610  0F405AA3   JAL 0x9D016A8C
9D005614  00000000   NOP
344:                                 return cBuff;
9D005618  8FC20028   LW V0, 40(S8)
9D00561C  0B401700   J 0x9D005C00
9D005620  00000000   NOP
345:                             }
346:                             uBuffIndex++;
9D005624  93828074   LBU V0, -32652(GP)
9D005628  24420001   ADDIU V0, V0, 1
9D00562C  304200FF   ANDI V0, V0, 255
9D005630  A3828074   SB V0, -32652(GP)
9D005634  0B401590   J 0x9D005640
9D005638  00000000   NOP
347:                         }
348:                         uBuffIndex = 0;
9D005658  A3808074   SB ZERO, -32652(GP)
349:                         cBuff[0] = 0x00;
9D00565C  8FC20028   LW V0, 40(S8)
9D005660  A0400000   SB ZERO, 0(V0)
350:                         return cBuff;
9D005664  8FC20028   LW V0, 40(S8)
9D005668  0B401700   J 0x9D005C00
9D00566C  00000000   NOP
351:                     }
352:                     if(MENU_ACTION == INPUT_STRING)
9D005670  8F838070   LW V1, -32656(GP)
9D005674  24020008   ADDIU V0, ZERO, 8
9D005678  14620099   BNE V1, V0, 0x9D0058E0
9D00567C  00000000   NOP
353:                     {
354:                         if(cBuff[0] == 0x00) return StrFunctionPtr(cBuff, 0); // RunMenu
9D005680  8FC20028   LW V0, 40(S8)
9D005684  80420000   LB V0, 0(V0)
9D005688  14400088   BNE V0, ZERO, 0x9D0058AC
9D00568C  00000000   NOP
9D005690  8F8281C8   LW V0, -32312(GP)
9D005694  8FC40028   LW A0, 40(S8)
9D005698  00002821   ADDU A1, ZERO, ZERO
9D00569C  0040F809   JALR V0
9D0056A0  00000000   NOP
9D0056A4  0B401700   J 0x9D005C00
9D0056A8  00000000   NOP
355:                         while(cBuff[uBuffIndex] != 0x00)
9D0058AC  00000000   NOP
9D0058B0  93828074   LBU V0, -32652(GP)
9D0058B4  8FC30028   LW V1, 40(S8)
9D0058B8  00621021   ADDU V0, V1, V0
9D0058BC  80420000   LB V0, 0(V0)
9D0058C0  1440FF91   BNE V0, ZERO, 0x9D005708
9D0058C4  00000000   NOP
356:                         {
357:                             while((cBuff[uBuffIndex] >= 20) && (cBuff[uBuffIndex] <= 126))//Get everything in buffer
9D005708  00000000   NOP
9D00570C  93828074   LBU V0, -32652(GP)
9D005710  8FC30028   LW V1, 40(S8)
9D005714  00621021   ADDU V0, V1, V0
9D005718  80420000   LB V0, 0(V0)
9D00571C  28420014   SLTI V0, V0, 20
9D005720  14400008   BNE V0, ZERO, 0x9D005744
9D005724  00000000   NOP
9D005728  93828074   LBU V0, -32652(GP)
9D00572C  8FC30028   LW V1, 40(S8)
9D005730  00621021   ADDU V0, V1, V0
9D005734  80430000   LB V1, 0(V0)
9D005738  2402007F   ADDIU V0, ZERO, 127
9D00573C  1462FFDB   BNE V1, V0, 0x9D0056AC
9D005740  00000000   NOP
358:                             {
359:                                 alphaBuff[aBufferIndex + 1] = 0x00;
9D0056AC  93828075   LBU V0, -32651(GP)
9D0056B0  24430001   ADDIU V1, V0, 1
9D0056B4  278281CC   ADDIU V0, GP, -32308
9D0056B8  00621021   ADDU V0, V1, V0
9D0056BC  A0400000   SB ZERO, 0(V0)
360:                                 alphaBuff[aBufferIndex++]=cBuff[uBuffIndex++];
9D0056C0  93838075   LBU V1, -32651(GP)
9D0056C4  00603021   ADDU A2, V1, ZERO
9D0056C8  93828074   LBU V0, -32652(GP)
9D0056CC  00402021   ADDU A0, V0, ZERO
9D0056D0  8FC50028   LW A1, 40(S8)
9D0056D4  00A42021   ADDU A0, A1, A0
9D0056D8  80850000   LB A1, 0(A0)
9D0056DC  278481CC   ADDIU A0, GP, -32308
9D0056E0  00C42021   ADDU A0, A2, A0
9D0056E4  A0850000   SB A1, 0(A0)
9D0056E8  24630001   ADDIU V1, V1, 1
9D0056EC  306300FF   ANDI V1, V1, 255
9D0056F0  A3838075   SB V1, -32651(GP)
9D0056F4  24420001   ADDIU V0, V0, 1
9D0056F8  304200FF   ANDI V0, V0, 255
9D0056FC  A3828074   SB V0, -32652(GP)
9D005700  0B4015C3   J 0x9D00570C
9D005704  00000000   NOP
361:                             }
362:                             if(cBuff[uBuffIndex] == 0x00)return cBuff;
9D005744  93828074   LBU V0, -32652(GP)
9D005748  8FC30028   LW V1, 40(S8)
9D00574C  00621021   ADDU V0, V1, V0
9D005750  80420000   LB V0, 0(V0)
9D005754  14400004   BNE V0, ZERO, 0x9D005768
9D005758  00000000   NOP
9D00575C  8FC20028   LW V0, 40(S8)
9D005760  0B401700   J 0x9D005C00
9D005764  00000000   NOP
363:                 
364:                             if(cBuff[uBuffIndex] == 0x0D)//Input complete, process string
9D005768  93828074   LBU V0, -32652(GP)
9D00576C  8FC30028   LW V1, 40(S8)
9D005770  00621021   ADDU V0, V1, V0
9D005774  80430000   LB V1, 0(V0)
9D005778  2402000D   ADDIU V0, ZERO, 13
9D00577C  1462002C   BNE V1, V0, 0x9D005830
9D005780  00000000   NOP
365:                             {
366:                                 aBufferIndex = 0; //Reset index
9D005784  A3808075   SB ZERO, -32651(GP)
367:                                 cBuff[uBuffIndex] = 0x00;
9D005788  93828074   LBU V0, -32652(GP)
9D00578C  8FC30028   LW V1, 40(S8)
9D005790  00621021   ADDU V0, V1, V0
9D005794  A0400000   SB ZERO, 0(V0)
368:                                 //if(tempInt != NULL) (*tempInt)(int);
369:                                 if(StrFunctionPtr != NULL )//Be sure your pointing at something
9D005798  8F8281C8   LW V0, -32312(GP)
9D00579C  10400012   BEQ V0, ZERO, 0x9D0057E8
9D0057A0  00000000   NOP
370:                                 {
371:                                     cBuff[0] = 1; //Being non zero supresses menu
9D0057A4  8FC20028   LW V0, 40(S8)
9D0057A8  24030001   ADDIU V1, ZERO, 1
9D0057AC  A0430000   SB V1, 0(V0)
372:                                     StrFunctionPtr(alphaBuff, 1);// Second argument is optional
9D0057B0  8F8281C8   LW V0, -32312(GP)
9D0057B4  278481CC   ADDIU A0, GP, -32308
9D0057B8  24050001   ADDIU A1, ZERO, 1
9D0057BC  0040F809   JALR V0
9D0057C0  00000000   NOP
373:                                     MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D0057C4  24020002   ADDIU V0, ZERO, 2
9D0057C8  AF828070   SW V0, -32656(GP)
374:                                     return CurrentMenuPtr(cBuff, -1);
9D0057CC  8F8281E4   LW V0, -32284(GP)
9D0057D0  8FC40028   LW A0, 40(S8)
9D0057D4  2405FFFF   ADDIU A1, ZERO, -1
9D0057D8  0040F809   JALR V0
9D0057DC  00000000   NOP
9D0057E0  0B401700   J 0x9D005C00
9D0057E4  00000000   NOP
375:                                 }
376:                                 else
377:                                 {
378:                                     sprintf(cBuff,"Null Pointer Error \r\n ");
9D0057E8  8FC40028   LW A0, 40(S8)
9D0057EC  3C029D01   LUI V0, -25343
9D0057F0  24457D30   ADDIU A1, V0, 32048
9D0057F4  24060017   ADDIU A2, ZERO, 23
9D0057F8  0F405AA3   JAL 0x9D016A8C
9D0057FC  00000000   NOP
379:                                     CurrentMenuPtr(&cBuff[23],-1);//Re Run last menu;
9D005800  8F8281E4   LW V0, -32284(GP)
9D005804  8FC30028   LW V1, 40(S8)
9D005808  24630017   ADDIU V1, V1, 23
9D00580C  00602021   ADDU A0, V1, ZERO
9D005810  2405FFFF   ADDIU A1, ZERO, -1
9D005814  0040F809   JALR V0
9D005818  00000000   NOP
380:                                     MENU_ACTION = NAVIGATE_MENU; //Go back to last menu
9D00581C  24020002   ADDIU V0, ZERO, 2
9D005820  AF828070   SW V0, -32656(GP)
381:                                     return cBuff;
9D005824  8FC20028   LW V0, 40(S8)
9D005828  0B401700   J 0x9D005C00
9D00582C  00000000   NOP
382:                                 }
383:                             }
384:                             if(cBuff[uBuffIndex] == 0x08)//if there is a back space erase last number
9D005830  93828074   LBU V0, -32652(GP)
9D005834  8FC30028   LW V1, 40(S8)
9D005838  00621021   ADDU V0, V1, V0
9D00583C  80430000   LB V1, 0(V0)
9D005840  24020008   ADDIU V0, ZERO, 8
9D005844  14620013   BNE V1, V0, 0x9D005894
9D005848  00000000   NOP
385:                             {
386:                                 alphaBuff[--aBufferIndex] = 0x00; // erase last number
9D00584C  93828075   LBU V0, -32651(GP)
9D005850  2442FFFF   ADDIU V0, V0, -1
9D005854  304200FF   ANDI V0, V0, 255
9D005858  A3828075   SB V0, -32651(GP)
9D00585C  93828075   LBU V0, -32651(GP)
9D005860  00401821   ADDU V1, V0, ZERO
9D005864  278281CC   ADDIU V0, GP, -32308
9D005868  00621021   ADDU V0, V1, V0
9D00586C  A0400000   SB ZERO, 0(V0)
387:                                 sprintf(cBuff,"\x1B[1D\x1B[K");
9D005870  8FC40028   LW A0, 40(S8)
9D005874  3C029D01   LUI V0, -25343
9D005878  24457D70   ADDIU A1, V0, 32112
9D00587C  24060008   ADDIU A2, ZERO, 8
9D005880  0F405AA3   JAL 0x9D016A8C
9D005884  00000000   NOP
388:                                 return cBuff;
9D005888  8FC20028   LW V0, 40(S8)
9D00588C  0B401700   J 0x9D005C00
9D005890  00000000   NOP
389:                             }
390:                             uBuffIndex++;
9D005894  93828074   LBU V0, -32652(GP)
9D005898  24420001   ADDIU V0, V0, 1
9D00589C  304200FF   ANDI V0, V0, 255
9D0058A0  A3828074   SB V0, -32652(GP)
9D0058A4  0B40162C   J 0x9D0058B0
9D0058A8  00000000   NOP
391:                         }
392:                         uBuffIndex = 0;
9D0058C8  A3808074   SB ZERO, -32652(GP)
393:                         cBuff[0] = 0x00;
9D0058CC  8FC20028   LW V0, 40(S8)
9D0058D0  A0400000   SB ZERO, 0(V0)
394:                         return cBuff;
9D0058D4  8FC20028   LW V0, 40(S8)
9D0058D8  0B401700   J 0x9D005C00
9D0058DC  00000000   NOP
395:                     }
396:                         //if the esc or backspace key is pressed go up the menu tree
397:                 
398:                     if((keyPress == htESC)|(keyPress == htBS))//If user presses ecs move menu back one
9D0058E0  83C20010   LB V0, 16(S8)
9D0058E4  3842001B   XORI V0, V0, 27
9D0058E8  2C420001   SLTIU V0, V0, 1
9D0058EC  304300FF   ANDI V1, V0, 255
9D0058F0  83C20010   LB V0, 16(S8)
9D0058F4  38420008   XORI V0, V0, 8
9D0058F8  2C420001   SLTIU V0, V0, 1
9D0058FC  304200FF   ANDI V0, V0, 255
9D005900  00621025   OR V0, V1, V0
9D005904  304200FF   ANDI V0, V0, 255
9D005908  10400072   BEQ V0, ZERO, 0x9D005AD4
9D00590C  00000000   NOP
399:                     {      
400:                         if(menuIndex > 0) //
9D005910  83828090   LB V0, -32624(GP)
9D005914  1840003A   BLEZ V0, 0x9D005A00
9D005918  00000000   NOP
401:                         {
402:                             menuIndex--;
9D00591C  83828090   LB V0, -32624(GP)
9D005920  2442FFFF   ADDIU V0, V0, -1
9D005924  7C021420   SEB V0, V0
9D005928  A3828090   SB V0, -32624(GP)
403:                             //If we are going to show the main menu, then get ready to exit next esc char
404:                             if(menuIndex == 0)menuExitFlag = 1;
9D00592C  83828090   LB V0, -32624(GP)
9D005930  14400003   BNE V0, ZERO, 0x9D005940
9D005934  00000000   NOP
9D005938  24020001   ADDIU V0, ZERO, 1
9D00593C  A382807B   SB V0, -32645(GP)
405:                             if(MenuHistory[menuIndex] != 0x00)
9D005940  83828090   LB V0, -32624(GP)
9D005944  00401821   ADDU V1, V0, ZERO
9D005948  3C02A000   LUI V0, -24576
9D00594C  00031880   SLL V1, V1, 2
9D005950  2442037C   ADDIU V0, V0, 892
9D005954  00621021   ADDU V0, V1, V0
9D005958  8C420000   LW V0, 0(V0)
9D00595C  10400014   BEQ V0, ZERO, 0x9D0059B0
9D005960  00000000   NOP
406:                             {
407:                                 MenuHistory[menuIndex](cBuff, -1);
9D005964  83828090   LB V0, -32624(GP)
9D005968  00401821   ADDU V1, V0, ZERO
9D00596C  3C02A000   LUI V0, -24576
9D005970  00031880   SLL V1, V1, 2
9D005974  2442037C   ADDIU V0, V0, 892
9D005978  00621021   ADDU V0, V1, V0
9D00597C  8C420000   LW V0, 0(V0)
9D005980  8FC40028   LW A0, 40(S8)
9D005984  2405FFFF   ADDIU A1, ZERO, -1
9D005988  0040F809   JALR V0
9D00598C  00000000   NOP
408:                                 CurrentMenuPtr = MenuHistory[menuIndex];
9D005990  83828090   LB V0, -32624(GP)
9D005994  00401821   ADDU V1, V0, ZERO
9D005998  3C02A000   LUI V0, -24576
9D00599C  00031880   SLL V1, V1, 2
9D0059A0  2442037C   ADDIU V0, V0, 892
9D0059A4  00621021   ADDU V0, V1, V0
9D0059A8  8C420000   LW V0, 0(V0)
9D0059AC  AF8281E4   SW V0, -32284(GP)
409:                             }
410:                             MenuHistory[menuIndex] = 0x00; // Erase last menu history
9D0059B0  83828090   LB V0, -32624(GP)
9D0059B4  00401821   ADDU V1, V0, ZERO
9D0059B8  3C02A000   LUI V0, -24576
9D0059BC  00031880   SLL V1, V1, 2
9D0059C0  2442037C   ADDIU V0, V0, 892
9D0059C4  00621021   ADDU V0, V1, V0
9D0059C8  AC400000   SW ZERO, 0(V0)
411:                             LCDClear();
9D0059CC  0F4031E3   JAL LCDClear
9D0059D0  00000000   NOP
412:                             LCDPutString(cBuff);
9D0059D4  8FC40028   LW A0, 40(S8)
9D0059D8  0F403370   JAL LCDPutString
9D0059DC  00000000   NOP
413:                             BuildTouchPad(NavigationPad,BRIGHTGREEN);
9D0059E0  3C02A000   LUI V0, -24576
9D0059E4  244409B4   ADDIU A0, V0, 2484
9D0059E8  240507E0   ADDIU A1, ZERO, 2016
9D0059EC  0F402DCC   JAL BuildTouchPad
9D0059F0  00000000   NOP
414:                             return cBuff;
9D0059F4  8FC20028   LW V0, 40(S8)
9D0059F8  0B401700   J 0x9D005C00
9D0059FC  00000000   NOP
415:                         }
416:                         else if(menuIndex == 0)//Show Main Menu
9D005A00  83828090   LB V0, -32624(GP)
9D005A04  14400033   BNE V0, ZERO, 0x9D005AD4
9D005A08  00000000   NOP
417:                         {
418:                             if(menuExitFlag == 1)
9D005A0C  8383807B   LB V1, -32645(GP)
9D005A10  24020001   ADDIU V0, ZERO, 1
9D005A14  1462000F   BNE V1, V0, 0x9D005A54
9D005A18  00000000   NOP
419:                             {
420:                                 MENU_ACTION = MENU_INACTIVE;
9D005A1C  AF808070   SW ZERO, -32656(GP)
421:                                 //cBuff[0] = NULL;
422:                                 menuIndex = 0;
9D005A20  A3808090   SB ZERO, -32624(GP)
423:                                 menuExitFlag = 0;
9D005A24  A380807B   SB ZERO, -32645(GP)
424:                                 ExitMenus();
9D005A28  0F4044F4   JAL ExitMenus
9D005A2C  00000000   NOP
425:                                 cBuff[0] = 0x20;
9D005A30  8FC20028   LW V0, 40(S8)
9D005A34  24030020   ADDIU V1, ZERO, 32
9D005A38  A0430000   SB V1, 0(V0)
426:                                 cBuff[2] = NULL;
9D005A3C  8FC20028   LW V0, 40(S8)
9D005A40  24420002   ADDIU V0, V0, 2
9D005A44  A0400000   SB ZERO, 0(V0)
427:                                 return cBuff;
9D005A48  8FC20028   LW V0, 40(S8)
9D005A4C  0B401700   J 0x9D005C00
9D005A50  00000000   NOP
428:                 
429:                             }
430:                             //menuIndex--;
431:                             menuExitFlag = 1;
9D005A54  24020001   ADDIU V0, ZERO, 1
9D005A58  A382807B   SB V0, -32645(GP)
432:                             MENU_ACTION = NAVIGATE_MENU;//SHOW_MAIN_MENU;
9D005A5C  24020002   ADDIU V0, ZERO, 2
9D005A60  AF828070   SW V0, -32656(GP)
433:                             CurrentMenuPtr = MenuHomePage;
9D005A64  8F8281D4   LW V0, -32300(GP)
9D005A68  AF8281E4   SW V0, -32284(GP)
434:                             MenuHistory[menuIndex] = CurrentMenuPtr;
9D005A6C  83828090   LB V0, -32624(GP)
9D005A70  00402021   ADDU A0, V0, ZERO
9D005A74  8F8381E4   LW V1, -32284(GP)
9D005A78  3C02A000   LUI V0, -24576
9D005A7C  00042080   SLL A0, A0, 2
9D005A80  2442037C   ADDIU V0, V0, 892
9D005A84  00821021   ADDU V0, A0, V0
9D005A88  AC430000   SW V1, 0(V0)
435:                             CurrentMenuPtr(cBuff, -1);
9D005A8C  8F8281E4   LW V0, -32284(GP)
9D005A90  8FC40028   LW A0, 40(S8)
9D005A94  2405FFFF   ADDIU A1, ZERO, -1
9D005A98  0040F809   JALR V0
9D005A9C  00000000   NOP
436:                             LCDClear();
9D005AA0  0F4031E3   JAL LCDClear
9D005AA4  00000000   NOP
437:                             LCDPutString(cBuff);
9D005AA8  8FC40028   LW A0, 40(S8)
9D005AAC  0F403370   JAL LCDPutString
9D005AB0  00000000   NOP
438:                             BuildTouchPad(NavigationPad,BRIGHTGREEN);
9D005AB4  3C02A000   LUI V0, -24576
9D005AB8  244409B4   ADDIU A0, V0, 2484
9D005ABC  240507E0   ADDIU A1, ZERO, 2016
9D005AC0  0F402DCC   JAL BuildTouchPad
9D005AC4  00000000   NOP
439:                             return cBuff;
9D005AC8  8FC20028   LW V0, 40(S8)
9D005ACC  0B401700   J 0x9D005C00
9D005AD0  00000000   NOP
440:                         }  
441:                     }
442:                     if(MENU_ACTION == NAVIGATE_MENU) //Limits inputs to number 1 to 9;
9D005AD4  8F838070   LW V1, -32656(GP)
9D005AD8  24020002   ADDIU V0, ZERO, 2
9D005ADC  14620041   BNE V1, V0, 0x9D005BE4
9D005AE0  00000000   NOP
443:                     {
444:                         keyPress = keyPress - 48; //Normalize keypress to numbers
9D005AE4  93C20010   LBU V0, 16(S8)
9D005AE8  2442FFD0   ADDIU V0, V0, -48
9D005AEC  304200FF   ANDI V0, V0, 255
9D005AF0  A3C20010   SB V0, 16(S8)
445:                         if(keyPress >= (char)0 && keyPress <= (char)9)
9D005AF4  83C20010   LB V0, 16(S8)
9D005AF8  04400035   BLTZ V0, 0x9D005BD0
9D005AFC  00000000   NOP
9D005B00  83C20010   LB V0, 16(S8)
9D005B04  2842000A   SLTI V0, V0, 10
9D005B08  10400031   BEQ V0, ZERO, 0x9D005BD0
9D005B0C  00000000   NOP
446:                         {
447:                             //First navigate using the menu displayed previously
448:                             //When keypress >=0 the CurrentMenuPtr is set to the new menu page
449:                             //by SetMenuPage()
450:                             CurrentMenuPtr(cBuff, keyPress);//keyPress[menuIndex]);
9D005B10  8F8281E4   LW V0, -32284(GP)
9D005B14  83C30010   LB V1, 16(S8)
9D005B18  8FC40028   LW A0, 40(S8)
9D005B1C  00602821   ADDU A1, V1, ZERO
9D005B20  0040F809   JALR V0
9D005B24  00000000   NOP
451:                             //if(CONFIG_FUNCTION != NAVIGATE_MENU)
452:                 
453:                             //cBuff[0] = 0x00;// The 0x00 will display cofig discriptor
454:                             if(MenuHistory[menuIndex] != CurrentMenuPtr)
9D005B28  83828090   LB V0, -32624(GP)
9D005B2C  00401821   ADDU V1, V0, ZERO
9D005B30  3C02A000   LUI V0, -24576
9D005B34  00031880   SLL V1, V1, 2
9D005B38  2442037C   ADDIU V0, V0, 892
9D005B3C  00621021   ADDU V0, V1, V0
9D005B40  8C430000   LW V1, 0(V0)
9D005B44  8F8281E4   LW V0, -32284(GP)
9D005B48  10620026   BEQ V1, V0, 0x9D005BE4
9D005B4C  00000000   NOP
455:                             {
456:                                 menuIndex++;
9D005B50  83828090   LB V0, -32624(GP)
9D005B54  24420001   ADDIU V0, V0, 1
9D005B58  7C021420   SEB V0, V0
9D005B5C  A3828090   SB V0, -32624(GP)
457:                                 menuExitFlag = 0;
9D005B60  A380807B   SB ZERO, -32645(GP)
458:                                 MenuHistory[menuIndex] = CurrentMenuPtr;
9D005B64  83828090   LB V0, -32624(GP)
9D005B68  00402021   ADDU A0, V0, ZERO
9D005B6C  8F8381E4   LW V1, -32284(GP)
9D005B70  3C02A000   LUI V0, -24576
9D005B74  00042080   SLL A0, A0, 2
9D005B78  2442037C   ADDIU V0, V0, 892
9D005B7C  00821021   ADDU V0, A0, V0
9D005B80  AC430000   SW V1, 0(V0)
459:                                 //return CurrentMenuPtr(cBuff, -1);  // When < 0 function's menu screen is run;
460:                                 CurrentMenuPtr(cBuff, -1);  // When second param is < 0 function's menu screen is run;
9D005B84  8F8281E4   LW V0, -32284(GP)
9D005B88  8FC40028   LW A0, 40(S8)
9D005B8C  2405FFFF   ADDIU A1, ZERO, -1
9D005B90  0040F809   JALR V0
9D005B94  00000000   NOP
461:                                 mainMenuFlag = 0;
9D005B98  A3808091   SB ZERO, -32623(GP)
462:                                 LCDClear();
9D005B9C  0F4031E3   JAL LCDClear
9D005BA0  00000000   NOP
463:                                 LCDPutString(cBuff);
9D005BA4  8FC40028   LW A0, 40(S8)
9D005BA8  0F403370   JAL LCDPutString
9D005BAC  00000000   NOP
464:                                 BuildTouchPad(NavigationPad,BRIGHTGREEN);
9D005BB0  3C02A000   LUI V0, -24576
9D005BB4  244409B4   ADDIU A0, V0, 2484
9D005BB8  240507E0   ADDIU A1, ZERO, 2016
9D005BBC  0F402DCC   JAL BuildTouchPad
9D005BC0  00000000   NOP
465:                                 return cBuff;
9D005BC4  8FC20028   LW V0, 40(S8)
9D005BC8  0B401700   J 0x9D005C00
9D005BCC  00000000   NOP
466:                             }
467:                         }
468:                         else
469:                         {
470:                             cBuff[0] = 0x00;
9D005BD0  8FC20028   LW V0, 40(S8)
9D005BD4  A0400000   SB ZERO, 0(V0)
471:                             return cBuff;
9D005BD8  8FC20028   LW V0, 40(S8)
9D005BDC  0B401700   J 0x9D005C00
9D005BE0  00000000   NOP
472:                         }
473:                     }
474:                     
475:                     if(MENU_ACTION == SHOW_MAIN_MENU) //Limits inputs to number 1 to 9;
9D005BE4  8F838070   LW V1, -32656(GP)
9D005BE8  24020001   ADDIU V0, ZERO, 1
9D005BEC  14620003   BNE V1, V0, 0x9D005BFC
9D005BF0  00000000   NOP
476:                     {
477:                         //menuIndex = 0;
478:                         MENU_ACTION  = NAVIGATE_MENU;
9D005BF4  24020002   ADDIU V0, ZERO, 2
9D005BF8  AF828070   SW V0, -32656(GP)
479:                         //CurrentMenuPtr = MenuHomePage;
480:                         //MenuHistory[menuIndex] = CurrentMenuPtr;
481:                         //MenuHistory[menuIndex](cBuff, -1);
482:                         //return cBuff;
483:                     }
484:                     /*
485:                     if(cBuff[0] != NULL)
486:                     {
487:                 
488:                     }*/
489:                     return cBuff;
9D005BFC  8FC20028   LW V0, 40(S8)
490:                     //uBuffIndex++;
491:                 
492:                 }
9D005C00  03C0E821   ADDU SP, S8, ZERO
9D005C04  8FBF0024   LW RA, 36(SP)
9D005C08  8FBE0020   LW S8, 32(SP)
9D005C0C  8FB0001C   LW S0, 28(SP)
9D005C10  27BD0028   ADDIU SP, SP, 40
9D005C14  03E00008   JR RA
9D005C18  00000000   NOP
493:                 
494:                 #ifdef _TMENU_CONNECTION_UART
495:                 
496:                 
497:                 #endif
498:                 void InitMenuStartPage(char*(*MenuFuncPtr)(char*, char))
499:                 {
9D005C1C  27BDFFF8   ADDIU SP, SP, -8
9D005C20  AFBE0004   SW S8, 4(SP)
9D005C24  03A0F021   ADDU S8, SP, ZERO
9D005C28  AFC40008   SW A0, 8(S8)
500:                     MenuHomePage = MenuFuncPtr;
9D005C2C  8FC20008   LW V0, 8(S8)
9D005C30  AF8281D4   SW V0, -32300(GP)
501:                     MENU_ACTION = NAVIGATE_MENU;
9D005C34  24020002   ADDIU V0, ZERO, 2
9D005C38  AF828070   SW V0, -32656(GP)
502:                 }
9D005C3C  03C0E821   ADDU SP, S8, ZERO
9D005C40  8FBE0004   LW S8, 4(SP)
9D005C44  27BD0008   ADDIU SP, SP, 8
9D005C48  03E00008   JR RA
9D005C4C  00000000   NOP
503:                 
504:                 char* GetAccessPoints(char* cBuff, char Value)
505:                 {
9D005C50  27BDFFE8   ADDIU SP, SP, -24
9D005C54  AFBF0014   SW RA, 20(SP)
9D005C58  AFBE0010   SW S8, 16(SP)
9D005C5C  03A0F021   ADDU S8, SP, ZERO
9D005C60  AFC40018   SW A0, 24(S8)
9D005C64  00A01021   ADDU V0, A1, ZERO
9D005C68  A3C2001C   SB V0, 28(S8)
506:                 	sprintf(cBuff, "!** Select Access Point **!\r\n");
9D005C6C  8FC40018   LW A0, 24(S8)
9D005C70  3C029D01   LUI V0, -25343
9D005C74  24457DA0   ADDIU A1, V0, 32160
9D005C78  2406001E   ADDIU A2, ZERO, 30
9D005C7C  0F405AA3   JAL 0x9D016A8C
9D005C80  00000000   NOP
507:                 	strcat(cBuff,"\t 1 - Stillbright\r\n");
9D005C84  8FC40018   LW A0, 24(S8)
9D005C88  0F405AFD   JAL 0x9D016BF4
9D005C8C  00000000   NOP
9D005C90  8FC30018   LW V1, 24(S8)
9D005C94  00621021   ADDU V0, V1, V0
9D005C98  00402021   ADDU A0, V0, ZERO
9D005C9C  3C029D01   LUI V0, -25343
9D005CA0  24457DC0   ADDIU A1, V0, 32192
9D005CA4  24060014   ADDIU A2, ZERO, 20
9D005CA8  0F405AA3   JAL 0x9D016A8C
9D005CAC  00000000   NOP
508:                 	strcat(cBuff,"\t 2 - Riotech\r\n");
9D005CB0  8FC40018   LW A0, 24(S8)
9D005CB4  0F405AFD   JAL 0x9D016BF4
9D005CB8  00000000   NOP
9D005CBC  8FC30018   LW V1, 24(S8)
9D005CC0  00621021   ADDU V0, V1, V0
9D005CC4  00402021   ADDU A0, V0, ZERO
9D005CC8  3C029D01   LUI V0, -25343
9D005CCC  24457DD4   ADDIU A1, V0, 32212
9D005CD0  24060010   ADDIU A2, ZERO, 16
9D005CD4  0F405AA3   JAL 0x9D016A8C
9D005CD8  00000000   NOP
509:                 	return cBuff;
9D005CDC  8FC20018   LW V0, 24(S8)
510:                 }
9D005CE0  03C0E821   ADDU SP, S8, ZERO
9D005CE4  8FBF0014   LW RA, 20(SP)
9D005CE8  8FBE0010   LW S8, 16(SP)
9D005CEC  27BD0018   ADDIU SP, SP, 24
9D005CF0  03E00008   JR RA
9D005CF4  00000000   NOP
511:                 void SetMenuPage(char*(*MenuFuncPtr)(char*, char))
512:                 {
9D005CF8  27BDFFF8   ADDIU SP, SP, -8
9D005CFC  AFBE0004   SW S8, 4(SP)
9D005D00  03A0F021   ADDU S8, SP, ZERO
9D005D04  AFC40008   SW A0, 8(S8)
513:                     CurrentMenuPtr = MenuFuncPtr;
9D005D08  8FC20008   LW V0, 8(S8)
9D005D0C  AF8281E4   SW V0, -32284(GP)
514:                     MENU_ACTION = NAVIGATE_MENU;
9D005D10  24020002   ADDIU V0, ZERO, 2
9D005D14  AF828070   SW V0, -32656(GP)
515:                 }
9D005D18  03C0E821   ADDU SP, S8, ZERO
9D005D1C  8FBE0004   LW S8, 4(SP)
9D005D20  27BD0008   ADDIU SP, SP, 8
9D005D24  03E00008   JR RA
9D005D28  00000000   NOP
516:                 void SetIntConfig(char*(*IntFuncPtr)(char*, int))
517:                 {
9D005D2C  27BDFFF8   ADDIU SP, SP, -8
9D005D30  AFBE0004   SW S8, 4(SP)
9D005D34  03A0F021   ADDU S8, SP, ZERO
9D005D38  AFC40008   SW A0, 8(S8)
518:                     notZeroFlag = 0; //so far users input is zero 
9D005D3C  A3808077   SB ZERO, -32649(GP)
519:                     negSymbolExists = 0; //user has not entered neg symbol
9D005D40  A3808078   SB ZERO, -32648(GP)
520:                     decimalExists = 0;
9D005D44  A3808079   SB ZERO, -32647(GP)
521:                     IntFunctionPtr = IntFuncPtr;
9D005D48  8FC20008   LW V0, 8(S8)
9D005D4C  AF8281B4   SW V0, -32332(GP)
522:                     MENU_ACTION = INPUT_INT;
9D005D50  24020003   ADDIU V0, ZERO, 3
9D005D54  AF828070   SW V0, -32656(GP)
523:                 }
9D005D58  03C0E821   ADDU SP, S8, ZERO
9D005D5C  8FBE0004   LW S8, 4(SP)
9D005D60  27BD0008   ADDIU SP, SP, 8
9D005D64  03E00008   JR RA
9D005D68  00000000   NOP
524:                 void SetUintConfig(char*(*uIntFuncPtr)(char*, uInt))
525:                 {
9D005D6C  27BDFFF8   ADDIU SP, SP, -8
9D005D70  AFBE0004   SW S8, 4(SP)
9D005D74  03A0F021   ADDU S8, SP, ZERO
9D005D78  AFC40008   SW A0, 8(S8)
526:                     notZeroFlag = 0; //so far users input is zero 
9D005D7C  A3808077   SB ZERO, -32649(GP)
527:                     negSymbolExists = 0; //user has not entered neg symbol
9D005D80  A3808078   SB ZERO, -32648(GP)
528:                     decimalExists = 0;
9D005D84  A3808079   SB ZERO, -32647(GP)
529:                     uIntFunctionPtr = uIntFuncPtr;
9D005D88  8FC20008   LW V0, 8(S8)
9D005D8C  AF8281DC   SW V0, -32292(GP)
530:                     MENU_ACTION = INPUT_UINT;
9D005D90  24020004   ADDIU V0, ZERO, 4
9D005D94  AF828070   SW V0, -32656(GP)
531:                 }
9D005D98  03C0E821   ADDU SP, S8, ZERO
9D005D9C  8FBE0004   LW S8, 4(SP)
9D005DA0  27BD0008   ADDIU SP, SP, 8
9D005DA4  03E00008   JR RA
9D005DA8  00000000   NOP
532:                 void SetLongConfig(char*(*LongFuncPtr)(char*, double))
533:                 {
9D005DAC  27BDFFF8   ADDIU SP, SP, -8
9D005DB0  AFBE0004   SW S8, 4(SP)
9D005DB4  03A0F021   ADDU S8, SP, ZERO
9D005DB8  AFC40008   SW A0, 8(S8)
534:                     notZeroFlag = 0; //so far users input is zero 
9D005DBC  A3808077   SB ZERO, -32649(GP)
535:                     negSymbolExists = 0; //user has not entered neg symbol
9D005DC0  A3808078   SB ZERO, -32648(GP)
536:                     decimalExists = 0;
9D005DC4  A3808079   SB ZERO, -32647(GP)
537:                     LongFunctionPtr = LongFuncPtr;
9D005DC8  8FC20008   LW V0, 8(S8)
9D005DCC  AF8281D8   SW V0, -32296(GP)
538:                     MENU_ACTION = INPUT_LONG;
9D005DD0  24020006   ADDIU V0, ZERO, 6
9D005DD4  AF828070   SW V0, -32656(GP)
539:                 }
9D005DD8  03C0E821   ADDU SP, S8, ZERO
9D005DDC  8FBE0004   LW S8, 4(SP)
9D005DE0  27BD0008   ADDIU SP, SP, 8
9D005DE4  03E00008   JR RA
9D005DE8  00000000   NOP
540:                 void SetFloatConfig(char*(*FloatFuncPtr)(char*, float))
541:                 {
9D005DEC  27BDFFF8   ADDIU SP, SP, -8
9D005DF0  AFBE0004   SW S8, 4(SP)
9D005DF4  03A0F021   ADDU S8, SP, ZERO
9D005DF8  AFC40008   SW A0, 8(S8)
542:                     notZeroFlag = 0; //so far users input is zero 
9D005DFC  A3808077   SB ZERO, -32649(GP)
543:                     negSymbolExists = 0; //user has not entered neg symbol
9D005E00  A3808078   SB ZERO, -32648(GP)
544:                     decimalExists = 0;
9D005E04  A3808079   SB ZERO, -32647(GP)
545:                     FloatFunctionPtr = FloatFuncPtr;
9D005E08  8FC20008   LW V0, 8(S8)
9D005E0C  AF8281C0   SW V0, -32320(GP)
546:                     MENU_ACTION = INPUT_FLOAT;
9D005E10  24020005   ADDIU V0, ZERO, 5
9D005E14  AF828070   SW V0, -32656(GP)
547:                 }
9D005E18  03C0E821   ADDU SP, S8, ZERO
9D005E1C  8FBE0004   LW S8, 4(SP)
9D005E20  27BD0008   ADDIU SP, SP, 8
9D005E24  03E00008   JR RA
9D005E28  00000000   NOP
548:                 void SetStrConfig(char*(*StrFuncPtr)(char*, uInt))
549:                 {
9D005E2C  27BDFFF8   ADDIU SP, SP, -8
9D005E30  AFBE0004   SW S8, 4(SP)
9D005E34  03A0F021   ADDU S8, SP, ZERO
9D005E38  AFC40008   SW A0, 8(S8)
550:                     notZeroFlag = 0; //so far users input is zero 
9D005E3C  A3808077   SB ZERO, -32649(GP)
551:                     StrFunctionPtr = StrFuncPtr;
9D005E40  8FC20008   LW V0, 8(S8)
9D005E44  AF8281C8   SW V0, -32312(GP)
552:                     MENU_ACTION = INPUT_STRING;
9D005E48  24020008   ADDIU V0, ZERO, 8
9D005E4C  AF828070   SW V0, -32656(GP)
553:                 }
9D005E50  03C0E821   ADDU SP, S8, ZERO
9D005E54  8FBE0004   LW S8, 4(SP)
9D005E58  27BD0008   ADDIU SP, SP, 8
9D005E5C  03E00008   JR RA
9D005E60  00000000   NOP
---  C:/MC_XProjects/FC_APP/APP_SOURCE/report_mgr.c  ----------------------------------------------------
1:                   #include "../report_mgr.h"
2:                   
3:                   
4:                   char* ConfigReports(char* cBuff, char keyPress)
5:                   {
9D018000  27BDFFE8   ADDIU SP, SP, -24
9D018004  AFBF0014   SW RA, 20(SP)
9D018008  AFBE0010   SW S8, 16(SP)
9D01800C  03A0F021   ADDU S8, SP, ZERO
9D018010  AFC40018   SW A0, 24(S8)
9D018014  00A01021   ADDU V0, A1, ZERO
9D018018  A3C2001C   SB V0, 28(S8)
6:                       if(keyPress < 0)
9D01801C  83C2001C   LB V0, 28(S8)
9D018020  0441000A   BGEZ V0, 0x9D01804C
9D018024  00000000   NOP
7:                       {
8:                           sprintf(cBuff,"\x1B[2J\x1B[H !* Config Meters & Sensors *!\r\n \
9D018028  8FC40018   LW A0, 24(S8)
9D01802C  3C029D02   LUI V0, -25342
9D018030  24458A50   ADDIU A1, V0, -30128
9D018034  24060057   ADDIU A2, ZERO, 87
9D018038  0F405AA3   JAL 0x9D016A8C
9D01803C  00000000   NOP
9:                   \t1 - Run Reports\r\n \
10:                  \t2 - Config Reports/Date \r\n");
11:                          return cBuff;
9D018040  8FC20018   LW V0, 24(S8)
9D018044  0B406026   J 0x9D018098
9D018048  00000000   NOP
12:                      }
13:                      if(keyPress == 1)
9D01804C  83C3001C   LB V1, 28(S8)
9D018050  24020001   ADDIU V0, ZERO, 1
9D018054  14620005   BNE V1, V0, 0x9D01806C
9D018058  00000000   NOP
14:                      {
15:                          SetMenuPage(WiFiConfigMenu);
9D01805C  3C029D01   LUI V0, -25343
9D018060  244464B8   ADDIU A0, V0, 25784
9D018064  0F40173E   JAL SetMenuPage
9D018068  00000000   NOP
16:                      }
17:                      if(keyPress ==2)
9D01806C  83C3001C   LB V1, 28(S8)
9D018070  24020002   ADDIU V0, ZERO, 2
9D018074  14620005   BNE V1, V0, 0x9D01808C
9D018078  00000000   NOP
18:                      {
19:                          SetMenuPage(WiFiConfigDHCP);
9D01807C  3C029D01   LUI V0, -25343
9D018080  244465CC   ADDIU A0, V0, 26060
9D018084  0F40173E   JAL SetMenuPage
9D018088  00000000   NOP
20:                      }
21:                      cBuff[0] = 0x00;
9D01808C  8FC20018   LW V0, 24(S8)
9D018090  A0400000   SB ZERO, 0(V0)
22:                      return cBuff;
9D018094  8FC20018   LW V0, 24(S8)
23:                  }
9D018098  03C0E821   ADDU SP, S8, ZERO
9D01809C  8FBF0014   LW RA, 20(SP)
9D0180A0  8FBE0010   LW S8, 16(SP)
9D0180A4  27BD0018   ADDIU SP, SP, 24
9D0180A8  03E00008   JR RA
9D0180AC  00000000   NOP
---  C:/MC_XProjects/FC_APP/APP_SOURCE/app_main.c  ------------------------------------------------------
1:                   /*
2:                    * File:   app_main.c
3:                    * Author: JKovach - Copyright Stillbright LLC 2012
4:                    * Description: Module for holding the appMain function which is the starting point for any
5:                    * application.
6:                    * Revisions:   9/9/12 - Created
7:                    *              10/24/12 -  Added switch variable to control what sensor inputs are being used
8:                    *              used by the application.
9:                    *
10:                   *
11:                   */
12:                  #include <stdio.h>
13:                  #include <stdlib.h>
14:                  #include <string.h>
15:                  #include "../app_main.h"
16:                  #include "../../Microhip/Include/Graphics/Graphics.h"
17:                  
18:                  //************************************* Sensor Input Defines ********************************
19:                  // There are four groups of switches, allowing configuration of up to four inputs.
20:                  //Switches for 
21:                  
22:                  uInt    inputSwitches, 
23:                          appStatus; //Holds error flags indicating app condition
24:                  void RunAppMain(void)
25:                  {
9D00FFCC  27BDFFE8   ADDIU SP, SP, -24
9D00FFD0  AFBF0014   SW RA, 20(SP)
9D00FFD4  AFBE0010   SW S8, 16(SP)
9D00FFD8  03A0F021   ADDU S8, SP, ZERO
26:                      if(appStatus == 0)
9D00FFDC  8F828190   LW V0, -32368(GP)
9D00FFE0  14400006   BNE V0, ZERO, 0x9D00FFFC
9D00FFE4  00000000   NOP
27:                      {
28:                          mPORTAToggleBits(BIT_0);
9D00FFE8  3C02BF88   LUI V0, -16504
9D00FFEC  24030001   ADDIU V1, ZERO, 1
9D00FFF0  AC43602C   SW V1, 24620(V0)
9D00FFF4  0B404003   J 0x9D01000C
9D00FFF8  00000000   NOP
29:                          //Switch run apps
30:                      
31:                      }
32:                      else SetMenuPage(RunErrorMenu);
9D00FFFC  3C029D01   LUI V0, -25343
9D010000  244400C0   ADDIU A0, V0, 192
9D010004  0F40173E   JAL SetMenuPage
9D010008  00000000   NOP
33:                      
34:                  
35:                  }
9D01000C  03C0E821   ADDU SP, S8, ZERO
9D010010  8FBF0014   LW RA, 20(SP)
9D010014  8FBE0010   LW S8, 16(SP)
9D010018  27BD0018   ADDIU SP, SP, 24
9D01001C  03E00008   JR RA
9D010020  00000000   NOP
36:                  void DisplayAppResults(char *CharBuff)
37:                  {
9D010024  27BDFFE0   ADDIU SP, SP, -32
9D010028  AFBF001C   SW RA, 28(SP)
9D01002C  AFBE0018   SW S8, 24(SP)
9D010030  03A0F021   ADDU S8, SP, ZERO
9D010034  AFC40020   SW A0, 32(S8)
38:                        SetColor(YELLOW);
9D010038  2402FFF0   ADDIU V0, ZERO, -16
9D01003C  A7828198   SH V0, -32360(GP)
39:                          LCDCenterString( -4, "Main Application Running");
9D010040  2404FFFC   ADDIU A0, ZERO, -4
9D010044  3C029D01   LUI V0, -25343
9D010048  24455918   ADDIU A1, V0, 22808
9D01004C  0F40338C   JAL LCDCenterString
9D010050  00000000   NOP
40:                         // SetColor(BLACK);
41:                          //LCDLineHome();
42:                          LCDClearLine(9);//JK This function Takes a lot of time
9D010054  24040009   ADDIU A0, ZERO, 9
9D010058  0F4031C2   JAL LCDClearLine
9D01005C  00000000   NOP
43:                          SetColor(YELLOW);
9D010060  2402FFF0   ADDIU V0, ZERO, -16
9D010064  A7828198   SH V0, -32360(GP)
44:                          sprintf(CharBuff,"Time is %d :%d : %d", Time.Hours, Time.Minutes, Time.Seconds);
9D010068  938281F0   LBU V0, -32272(GP)
9D01006C  00401821   ADDU V1, V0, ZERO
9D010070  938281F1   LBU V0, -32271(GP)
9D010074  938481F2   LBU A0, -32270(GP)
9D010078  AFA40010   SW A0, 16(SP)
9D01007C  8FC40020   LW A0, 32(S8)
9D010080  3C059D01   LUI A1, -25343
9D010084  24A55934   ADDIU A1, A1, 22836
9D010088  00603021   ADDU A2, V1, ZERO
9D01008C  00403821   ADDU A3, V0, ZERO
9D010090  0F40627D   JAL sprintf
9D010094  00000000   NOP
45:                          LCDCenterString( 4, CharBuff);
9D010098  24040004   ADDIU A0, ZERO, 4
9D01009C  8FC50020   LW A1, 32(S8)
9D0100A0  0F40338C   JAL LCDCenterString
9D0100A4  00000000   NOP
46:                          //WriteTerminalU1(CharBuff);
47:                  }
9D0100A8  03C0E821   ADDU SP, S8, ZERO
9D0100AC  8FBF001C   LW RA, 28(SP)
9D0100B0  8FBE0018   LW S8, 24(SP)
9D0100B4  27BD0020   ADDIU SP, SP, 32
9D0100B8  03E00008   JR RA
9D0100BC  00000000   NOP
48:                  char* RunErrorMenu(char* cBuff, char keyPress)
49:                  {
9D0100C0  27BDFFE8   ADDIU SP, SP, -24
9D0100C4  AFBF0014   SW RA, 20(SP)
9D0100C8  AFBE0010   SW S8, 16(SP)
9D0100CC  03A0F021   ADDU S8, SP, ZERO
9D0100D0  AFC40018   SW A0, 24(S8)
9D0100D4  00A01021   ADDU V0, A1, ZERO
9D0100D8  A3C2001C   SB V0, 28(S8)
50:                      if(keyPress < 0)
9D0100DC  83C2001C   LB V0, 28(S8)
9D0100E0  0441000A   BGEZ V0, 0x9D01010C
9D0100E4  00000000   NOP
51:                      {
52:                          sprintf(cBuff," !** Error Menu **!\r\n \
9D0100E8  8FC40018   LW A0, 24(S8)
9D0100EC  3C029D01   LUI V0, -25343
9D0100F0  24455948   ADDIU A1, V0, 22856
9D0100F4  2406005B   ADDIU A2, ZERO, 91
9D0100F8  0F405AA3   JAL 0x9D016A8C
9D0100FC  00000000   NOP
53:                  ** Press to Fix ** \
54:                  1-Sensor Errors\r\n \
55:                  2-Fluid Errors\r\n \
56:                  3-App Errors\r\n");
57:                          return cBuff;
9D010100  8FC20018   LW V0, 24(S8)
9D010104  0B40405E   J 0x9D010178
9D010108  00000000   NOP
58:                      }
59:                      if(keyPress == 1)
9D01010C  83C3001C   LB V1, 28(S8)
9D010110  24020001   ADDIU V0, ZERO, 1
9D010114  14620005   BNE V1, V0, 0x9D01012C
9D010118  00000000   NOP
60:                      {
61:                          SetMenuPage(ReportMenu);
9D01011C  3C029D01   LUI V0, -25343
9D010120  244403C0   ADDIU A0, V0, 960
9D010124  0F40173E   JAL SetMenuPage
9D010128  00000000   NOP
62:                      }
63:                      if(keyPress == 2)
9D01012C  83C3001C   LB V1, 28(S8)
9D010130  24020002   ADDIU V0, ZERO, 2
9D010134  14620005   BNE V1, V0, 0x9D01014C
9D010138  00000000   NOP
64:                      {
65:                          SetMenuPage(ConfigApps);
9D01013C  3C029D01   LUI V0, -25343
9D010140  24440280   ADDIU A0, V0, 640
9D010144  0F40173E   JAL SetMenuPage
9D010148  00000000   NOP
66:                      }
67:                      if(keyPress == 3)
9D01014C  83C3001C   LB V1, 28(S8)
9D010150  24020003   ADDIU V0, ZERO, 3
9D010154  14620005   BNE V1, V0, 0x9D01016C
9D010158  00000000   NOP
68:                      {
69:                          SetMenuPage(ConfigSystem);
9D01015C  3C029D01   LUI V0, -25343
9D010160  24440310   ADDIU A0, V0, 784
9D010164  0F40173E   JAL SetMenuPage
9D010168  00000000   NOP
70:                      }   
71:                      cBuff[0] = 0x00;
9D01016C  8FC20018   LW V0, 24(S8)
9D010170  A0400000   SB ZERO, 0(V0)
72:                      return cBuff;
9D010174  8FC20018   LW V0, 24(S8)
73:                  }
9D010178  03C0E821   ADDU SP, S8, ZERO
9D01017C  8FBF0014   LW RA, 20(SP)
9D010180  8FBE0010   LW S8, 16(SP)
9D010184  27BD0018   ADDIU SP, SP, 24
9D010188  03E00008   JR RA
9D01018C  00000000   NOP
74:                  char* AppMainMenu(char* cBuff, char keyPress)
75:                  {
9D010190  27BDFFE8   ADDIU SP, SP, -24
9D010194  AFBF0014   SW RA, 20(SP)
9D010198  AFBE0010   SW S8, 16(SP)
9D01019C  03A0F021   ADDU S8, SP, ZERO
9D0101A0  AFC40018   SW A0, 24(S8)
9D0101A4  00A01021   ADDU V0, A1, ZERO
9D0101A8  A3C2001C   SB V0, 28(S8)
76:                      if(keyPress < 0)
9D0101AC  83C2001C   LB V0, 28(S8)
9D0101B0  0441000A   BGEZ V0, 0x9D0101DC
9D0101B4  00000000   NOP
77:                      {
78:                          sprintf(cBuff," !** Main Menu **!\r\n \
9D0101B8  8FC40018   LW A0, 24(S8)
9D0101BC  3C029D01   LUI V0, -25343
9D0101C0  244559A4   ADDIU A1, V0, 22948
9D0101C4  2406004D   ADDIU A2, ZERO, 77
9D0101C8  0F405AA3   JAL 0x9D016A8C
9D0101CC  00000000   NOP
79:                  1-Reports\r\n \
80:                  2-Config Apps\r\n \
81:                  3-Config System\r\n \
82:                  4-Run App");
83:                          return cBuff;
9D0101D0  8FC20018   LW V0, 24(S8)
9D0101D4  0B40409A   J 0x9D010268
9D0101D8  00000000   NOP
84:                      }
85:                      if(keyPress == 1)
9D0101DC  83C3001C   LB V1, 28(S8)
9D0101E0  24020001   ADDIU V0, ZERO, 1
9D0101E4  14620005   BNE V1, V0, 0x9D0101FC
9D0101E8  00000000   NOP
86:                      {
87:                          SetMenuPage(ReportMenu);
9D0101EC  3C029D01   LUI V0, -25343
9D0101F0  244403C0   ADDIU A0, V0, 960
9D0101F4  0F40173E   JAL SetMenuPage
9D0101F8  00000000   NOP
88:                      }
89:                      if(keyPress == 2)
9D0101FC  83C3001C   LB V1, 28(S8)
9D010200  24020002   ADDIU V0, ZERO, 2
9D010204  14620005   BNE V1, V0, 0x9D01021C
9D010208  00000000   NOP
90:                      {
91:                          SetMenuPage(ConfigApps);
9D01020C  3C029D01   LUI V0, -25343
9D010210  24440280   ADDIU A0, V0, 640
9D010214  0F40173E   JAL SetMenuPage
9D010218  00000000   NOP
92:                      }
93:                      if(keyPress == 3)
9D01021C  83C3001C   LB V1, 28(S8)
9D010220  24020003   ADDIU V0, ZERO, 3
9D010224  14620005   BNE V1, V0, 0x9D01023C
9D010228  00000000   NOP
94:                      {
95:                          SetMenuPage(ConfigSystem);
9D01022C  3C029D01   LUI V0, -25343
9D010230  24440310   ADDIU A0, V0, 784
9D010234  0F40173E   JAL SetMenuPage
9D010238  00000000   NOP
96:                      } 
97:                      if(keyPress == 4)
9D01023C  83C3001C   LB V1, 28(S8)
9D010240  24020004   ADDIU V0, ZERO, 4
9D010244  14620005   BNE V1, V0, 0x9D01025C
9D010248  00000000   NOP
98:                      {
99:                          SetMenuPage(ConfigSystem);
9D01024C  3C029D01   LUI V0, -25343
9D010250  24440310   ADDIU A0, V0, 784
9D010254  0F40173E   JAL SetMenuPage
9D010258  00000000   NOP
100:                     }     
101:                     cBuff[0] = 0x00;
9D01025C  8FC20018   LW V0, 24(S8)
9D010260  A0400000   SB ZERO, 0(V0)
102:                     return cBuff;
9D010264  8FC20018   LW V0, 24(S8)
103:                 }
9D010268  03C0E821   ADDU SP, S8, ZERO
9D01026C  8FBF0014   LW RA, 20(SP)
9D010270  8FBE0010   LW S8, 16(SP)
9D010274  27BD0018   ADDIU SP, SP, 24
9D010278  03E00008   JR RA
9D01027C  00000000   NOP
104:                 /*
105:                  * 1 - report_mgr
106:                  * 2 - app_inputs
107:                  * 3 - app_main */
108:                 
109:                 char* ConfigApps(char* cBuff, char keyPress)
110:                 {
9D010280  27BDFFE8   ADDIU SP, SP, -24
9D010284  AFBF0014   SW RA, 20(SP)
9D010288  AFBE0010   SW S8, 16(SP)
9D01028C  03A0F021   ADDU S8, SP, ZERO
9D010290  AFC40018   SW A0, 24(S8)
9D010294  00A01021   ADDU V0, A1, ZERO
9D010298  A3C2001C   SB V0, 28(S8)
111:                     if(keyPress < 0)
9D01029C  83C2001C   LB V0, 28(S8)
9D0102A0  0441000A   BGEZ V0, 0x9D0102CC
9D0102A4  00000000   NOP
112:                     {
113:                         sprintf(cBuff," *Application Menu*\r\n \
9D0102A8  8FC40018   LW A0, 24(S8)
9D0102AC  3C029D01   LUI V0, -25343
9D0102B0  244559F4   ADDIU A1, V0, 23028
9D0102B4  2406004A   ADDIU A2, ZERO, 74
9D0102B8  0F405AA3   JAL 0x9D016A8C
9D0102BC  00000000   NOP
114:                 1-Config Fluid\r\n \
115:                 2-Config Sensors\r\n \
116:                 3-Config App\r\n \
117:                 ");
118:                         return cBuff;
9D0102C0  8FC20018   LW V0, 24(S8)
9D0102C4  0B4040BE   J 0x9D0102F8
9D0102C8  00000000   NOP
119:                     }
120:                     if(keyPress == 1)
121:                     {
122:                         //SetMenuPage(ConfigSensors);
123:                     }
124:                     if(keyPress ==2)
9D0102CC  83C3001C   LB V1, 28(S8)
9D0102D0  24020002   ADDIU V0, ZERO, 2
9D0102D4  14620005   BNE V1, V0, 0x9D0102EC
9D0102D8  00000000   NOP
125:                     {
126:                         SetMenuPage(WiFiConfigDHCP);
9D0102DC  3C029D01   LUI V0, -25343
9D0102E0  244465CC   ADDIU A0, V0, 26060
9D0102E4  0F40173E   JAL SetMenuPage
9D0102E8  00000000   NOP
127:                     }
128:                     cBuff[0] = 0x00;
9D0102EC  8FC20018   LW V0, 24(S8)
9D0102F0  A0400000   SB ZERO, 0(V0)
129:                     return cBuff;
9D0102F4  8FC20018   LW V0, 24(S8)
130:                 }
9D0102F8  03C0E821   ADDU SP, S8, ZERO
9D0102FC  8FBF0014   LW RA, 20(SP)
9D010300  8FBE0010   LW S8, 16(SP)
9D010304  27BD0018   ADDIU SP, SP, 24
9D010308  03E00008   JR RA
9D01030C  00000000   NOP
131:                 
132:                 char* ConfigSystem(char* cBuff, char keyPress)
133:                 {
9D010310  27BDFFE8   ADDIU SP, SP, -24
9D010314  AFBF0014   SW RA, 20(SP)
9D010318  AFBE0010   SW S8, 16(SP)
9D01031C  03A0F021   ADDU S8, SP, ZERO
9D010320  AFC40018   SW A0, 24(S8)
9D010324  00A01021   ADDU V0, A1, ZERO
9D010328  A3C2001C   SB V0, 28(S8)
134:                     if(keyPress < 0)
9D01032C  83C2001C   LB V0, 28(S8)
9D010330  0441000A   BGEZ V0, 0x9D01035C
9D010334  00000000   NOP
135:                     {
136:                         sprintf(cBuff," *Config System*\r\n \
9D010338  8FC40018   LW A0, 24(S8)
9D01033C  3C029D01   LUI V0, -25343
9D010340  24455A40   ADDIU A1, V0, 23104
9D010344  24060050   ADDIU A2, ZERO, 80
9D010348  0F405AA3   JAL 0x9D016A8C
9D01034C  00000000   NOP
137:                 1 - Config ADC\r\n \
138:                 2 - Config Time/Date \r\n \
139:                 3 - Pressure User\r\n");
140:                         return cBuff;
9D010350  8FC20018   LW V0, 24(S8)
9D010354  0B4040EA   J 0x9D0103A8
9D010358  00000000   NOP
141:                     }
142:                     if(keyPress == 1)
9D01035C  83C3001C   LB V1, 28(S8)
9D010360  24020001   ADDIU V0, ZERO, 1
9D010364  14620005   BNE V1, V0, 0x9D01037C
9D010368  00000000   NOP
143:                     {
144:                         SetMenuPage(ConfigSystemInputs);
9D01036C  3C029D01   LUI V0, -25343
9D010370  24447018   ADDIU A0, V0, 28696
9D010374  0F40173E   JAL SetMenuPage
9D010378  00000000   NOP
145:                     }
146:                     if(keyPress ==2)
9D01037C  83C3001C   LB V1, 28(S8)
9D010380  24020002   ADDIU V0, ZERO, 2
9D010384  14620005   BNE V1, V0, 0x9D01039C
9D010388  00000000   NOP
147:                     {
148:                         SetMenuPage(ConfigTimeDate);
9D01038C  3C029D01   LUI V0, -25343
9D010390  244429E4   ADDIU A0, V0, 10724
9D010394  0F40173E   JAL SetMenuPage
9D010398  00000000   NOP
149:                     }
150:                     cBuff[0] = 0x00;
9D01039C  8FC20018   LW V0, 24(S8)
9D0103A0  A0400000   SB ZERO, 0(V0)
151:                     return cBuff;
9D0103A4  8FC20018   LW V0, 24(S8)
152:                 }
9D0103A8  03C0E821   ADDU SP, S8, ZERO
9D0103AC  8FBF0014   LW RA, 20(SP)
9D0103B0  8FBE0010   LW S8, 16(SP)
9D0103B4  27BD0018   ADDIU SP, SP, 24
9D0103B8  03E00008   JR RA
9D0103BC  00000000   NOP
153:                 char* ReportMenu(char* cBuff, char keyPress)
154:                 {
9D0103C0  27BDFFE8   ADDIU SP, SP, -24
9D0103C4  AFBF0014   SW RA, 20(SP)
9D0103C8  AFBE0010   SW S8, 16(SP)
9D0103CC  03A0F021   ADDU S8, SP, ZERO
9D0103D0  AFC40018   SW A0, 24(S8)
9D0103D4  00A01021   ADDU V0, A1, ZERO
9D0103D8  A3C2001C   SB V0, 28(S8)
155:                     if(keyPress < 0)
9D0103DC  83C2001C   LB V0, 28(S8)
9D0103E0  0441000A   BGEZ V0, 0x9D01040C
9D0103E4  00000000   NOP
156:                     {
157:                         sprintf(cBuff," *Report Menu* \r\n \
9D0103E8  8FC40018   LW A0, 24(S8)
9D0103EC  3C029D01   LUI V0, -25343
9D0103F0  24455A90   ADDIU A1, V0, 23184
9D0103F4  2406004F   ADDIU A2, ZERO, 79
9D0103F8  0F405AA3   JAL 0x9D016A8C
9D0103FC  00000000   NOP
158:                 1 - Config ADC\r\n \
159:                 2 - Config Time/Date \r\n \
160:                 3 - Pressure User\r\n");
161:                         return cBuff;
9D010400  8FC20018   LW V0, 24(S8)
9D010404  0B404116   J 0x9D010458
9D010408  00000000   NOP
162:                     }
163:                     if(keyPress == 1)
9D01040C  83C3001C   LB V1, 28(S8)
9D010410  24020001   ADDIU V0, ZERO, 1
9D010414  14620005   BNE V1, V0, 0x9D01042C
9D010418  00000000   NOP
164:                     {
165:                         SetMenuPage(ConfigSystemInputs);
9D01041C  3C029D01   LUI V0, -25343
9D010420  24447018   ADDIU A0, V0, 28696
9D010424  0F40173E   JAL SetMenuPage
9D010428  00000000   NOP
166:                     }
167:                     if(keyPress ==2)
9D01042C  83C3001C   LB V1, 28(S8)
9D010430  24020002   ADDIU V0, ZERO, 2
9D010434  14620005   BNE V1, V0, 0x9D01044C
9D010438  00000000   NOP
168:                     {
169:                         SetMenuPage(ConfigTimeDate);
9D01043C  3C029D01   LUI V0, -25343
9D010440  244429E4   ADDIU A0, V0, 10724
9D010444  0F40173E   JAL SetMenuPage
9D010448  00000000   NOP
170:                     }
171:                     cBuff[0] = 0x00;
9D01044C  8FC20018   LW V0, 24(S8)
9D010450  A0400000   SB ZERO, 0(V0)
172:                     return cBuff;
9D010454  8FC20018   LW V0, 24(S8)
173:                 }
9D010458  03C0E821   ADDU SP, S8, ZERO
9D01045C  8FBF0014   LW RA, 20(SP)
9D010460  8FBE0010   LW S8, 16(SP)
9D010464  27BD0018   ADDIU SP, SP, 24
9D010468  03E00008   JR RA
9D01046C  00000000   NOP
174:                 void SetAppStatus(uInt State)
175:                 {
9D010470  27BDFFF8   ADDIU SP, SP, -8
9D010474  AFBE0004   SW S8, 4(SP)
9D010478  03A0F021   ADDU S8, SP, ZERO
9D01047C  AFC40008   SW A0, 8(S8)
176:                     appStatus |= State;
9D010480  8F838190   LW V1, -32368(GP)
9D010484  8FC20008   LW V0, 8(S8)
9D010488  00621025   OR V0, V1, V0
9D01048C  AF828190   SW V0, -32368(GP)
177:                 }
9D010490  03C0E821   ADDU SP, S8, ZERO
9D010494  8FBE0004   LW S8, 4(SP)
9D010498  27BD0008   ADDIU SP, SP, 8
9D01049C  03E00008   JR RA
9D0104A0  00000000   NOP
178:                 void ClearAppStatus(uInt State)
179:                 {
9D0104A4  27BDFFF8   ADDIU SP, SP, -8
9D0104A8  AFBE0004   SW S8, 4(SP)
9D0104AC  03A0F021   ADDU S8, SP, ZERO
9D0104B0  AFC40008   SW A0, 8(S8)
180:                     appStatus &= ~State;
9D0104B4  8FC20008   LW V0, 8(S8)
9D0104B8  00021827   NOR V1, ZERO, V0
9D0104BC  8F828190   LW V0, -32368(GP)
9D0104C0  00621024   AND V0, V1, V0
9D0104C4  AF828190   SW V0, -32368(GP)
181:                 }
9D0104C8  03C0E821   ADDU SP, S8, ZERO
9D0104CC  8FBE0004   LW S8, 4(SP)
9D0104D0  27BD0008   ADDIU SP, SP, 8
9D0104D4  03E00008   JR RA
9D0104D8  00000000   NOP
182:                 uShort CheckAppStatus(uInt State)
183:                 {
9D0104DC  27BDFFF8   ADDIU SP, SP, -8
9D0104E0  AFBE0004   SW S8, 4(SP)
9D0104E4  03A0F021   ADDU S8, SP, ZERO
9D0104E8  AFC40008   SW A0, 8(S8)
184:                     if(appStatus & State == State)
9D0104EC  8F828190   LW V0, -32368(GP)
9D0104F0  30420001   ANDI V0, V0, 1
9D0104F4  304200FF   ANDI V0, V0, 255
9D0104F8  10400004   BEQ V0, ZERO, 0x9D01050C
9D0104FC  00000000   NOP
185:                         return (uShort)1;
9D010500  24020001   ADDIU V0, ZERO, 1
9D010504  0B404144   J 0x9D010510
9D010508  00000000   NOP
186:                     else
187:                         return (uShort)0;
9D01050C  00001021   ADDU V0, ZERO, ZERO
188:                 }
9D010510  03C0E821   ADDU SP, S8, ZERO
9D010514  8FBE0004   LW S8, 4(SP)
9D010518  27BD0008   ADDIU SP, SP, 8
9D01051C  03E00008   JR RA
9D010520  00000000   NOP
---  C:/MC_XProjects/FC_APP/APP_SOURCE/app_inputs.c  ----------------------------------------------------
1:                   #include "../app_inputs.h"
2:                   #include "../app_includes.h"
3:                   
4:                   static char *meterTypeStrings[] = {"Turbine", "SquareRoot", "Linear", "Exponential"};
5:                   uChar meterType = 0;
6:                   /**********************************************************************************
7:                                                       SYSTEM INPUTS MANAGMENT
8:                    ***********************************************************************************/
9:                   char* ConfigSensors(char* cBuff, char keyPress)
10:                  {
9D013F18  27BDFFE8   ADDIU SP, SP, -24
9D013F1C  AFBF0014   SW RA, 20(SP)
9D013F20  AFBE0010   SW S8, 16(SP)
9D013F24  03A0F021   ADDU S8, SP, ZERO
9D013F28  AFC40018   SW A0, 24(S8)
9D013F2C  00A01021   ADDU V0, A1, ZERO
9D013F30  A3C2001C   SB V0, 28(S8)
11:                      if(keyPress < 0)
9D013F34  83C2001C   LB V0, 28(S8)
9D013F38  0441000A   BGEZ V0, 0x9D013F64
9D013F3C  00000000   NOP
12:                      {
13:                          sprintf(cBuff,"!* Config Input Flow As: *!\r\n \
9D013F40  8FC40018   LW A0, 24(S8)
9D013F44  3C029D01   LUI V0, -25343
9D013F48  24455778   ADDIU A1, V0, 22392
9D013F4C  24060077   ADDIU A2, ZERO, 119
9D013F50  0F405AA3   JAL 0x9D016A8C
9D013F54  00000000   NOP
14:                  \t1 - Turbine Meter\r\n \
15:                  \t2 - Square Root Meter\r\n \
16:                  \t3 - Linear Meter\r\n \
17:                  \t4 - Exponintial Meter");
18:                          return cBuff;
9D013F58  8FC20018   LW V0, 24(S8)
9D013F5C  0B404FEC   J 0x9D013FB0
9D013F60  00000000   NOP
19:                      }
20:                      if(keyPress == 1)
9D013F64  83C3001C   LB V1, 28(S8)
9D013F68  24020001   ADDIU V0, ZERO, 1
9D013F6C  14620005   BNE V1, V0, 0x9D013F84
9D013F70  00000000   NOP
21:                      {
22:                          SetMenuPage(ConfigSensors);
9D013F74  3C029D01   LUI V0, -25343
9D013F78  24443F18   ADDIU A0, V0, 16152
9D013F7C  0F40173E   JAL SetMenuPage
9D013F80  00000000   NOP
23:                      }
24:                      if(keyPress ==2)
9D013F84  83C3001C   LB V1, 28(S8)
9D013F88  24020002   ADDIU V0, ZERO, 2
9D013F8C  14620005   BNE V1, V0, 0x9D013FA4
9D013F90  00000000   NOP
25:                      {
26:                          SetMenuPage(WiFiConfigDHCP);
9D013F94  3C029D01   LUI V0, -25343
9D013F98  244465CC   ADDIU A0, V0, 26060
9D013F9C  0F40173E   JAL SetMenuPage
9D013FA0  00000000   NOP
27:                      }
28:                      cBuff[0] = 0x00;
9D013FA4  8FC20018   LW V0, 24(S8)
9D013FA8  A0400000   SB ZERO, 0(V0)
29:                      return cBuff;
9D013FAC  8FC20018   LW V0, 24(S8)
30:                  }
9D013FB0  03C0E821   ADDU SP, S8, ZERO
9D013FB4  8FBF0014   LW RA, 20(SP)
9D013FB8  8FBE0010   LW S8, 16(SP)
9D013FBC  27BD0018   ADDIU SP, SP, 24
9D013FC0  03E00008   JR RA
9D013FC4  00000000   NOP
31:                  
32:                  //Called from App_Main
33:                  char* FlowMeterConfig(char* cBuff, char keyPress)
34:                  {
9D013FC8  27BDFFE8   ADDIU SP, SP, -24
9D013FCC  AFBF0014   SW RA, 20(SP)
9D013FD0  AFBE0010   SW S8, 16(SP)
9D013FD4  03A0F021   ADDU S8, SP, ZERO
9D013FD8  AFC40018   SW A0, 24(S8)
9D013FDC  00A01021   ADDU V0, A1, ZERO
9D013FE0  A3C2001C   SB V0, 28(S8)
35:                      if(keyPress < 0)
9D013FE4  83C2001C   LB V0, 28(S8)
9D013FE8  04410011   BGEZ V0, 0x9D014030
9D013FEC  00000000   NOP
36:                      {
37:                          sprintf(cBuff,"!** Config Flow Meter **!\r\n \
9D013FF0  93828068   LBU V0, -32664(GP)
9D013FF4  00401821   ADDU V1, V0, ZERO
9D013FF8  3C02A000   LUI V0, -24576
9D013FFC  00031880   SLL V1, V1, 2
9D014000  244210D0   ADDIU V0, V0, 4304
9D014004  00621021   ADDU V0, V1, V0
9D014008  8C420000   LW V0, 0(V0)
9D01400C  8FC40018   LW A0, 24(S8)
9D014010  3C039D01   LUI V1, -25343
9D014014  246557F0   ADDIU A1, V1, 22512
9D014018  00403021   ADDU A2, V0, ZERO
9D01401C  0F40627D   JAL sprintf
9D014020  00000000   NOP
38:                  \t%s Meter \r\n \
39:                  \t1 - Change Type\r\n \
40:                  \t2 - Config Meter\r\n", meterTypeStrings[meterType]);
41:                          return cBuff;
9D014024  8FC20018   LW V0, 24(S8)
9D014028  0B40501F   J 0x9D01407C
9D01402C  00000000   NOP
42:                      }
43:                      if(keyPress == 1)
9D014030  83C3001C   LB V1, 28(S8)
9D014034  24020001   ADDIU V0, ZERO, 1
9D014038  14620005   BNE V1, V0, 0x9D014050
9D01403C  00000000   NOP
44:                      {
45:                          SetMenuPage(ChangeFlowMeterType);
9D014040  3C029D01   LUI V0, -25343
9D014044  24444094   ADDIU A0, V0, 16532
9D014048  0F40173E   JAL SetMenuPage
9D01404C  00000000   NOP
46:                      }
47:                      if(keyPress ==2)
9D014050  83C3001C   LB V1, 28(S8)
9D014054  24020002   ADDIU V0, ZERO, 2
9D014058  14620005   BNE V1, V0, 0x9D014070
9D01405C  00000000   NOP
48:                      {
49:                          SetMenuPage(ConfigMeter);
9D014060  3C029D01   LUI V0, -25343
9D014064  24444120   ADDIU A0, V0, 16672
9D014068  0F40173E   JAL SetMenuPage
9D01406C  00000000   NOP
50:                      }
51:                      cBuff[0] = 0x00;
9D014070  8FC20018   LW V0, 24(S8)
9D014074  A0400000   SB ZERO, 0(V0)
52:                      return cBuff;
9D014078  8FC20018   LW V0, 24(S8)
53:                  }
9D01407C  03C0E821   ADDU SP, S8, ZERO
9D014080  8FBF0014   LW RA, 20(SP)
9D014084  8FBE0010   LW S8, 16(SP)
9D014088  27BD0018   ADDIU SP, SP, 24
9D01408C  03E00008   JR RA
9D014090  00000000   NOP
54:                  
55:                  
56:                  char* ChangeFlowMeterType(char* MenuBuff, char KeyPress )
57:                  {
9D014094  27BDFFE8   ADDIU SP, SP, -24
9D014098  AFBF0014   SW RA, 20(SP)
9D01409C  AFBE0010   SW S8, 16(SP)
9D0140A0  03A0F021   ADDU S8, SP, ZERO
9D0140A4  AFC40018   SW A0, 24(S8)
9D0140A8  00A01021   ADDU V0, A1, ZERO
9D0140AC  A3C2001C   SB V0, 28(S8)
58:                      if(KeyPress < 0)
9D0140B0  83C2001C   LB V0, 28(S8)
9D0140B4  0441000A   BGEZ V0, 0x9D0140E0
9D0140B8  00000000   NOP
59:                      {
60:                          sprintf(MenuBuff,"*Change Meter Type *\r\n \
9D0140BC  8FC40018   LW A0, 24(S8)
9D0140C0  3C029D01   LUI V0, -25343
9D0140C4  24455840   ADDIU A1, V0, 22592
9D0140C8  24060069   ADDIU A2, ZERO, 105
9D0140CC  0F405AA3   JAL 0x9D016A8C
9D0140D0  00000000   NOP
61:                  \t1 - Turbine\r\n \
62:                  \t2 - Linear\r\n \
63:                  \t3 - Square Root\r\n \
64:                  \t4 - Exponent\r\n \
65:                  \t5 - No Change\r\n ");
66:                          return MenuBuff;
9D0140D4  8FC20018   LW V0, 24(S8)
9D0140D8  0B405042   J 0x9D014108
9D0140DC  00000000   NOP
67:                      }  
68:                      if(KeyPress <= 5) meterType = KeyPress;
9D0140E0  83C2001C   LB V0, 28(S8)
9D0140E4  28420006   SLTI V0, V0, 6
9D0140E8  10400003   BEQ V0, ZERO, 0x9D0140F8
9D0140EC  00000000   NOP
9D0140F0  93C2001C   LBU V0, 28(S8)
9D0140F4  A3828068   SB V0, -32664(GP)
69:                      SetMenuPage(FlowMeterConfig);
9D0140F8  3C029D01   LUI V0, -25343
9D0140FC  24443FC8   ADDIU A0, V0, 16328
9D014100  0F40173E   JAL SetMenuPage
9D014104  00000000   NOP
70:                  
71:                  }
9D014108  03C0E821   ADDU SP, S8, ZERO
9D01410C  8FBF0014   LW RA, 20(SP)
9D014110  8FBE0010   LW S8, 16(SP)
9D014114  27BD0018   ADDIU SP, SP, 24
9D014118  03E00008   JR RA
9D01411C  00000000   NOP
72:                  char* ConfigMeter(char *MenuBuff, char KeyPress)
73:                  {
9D014120  27BDFFE8   ADDIU SP, SP, -24
9D014124  AFBF0014   SW RA, 20(SP)
9D014128  AFBE0010   SW S8, 16(SP)
9D01412C  03A0F021   ADDU S8, SP, ZERO
9D014130  AFC40018   SW A0, 24(S8)
9D014134  00A01021   ADDU V0, A1, ZERO
9D014138  A3C2001C   SB V0, 28(S8)
74:                    if(KeyPress < 0)
9D01413C  83C2001C   LB V0, 28(S8)
9D014140  0441000A   BGEZ V0, 0x9D01416C
9D014144  00000000   NOP
75:                      {
76:                          sprintf(MenuBuff," *Change Meter Type *\r\n \
9D014148  8FC40018   LW A0, 24(S8)
9D01414C  3C029D01   LUI V0, -25343
9D014150  244558AC   ADDIU A1, V0, 22700
9D014154  2406006A   ADDIU A2, ZERO, 106
9D014158  0F405AA3   JAL 0x9D016A8C
9D01415C  00000000   NOP
77:                  \t1 - Turbine\r\n \
78:                  \t2 - Linear\r\n \
79:                  \t3 - Square Root\r\n \
80:                  \t4 - Exponent\r\n \
81:                  \t5 - No Change\r\n ");
82:                          return MenuBuff;
9D014160  8FC20018   LW V0, 24(S8)
9D014164  0B405065   J 0x9D014194
9D014168  00000000   NOP
83:                      }
84:                      if(KeyPress <= 5) meterType = KeyPress;
9D01416C  83C2001C   LB V0, 28(S8)
9D014170  28420006   SLTI V0, V0, 6
9D014174  10400003   BEQ V0, ZERO, 0x9D014184
9D014178  00000000   NOP
9D01417C  93C2001C   LBU V0, 28(S8)
9D014180  A3828068   SB V0, -32664(GP)
85:                      SetMenuPage(FlowMeterConfig);
9D014184  3C029D01   LUI V0, -25343
9D014188  24443FC8   ADDIU A0, V0, 16328
9D01418C  0F40173E   JAL SetMenuPage
9D014190  00000000   NOP
86:                  
87:                  }
9D014194  03C0E821   ADDU SP, S8, ZERO
9D014198  8FBF0014   LW RA, 20(SP)
9D01419C  8FBE0010   LW S8, 16(SP)
9D0141A0  27BD0018   ADDIU SP, SP, 24
9D0141A4  03E00008   JR RA
9D0141A8  00000000   NOP
88:                  
89:                  /**********************************************************************************
90:                                                    PRESSURE METER MANAGMENT SECTION
91:                   ***********************************************************************************/
92:                  
---  C:/MC_XProjects/FCX_MB0/main.c  --------------------------------------------------------------------
1:                   /****************************************************************************
2:                   *   CREATED BY:     Stillbright Managment LLC
3:                   *                   Copyright 2012
4:                   *                                                                           
5:                   *   FILE:           main.c                                                 
6:                   *                                                                           
7:                   *   DESCRIPTION:    Templet for PIC33
8:                   *					        
9:                   *                                                                           
10:                  *   REVISION    8/20/2010 Created
11:                  *               9/9/2012 -  Added a switch to run the application file.
12:                   *              10/22/12 -  Copied this file from FC_33.x folder and converted 
13:                   *                          it to run on PIC33
14:                   *  
15:                  ****************************************************************************/
16:                  
17:                   /***************************************************************************
18:                   * Description:
19:                   *			The example code demonstrates using PIC32 core timer, core timer 
20:                   *          interrupt and interrupt service routine to blink LED1 10 times a second.
21:                   *
22:                   * Additional Info: 
23:                   *			Refer to readme.txt
24:                   *
25:                   * Platforms:
26:                   *			PIC32MX Starter Kit DM320001
27:                   *			PIC32MX USB Starter Kit DM320003
28:                   *
29:                   * Tools:
30:                   *			1. MPLAB IDE 8.20 or higher
31:                   *			2. MPLAB C Compiler for PIC32 v1.04 or higher
32:                   *			3. General Purpose Starter Kit DM320001 or USB Starter board DM320003
33:                   *			4. USB Cable
34:                   *
35:                   * Debug Print Library: SUPPORTED IN DEBUG MODE ONLY
36:                   *			The Debug Print Library adds user debugging input/output capability
37:                   *          to the MPLAB IDE Starter Kit console window using DBPRINTF, DPUTS,
38:                   *          DBGETC and DBGETS.
39:                   *
40:                   *          To use the Debug Print Library with the PIC32 Starter Kit, do the following:
41:                   *			1. Add '#include "db_utils.h"' to the source code.
42:                   *			   Note: you may need to copy db_utils.h into your working directory or
43:                   *			   specify a path to its location.
44:                   *			   It is located in "<install dir>\PIC32 Starter Kits\Microchip\Include".
45:                   *			2. Add 'db_utils.a' to the library branch of MPLAB IDE project tree.
46:                   *			   It is located in "<install dir>\PIC32 Starter Kits\Microchip\Common"
47:                   *			3. Add "PIC32_STARTER_KIT" macro definition to the project build options
48:                   *			   for the C compiler.
49:                   *			4. Be sure to call DBINIT() first before any other Debug Print Library macros.
50:                   *
51:                   * Starter Board Resources:
52:                   *			LED1 (RED)	= PORTD.RD0
53:                   *			LED2 (YELLOW)	= PORTD.RD1
54:                   *			LED3 (GREEN)	= PORTD.RD2
55:                   *			SW1		= PORTD.RD6  (change notice pin CN15)
56:                   *			SW2		= PORTD.RD7     (change notice pin CN16)
57:                   *			SW3		= PORTD.RD13 (change notice pin CN19)
58:                   *			JTAG.TMS	= PORTA.RA0  (used by debugger)
59:                   *			JTAG.TCK	= PORTA.RA1  (used by debugger)
60:                   *			JTAG.TDO	= PORTA.RA5  (used by debugger)
61:                   *			JTAG.TDI	= PORTA.RA4  (used by debugger)
62:                   *			PGC2		= PORTB.RB6  (used by debugger)
63:                   *			PGD2		= PORTB.RB7  (used by debugger)
64:                   *
65:                   * Starter Board Notes:
66:                   *			1.	There are no pullup resistors on SW1, SW2 or SW3.
67:                   *				To enable the PORTD pullups for SW1, SW2 and SW3, use the following:
68:                   *				CNPUE = (CN15_PULLUP_ENABLE | CN16_PULLUP_ENABLE | CN19_PULLUP_ENABLE);
69:                   *			2.  Do not disable the PIC32MX JTAG.  This will prevent the PIC32MX Starter Kit
70:                   *				debugger(PIC18F4550) from communicating with the PIC32MX device.
71:                   *			3.  Do not configure the SYSTEM CLOCK to operate faster than 80MHz.
72:                   *************************************************************************************
73:                   * Change History:
74:                   * ID			Date            Changes
75:                   * C11842		12/01/2008		Modified for 80MHz operation, Updated comments.
76:                   *************************************************************************************/
77:                  
78:                  // Adds support for PIC32 Peripheral library functions and macros
79:                  #include "../LIBS/SYS_LIB/sysglobals.h"
80:                  #include <plib.h>
81:                  #include <GenericTypeDefs.h>
82:                  #include <../include/peripheral/ports.h>
83:                  //#include <../include/peripheral/timer.h>
84:                  #include "../MMB/MMB.h"
85:                  
86:                  #include "../Microhip/Include/Graphics/DisplayDriver.h"
87:                  #include cpuSFRegisters
88:                  #include "../LIBS/MENUS_LIB/tMenus.h"
89:                  #include "../LIBS/SYS_LIB/uarts.h"
90:                  #include "../LIBS/SYS_LIB/systime_date.h"
91:                  #include "../LIBS/SYS_LIB/lcd_interface.h"
92:                  #include "../LIBS/SYS_LIB/TouchScreen.h"
93:                  #include "../FC_APP/app_globals.h"
94:                  #include "../FC_APP/app_main.h"
95:                  #include "../LIBS/MODBUS_LIB/modbus.h"
96:                  
97:                  
98:                  
99:                  // ****************  Define System Variables **************************
100:                 volatile uInt MachineState;
101:                 
102:                 uShort  mSecB4Blink,
103:                         rxResult,
104:                         secTillMenuReset = 30,  //Seconds remaining before UART reverts to idle mode
105:                         mSecTillMBReset = 10,  //mSeconds remaining before UART reverts to idle mode
106:                         secondFlag;
107:                 //volatile uInt CommTimeout = 1;  //CommTimeout * 10mSec = Time before rxReset
108:                 uInt  errCount = 0, ErrorFlags = 0;         
109:                 uInt Indian = 0xA1B2;// Datasheet says PIC33 is Little Indian
110:                 
111:                 //int main(void);
112:                 char    touchBusy = 0,
113:                         menuOn, //Menu is on the screen
114:                         rxKey = 0, *tempString ;
115:                 /******************************************************************************************
116:                 **                                RECEIVE AND TRANSMIT BUFFERS
117:                  * There will be only one TX buffer for each data type.  These will be shared
118:                  * by the different modules.  The idea being that with only a single UART, there can
119:                  * only be one TX event in process at a time                                           **
120:                 ********************************************************************************************/
121:                 uChar   MasterID = DEFAULT_ID;	//= 100
122:                 char    uartFlag = 0;
123:                 
124:                 
125:                     //**************** ------------------------- *********************
126:                 //char testBuff[] = "JK Hello";
127:                 int main()
128:                 {
9D010F54  27BDFFE8   ADDIU SP, SP, -24
9D010F58  AFBF0014   SW RA, 20(SP)
9D010F5C  AFBE0010   SW S8, 16(SP)
9D010F60  03A0F021   ADDU S8, SP, ZERO
129:                     
130:                     InitSysTime(); //10mSec timout For Clock Timout
9D010F64  0F404AA5   JAL InitSysTime
9D010F68  00000000   NOP
131:                     //.//////////////////////// The buffer for the UART is in uart.h///////
132:                     //Buffer for UART1 defined as char U1Buffer[U1_BUFFSZ=128]; in uart.h
133:                     InitUART1(DefaultBAUD);	//UnitID, Baudrate, timout in mSec
9D010F6C  3404E100   ORI A0, ZERO, -7936
9D010F70  0F40232A   JAL InitUART1
9D010F74  00000000   NOP
134:                 MB_Buffer[0] = 8;
9D010F78  3C02A000   LUI V0, -24576
9D010F7C  24030008   ADDIU V1, ZERO, 8
9D010F80  A44303A4   SH V1, 932(V0)
135:                 MB_Buffer[1] = 9;
9D010F84  3C02A000   LUI V0, -24576
9D010F88  244203A4   ADDIU V0, V0, 932
9D010F8C  24030009   ADDIU V1, ZERO, 9
9D010F90  A4430002   SH V1, 2(V0)
136:                 MB_Buffer[2] = 10;
9D010F94  3C02A000   LUI V0, -24576
9D010F98  244203A4   ADDIU V0, V0, 932
9D010F9C  2403000A   ADDIU V1, ZERO, 10
9D010FA0  A4430004   SH V1, 4(V0)
137:                     //InitDigitals_PIC32MX();
138:                 LoadNVArray();
9D010FA4  0F404841   JAL LoadNVArray
9D010FA8  00000000   NOP
139:                 WriteDefaults2NVMemory(3);
9D010FAC  24040003   ADDIU A0, ZERO, 3
9D010FB0  0F40490B   JAL WriteDefaults2NVMemory
9D010FB4  00000000   NOP
140:                 NVMemory2MBReg(4001,3,MB_Buffer);
9D010FB8  24040FA1   ADDIU A0, ZERO, 4001
9D010FBC  24050003   ADDIU A1, ZERO, 3
9D010FC0  3C02A000   LUI V0, -24576
9D010FC4  244603A4   ADDIU A2, V0, 932
9D010FC8  0F4048E3   JAL NVMemory2MBReg
9D010FCC  00000000   NOP
141:                     /*///////////////////////////////////////////////////////////////////
142:                      ///////////  char ScreenBuff[128] is defined in tMenus.h /////////
143:                      ///////////////////////////////////////////////////////////////////*/
144:                     InitMenuStartPage(AppMainMenu);//Found in app_main.c
9D010FD0  3C029D01   LUI V0, -25343
9D010FD4  24440190   ADDIU A0, V0, 400
9D010FD8  0F401707   JAL InitMenuStartPage
9D010FDC  00000000   NOP
145:                     InitSPI1MemBus();
9D010FE0  0F402ECA   JAL InitSPI1MemBus
9D010FE4  00000000   NOP
146:                     //InitRamtron();
147:                     //This the comment I added on 1/6/12 to test tortouse 
148:                     MachineState = sys_IDLE; // Start state machine is idle mode
9D010FE8  AF808278   SW ZERO, -32136(GP)
149:                     // Test NV Memory
150:                     WriteStringU1("\x1B[2J\x1B[H Next line should be 'Hello World'\r\n");
9D010FEC  3C029D02   LUI V0, -25342
9D010FF0  24428AA8   ADDIU V0, V0, -30040
9D010FF4  00402021   ADDU A0, V0, ZERO
9D010FF8  0F402480   JAL WriteStringU1
9D010FFC  00000000   NOP
151:                     //WriteRTChars(100,12,"Hello World");
152:                     //ReadRTChars(100,12,nvMemBuff);
153:                     RT_WriteChars(0x1111, 12, "Hello Modbus");
9D011000  3C029D02   LUI V0, -25342
9D011004  24428AD4   ADDIU V0, V0, -29996
9D011008  24041111   ADDIU A0, ZERO, 4369
9D01100C  2405000C   ADDIU A1, ZERO, 12
9D011010  00403021   ADDU A2, V0, ZERO
9D011014  0F4030C1   JAL RT_WriteChars
9D011018  00000000   NOP
154:                     RT_ReadChars(0x1111, 12, nvCharBuffer);
9D01101C  24041111   ADDIU A0, ZERO, 4369
9D011020  2405000C   ADDIU A1, ZERO, 12
9D011024  3C02A000   LUI V0, -24576
9D011028  24460878   ADDIU A2, V0, 2168
9D01102C  0F403120   JAL RT_ReadChars
9D011030  00000000   NOP
155:                 
156:                     nvCharBuffer[13] = NULL;
9D011034  3C02A000   LUI V0, -24576
9D011038  24420878   ADDIU V0, V0, 2168
9D01103C  A040000D   SB ZERO, 13(V0)
157:                     
158:                     // End test NV memory 
159:                 // TODO 's: add if(uart.IF == 1)
160:                     MMBInit();          // initialize the MikroE MMB board
9D011040  0F401FA7   JAL MMBInit
9D011044  00000000   NOP
161:                     LCDInit();
9D011048  0F403212   JAL LCDInit
9D01104C  00000000   NOP
162:                     LCDClear();
9D011050  0F4031E3   JAL LCDClear
9D011054  00000000   NOP
163:                     TouchInit();
9D011058  0F403BFC   JAL TouchInit
9D01105C  00000000   NOP
164:                     EEPROMInit();
9D011060  0F403CC1   JAL EEPROMInit
9D011064  00000000   NOP
165:                     TouchLoadCalibration();   
9D011068  0F403C9F   JAL TouchLoadCalibration
9D01106C  00000000   NOP
166:                     
167:                     //MMBFadeIn( 1000);
168:                     BacklightOn();
9D011070  3C03BF88   LUI V1, -16504
9D011074  8C6260E0   LW V0, 24800(V1)
9D011078  24040001   ADDIU A0, ZERO, 1
9D01107C  7C821084   INS V0, A0, 2, 1
9D011080  AC6260E0   SW V0, 24800(V1)
169:                     SetColor(BRIGHTRED);
9D011084  2402F800   ADDIU V0, ZERO, -2048
9D011088  A7828198   SH V0, -32360(GP)
170:                     //SetColor(BRIGHTRED);
171:                     WriteStringU1("StillBright Managment LLC");
9D01108C  3C029D02   LUI V0, -25342
9D011090  24428AE4   ADDIU V0, V0, -29980
9D011094  00402021   ADDU A0, V0, ZERO
9D011098  0F402480   JAL WriteStringU1
9D01109C  00000000   NOP
172:                     LCDCenterString( -0, "StillBright Managment LLC");
9D0110A0  00002021   ADDU A0, ZERO, ZERO
9D0110A4  3C029D02   LUI V0, -25342
9D0110A8  24458AE4   ADDIU A1, V0, -29980
9D0110AC  0F40338C   JAL LCDCenterString
9D0110B0  00000000   NOP
173:                     //LCDCenterString( 1, "(Touch 1 For Menu)");
174:                     LCDCenterString( 1, nvCharBuffer);
9D0110B4  3C02A000   LUI V0, -24576
9D0110B8  24420878   ADDIU V0, V0, 2168
9D0110BC  24040001   ADDIU A0, ZERO, 1
9D0110C0  00402821   ADDU A1, V0, ZERO
9D0110C4  0F40338C   JAL LCDCenterString
9D0110C8  00000000   NOP
175:                     WriteDefaults2NVMemory(3);
9D0110CC  24040003   ADDIU A0, ZERO, 3
9D0110D0  0F40490B   JAL WriteDefaults2NVMemory
9D0110D4  00000000   NOP
176:                     menuOn = 1;
9D0110D8  24020001   ADDIU V0, ZERO, 1
9D0110DC  A382827C   SB V0, -32132(GP)
177:                     MasterID = 1;
9D0110E0  24020001   ADDIU V0, ZERO, 1
9D0110E4  A3828024   SB V0, -32732(GP)
178:                     secTillMenuReset = 5;
9D0110E8  24020005   ADDIU V0, ZERO, 5
9D0110EC  A782801C   SH V0, -32740(GP)
179:                     BuildTouchPad(StartPad,BRIGHTRED);
9D0110F0  3C02A000   LUI V0, -24576
9D0110F4  24440A34   ADDIU A0, V0, 2612
9D0110F8  3405F800   ORI A1, ZERO, -2048
9D0110FC  0F402DCC   JAL BuildTouchPad
9D011100  00000000   NOP
9D011104  0B404444   J 0x9D011110
9D011108  00000000   NOP
180:                     while(1)
181:                     {
182:                         //0x01 0x03 0x4E 0x20 0x00 0x01 0x92 0xE8
183:                         if(U1STAbits.URXDA)
9D011110  3C02BF80   LUI V0, -16512
9D011114  8C426010   LW V0, 24592(V0)
9D011118  30420001   ANDI V0, V0, 1
9D01111C  10400025   BEQ V0, ZERO, 0x9D0111B4
9D011120  00000000   NOP
184:                         {
185:                             //Capture results from UART read
186:                             rxResult = ReadU1AsSlave(U1Buffer, rxResult);
9D011124  97828274   LHU V0, -32140(GP)
9D011128  3C03A000   LUI V1, -24576
9D01112C  246407F8   ADDIU A0, V1, 2040
9D011130  00402821   ADDU A1, V0, ZERO
9D011134  0F402372   JAL ReadU1AsSlave
9D011138  00000000   NOP
9D01113C  A7828274   SH V0, -32140(GP)
187:                             //The UART captured part of a potential MB cmd and
188:                             //is now waiting on the rest of it. The countdown to reset
189:                             //has started.  If no more bytes forthcomming then reset
190:                             if(rxResult == RXMB_WAITING)
9D011140  97838274   LHU V1, -32140(GP)
9D011144  24020010   ADDIU V0, ZERO, 16
9D011148  14620003   BNE V1, V0, 0x9D011158
9D01114C  00000000   NOP
191:                             {
192:                                  //MBReset comes from UART.h to allow menus to configure value
193:                                  //Default value is 10 mSec
194:                                  mSecTillMBReset = MSEC_TILL_MB_RESET;
9D011150  2402000A   ADDIU V0, ZERO, 10
9D011154  A782801E   SH V0, -32738(GP)
195:                             };
196:                             //The UART has receive one or two ESC chars and is now diverting
197:                             //all RX data to the menu module.  The countdown to reset
198:                             //has started.  If no more bytes forthcomming then reset
199:                             if(rxResult == RXMENU_ACTIVE)//0x0080
9D011158  97838274   LHU V1, -32140(GP)
9D01115C  24020080   ADDIU V0, ZERO, 128
9D011160  1462000E   BNE V1, V0, 0x9D01119C
9D011164  00000000   NOP
200:                             {
201:                                 LCDClear();
9D011168  0F4031E3   JAL LCDClear
9D01116C  00000000   NOP
202:                                 secTillMenuReset = SEC_TILL_MENU_RESET;
9D011170  2402000F   ADDIU V0, ZERO, 15
9D011174  A782801C   SH V0, -32740(GP)
203:                                 tempString = RunMenu(U1Buffer);
9D011178  3C02A000   LUI V0, -24576
9D01117C  244407F8   ADDIU A0, V0, 2040
9D011180  0F4011EF   JAL RunMenu
9D011184  00000000   NOP
9D011188  AF828284   SW V0, -32124(GP)
204:                                 //WriteStringU1(UartBuff);
205:                                 WriteTerminalU1(U1Buffer);
9D01118C  3C02A000   LUI V0, -24576
9D011190  244407F8   ADDIU A0, V0, 2040
9D011194  0F4024C6   JAL WriteTerminalU1
9D011198  00000000   NOP
206:                                 //MachineState |= sys_MENU_ACTIVE;
207:                             };
208:                             //The UART has captured one ESC char, we will wait 2 sec for the next
209:                             if(rxResult == RXMENU_STARTING) secTillMenuReset = 2;
9D01119C  97838274   LHU V1, -32140(GP)
9D0111A0  24020040   ADDIU V0, ZERO, 64
9D0111A4  14620003   BNE V1, V0, 0x9D0111B4
9D0111A8  00000000   NOP
9D0111AC  24020002   ADDIU V0, ZERO, 2
9D0111B0  A782801C   SH V0, -32740(GP)
210:                    
211:                         }
212:                         if((MachineState & sys_SCREENTOUCHED) == sys_SCREENTOUCHED)
9D0111B4  8F828278   LW V0, -32136(GP)
9D0111B8  30421000   ANDI V0, V0, 4096
9D0111BC  10400013   BEQ V0, ZERO, 0x9D01120C
9D0111C0  00000000   NOP
213:                         {
214:                             LCDClear();
9D0111C4  0F4031E3   JAL LCDClear
9D0111C8  00000000   NOP
215:                             secTillMenuReset = SEC_TILL_MENU_RESET;
9D0111CC  2402000F   ADDIU V0, ZERO, 15
9D0111D0  A782801C   SH V0, -32740(GP)
216:                             tempString = GetTouchPress(ScreenBuff);
9D0111D4  3C02A000   LUI V0, -24576
9D0111D8  244402FC   ADDIU A0, V0, 764
9D0111DC  0F402E5D   JAL GetTouchPress
9D0111E0  00000000   NOP
9D0111E4  AF828284   SW V0, -32124(GP)
217:                             tempString = RunMenu(ScreenBuff);
9D0111E8  3C02A000   LUI V0, -24576
9D0111EC  244402FC   ADDIU A0, V0, 764
9D0111F0  0F4011EF   JAL RunMenu
9D0111F4  00000000   NOP
9D0111F8  AF828284   SW V0, -32124(GP)
218:                             //if the cmd came in the UART, send back out the UART
219:                             //TODO: Make menu return 1 if there is a response    
220:                             MachineState &= ~ sys_SCREENTOUCHED;
9D0111FC  8F838278   LW V1, -32136(GP)
9D011200  2402EFFF   ADDIU V0, ZERO, -4097
9D011204  00621024   AND V0, V1, V0
9D011208  AF828278   SW V0, -32136(GP)
221:                         }
222:                         // sys_CHCKSYSTEM is enabled from systime_date.c in SYS_LIB
223:                         // it is enabled every 1 sec.
224:                         if((MachineState & sys_RUNAPP) == sys_RUNAPP)
9D01120C  8F828278   LW V0, -32136(GP)
9D011210  30420200   ANDI V0, V0, 512
9D011214  1040002B   BEQ V0, ZERO, 0x9D0112C4
9D011218  00000000   NOP
225:                         {
226:                             if(!CheckAppStatus(app_CHECK_ALL_ERRORS)) RunAppMain();
9D01121C  2404FFFF   ADDIU A0, ZERO, -1
9D011220  0F404137   JAL CheckAppStatus
9D011224  00000000   NOP
9D011228  14400003   BNE V0, ZERO, 0x9D011238
9D01122C  00000000   NOP
9D011230  0F403FF3   JAL RunAppMain
9D011234  00000000   NOP
227:                             //This flag is set if the UART is in Menu mode
228:                             //if no user interaction after user configured seconds
229:                             //any menus on screen are cleared, a button is built to
230:                             //recall menu and the application is allowed to display results
231:                        
232:                             if(secTillMenuReset > 0)
9D011238  9782801C   LHU V0, -32740(GP)
9D01123C  10400019   BEQ V0, ZERO, 0x9D0112A4
9D011240  00000000   NOP
233:                             {
234:                                 secTillMenuReset--;
9D011244  9782801C   LHU V0, -32740(GP)
9D011248  2442FFFF   ADDIU V0, V0, -1
9D01124C  3042FFFF   ANDI V0, V0, -1
9D011250  A782801C   SH V0, -32740(GP)
235:                                 if(secTillMenuReset <= 0)
9D011254  9782801C   LHU V0, -32740(GP)
9D011258  14400016   BNE V0, ZERO, 0x9D0112B4
9D01125C  00000000   NOP
236:                                 {
237:                                     //Turn whole screen into a button
238:                                     BuildTouchPad(StartPad,BLACK);
9D011260  3C02A000   LUI V0, -24576
9D011264  24440A34   ADDIU A0, V0, 2612
9D011268  00002821   ADDU A1, ZERO, ZERO
9D01126C  0F402DCC   JAL BuildTouchPad
9D011270  00000000   NOP
239:                                     LCDClear();
9D011274  0F4031E3   JAL LCDClear
9D011278  00000000   NOP
240:                                     rxResult = RX_IDLE;
9D01127C  A7808274   SH ZERO, -32140(GP)
241:                                     secTillMenuReset = 0;
9D011280  A780801C   SH ZERO, -32740(GP)
242:                                     ResetMenu();//Clear the exit menu flag so that menu does not immediately exit on entrance
9D011284  0F4011E4   JAL ResetMenu
9D011288  00000000   NOP
243:                                     ResetMBU1(U1Buffer);//Put MB back to IDLE mode
9D01128C  3C02A000   LUI V0, -24576
9D011290  244407F8   ADDIU A0, V0, 2040
9D011294  0F402363   JAL ResetMBU1
9D011298  00000000   NOP
9D01129C  0B4044AD   J 0x9D0112B4
9D0112A0  00000000   NOP
244:                                 }
245:                             }
246:                             else DisplayAppResults(ScreenBuff);
9D0112A4  3C02A000   LUI V0, -24576
9D0112A8  244402FC   ADDIU A0, V0, 764
9D0112AC  0F404009   JAL DisplayAppResults
9D0112B0  00000000   NOP
247:                             MachineState &= ~sys_RUNAPP;
9D0112B4  8F838278   LW V1, -32136(GP)
9D0112B8  2402FDFF   ADDIU V0, ZERO, -513
9D0112BC  00621024   AND V0, V1, V0
9D0112C0  AF828278   SW V0, -32136(GP)
248:                         }
249:                         // sys_CHCKSYSTEM is enabled from systime_date.c in SYS_LIB
250:                         // it is enabled every 1mS
251:                         if((MachineState & sys_CHCKSYSTEM) == sys_CHCKSYSTEM) //Every 1mSec
9D0112C4  8F828278   LW V0, -32136(GP)
9D0112C8  30420001   ANDI V0, V0, 1
9D0112CC  304200FF   ANDI V0, V0, 255
9D0112D0  1040FF8E   BEQ V0, ZERO, 0x9D01110C
9D0112D4  00000000   NOP
252:                         {
253:                             if(mSecB4Blink++ >= 125)
9D0112D8  9782827E   LHU V0, -32130(GP)
9D0112DC  2C43007D   SLTIU V1, V0, 125
9D0112E0  38630001   XORI V1, V1, 1
9D0112E4  306300FF   ANDI V1, V1, 255
9D0112E8  24420001   ADDIU V0, V0, 1
9D0112EC  3042FFFF   ANDI V0, V0, -1
9D0112F0  A782827E   SH V0, -32130(GP)
9D0112F4  10600005   BEQ V1, ZERO, 0x9D01130C
9D0112F8  00000000   NOP
254:                             {
255:                                 mPORTAToggleBits(BIT_1);
9D0112FC  3C02BF88   LUI V0, -16504
9D011300  24030002   ADDIU V1, ZERO, 2
9D011304  AC43602C   SW V1, 24620(V0)
256:                                 mSecB4Blink = 0;
9D011308  A780827E   SH ZERO, -32130(GP)
257:                             }
258:                             if(mSecTillMBReset > 0)
9D01130C  9782801E   LHU V0, -32738(GP)
9D011310  1040000C   BEQ V0, ZERO, 0x9D011344
9D011314  00000000   NOP
259:                             {
260:                                 mSecTillMBReset--;
9D011318  9782801E   LHU V0, -32738(GP)
9D01131C  2442FFFF   ADDIU V0, V0, -1
9D011320  3042FFFF   ANDI V0, V0, -1
9D011324  A782801E   SH V0, -32738(GP)
261:                                 if(mSecTillMBReset <= 0) ResetMBU1(ScreenBuff);
9D011328  9782801E   LHU V0, -32738(GP)
9D01132C  14400005   BNE V0, ZERO, 0x9D011344
9D011330  00000000   NOP
9D011334  3C02A000   LUI V0, -24576
9D011338  244402FC   ADDIU A0, V0, 764
9D01133C  0F402363   JAL ResetMBU1
9D011340  00000000   NOP
262:                             }
263:                             if(secondFlag != Time.Seconds)
9D011344  938281F2   LBU V0, -32270(GP)
9D011348  00401821   ADDU V1, V0, ZERO
9D01134C  97828280   LHU V0, -32128(GP)
9D011350  10620006   BEQ V1, V0, 0x9D01136C
9D011354  00000000   NOP
264:                             {
265:                                 secondFlag = Time.Seconds;         
9D011358  938281F2   LBU V0, -32270(GP)
9D01135C  A7828280   SH V0, -32128(GP)
266:                                 MachineState |= sys_RUNAPP;
9D011360  8F828278   LW V0, -32136(GP)
9D011364  34420200   ORI V0, V0, 512
9D011368  AF828278   SW V0, -32136(GP)
267:                             }
268:                             RunTouchScreen();  //Check if screen has been touched
9D01136C  0F403A99   JAL RunTouchScreen
9D011370  00000000   NOP
269:                             if(ADCGetX() >= 0)
9D011374  97828014   LHU V0, -32748(GP)
9D011378  7C021620   SEH V0, V0
9D01137C  0440000D   BLTZ V0, 0x9D0113B4
9D011380  00000000   NOP
270:                             {
271:                                 if(touchBusy == 0)//Minimize double touch
9D011384  83828128   LB V0, -32472(GP)
9D011388  1440000B   BNE V0, ZERO, 0x9D0113B8
9D01138C  00000000   NOP
272:                                 {
273:                                     MachineState |= sys_SCREENTOUCHED;
9D011390  8F828278   LW V0, -32136(GP)
9D011394  34421000   ORI V0, V0, 4096
9D011398  AF828278   SW V0, -32136(GP)
274:                                     touchBusy = 1; //Lockout touch screen until press is finished
9D01139C  24020001   ADDIU V0, ZERO, 1
9D0113A0  A3828128   SB V0, -32472(GP)
275:                                     secTillMenuReset  = 5;
9D0113A4  24020005   ADDIU V0, ZERO, 5
9D0113A8  A782801C   SH V0, -32740(GP)
9D0113AC  0B4044EE   J 0x9D0113B8
9D0113B0  00000000   NOP
276:                                 }             
277:                             }
278:                             else touchBusy = 0;
9D0113B4  A3808128   SB ZERO, -32472(GP)
279:                             MachineState &= ~sys_CHCKSYSTEM;
9D0113B8  8F838278   LW V1, -32136(GP)
9D0113BC  2402FFFE   ADDIU V0, ZERO, -2
9D0113C0  00621024   AND V0, V1, V0
9D0113C4  AF828278   SW V0, -32136(GP)
280:                         }
281:                     }
9D01110C  00000000   NOP
9D0113C8  0B404444   J 0x9D011110
9D0113CC  00000000   NOP
282:                     return 0;    
283:                 };
284:                 //Called by RunMenu in tMenus.h
285:                 void ExitMenus(void)
286:                 {
9D0113D0  27BDFFE8   ADDIU SP, SP, -24
9D0113D4  AFBF0014   SW RA, 20(SP)
9D0113D8  AFBE0010   SW S8, 16(SP)
9D0113DC  03A0F021   ADDU S8, SP, ZERO
287:                     BuildTouchPad(StartPad,BLACK);
9D0113E0  3C02A000   LUI V0, -24576
9D0113E4  24440A34   ADDIU A0, V0, 2612
9D0113E8  00002821   ADDU A1, ZERO, ZERO
9D0113EC  0F402DCC   JAL BuildTouchPad
9D0113F0  00000000   NOP
288:                     LCDClear();
9D0113F4  0F4031E3   JAL LCDClear
9D0113F8  00000000   NOP
289:                     rxResult = RX_IDLE;
9D0113FC  A7808274   SH ZERO, -32140(GP)
290:                     secTillMenuReset = 0;
9D011400  A780801C   SH ZERO, -32740(GP)
291:                     ResetMenu();//Clear the exit menu flag so that menu does not immediately exit on entrance
9D011404  0F4011E4   JAL ResetMenu
9D011408  00000000   NOP
292:                     ResetMBU1(ScreenBuff);//Put MB back to IDLE mode
9D01140C  3C02A000   LUI V0, -24576
9D011410  244402FC   ADDIU A0, V0, 764
9D011414  0F402363   JAL ResetMBU1
9D011418  00000000   NOP
293:                 }
9D01141C  03C0E821   ADDU SP, S8, ZERO
9D011420  8FBF0014   LW RA, 20(SP)
9D011424  8FBE0010   LW S8, 16(SP)
9D011428  27BD0018   ADDIU SP, SP, 24
9D01142C  03E00008   JR RA
9D011430  00000000   NOP
294:                 	/*	
295:                 
296:                  void __attribute__((interrupt, auto_psv)) _IC1Interrupt(void)
297:                 {
298:                 	
299:                 		PORTD++;
300:                 		//PORTD = 4;
301:                 		PORTD --;
302:                 		//Interrupt Service Routine code goes here         
303:                 }
304:                 */	  
305:                 
306:                 
307:                 
308:                 
309:                 
---  C:/MC_XProjects/FCX_MB0/exceptions.c  --------------------------------------------------------------
1:                   /******************************************************************************/
2:                   /* Files to Include                                                           */
3:                   /******************************************************************************/
4:                   
5:                   #include <plib.h>            /* Include to use PIC32 peripheral libraries     */
6:                   #include <stdint.h>          /* For uint32_t definition                       */
7:                   #include <stdbool.h>         /* For true/false definition                     */
8:                   
9:                   /******************************************************************************/
10:                  /* Exception Macro Definitions                                                */
11:                  /******************************************************************************/
12:                  
13:                  /*When WRITE_EXCEPTION_CAUSE_TO_FLASH is defined the PIC32 executes a self
14:                  write routine to save the exception cause register.*/
15:                  
16:                  /* #define WRITE_EXCEPTION_CAUSE_TO_FLASH */
17:                  
18:                  #ifdef WRITE_EXCEPTION_CAUSE_TO_FLASH
19:                  
20:                  /* Physical Addresses which are at the end of KSEG 0 program memory. */
21:                  /* User may want to adjust these values */
22:                  #define EXCEPTION_CAUSE 0x1D007FFC
23:                  #define EXCEPTION_ADDR  0x1D007FF8
24:                  
25:                  #endif
26:                  
27:                  /******************************************************************************/
28:                  /* Exception Variable Declaration                                             */
29:                  /******************************************************************************/
30:                  
31:                  /* static in case exception condition would stop auto variable being created  */
32:                  static enum {
33:                      EXCEP_IRQ = 0,           /* interrupt */
34:                      EXCEP_AdEL = 4,          /* address error exception (load or ifetch) */
35:                      EXCEP_AdES,              /* address error exception (store) */
36:                      EXCEP_IBE,               /* bus error (ifetch) */
37:                      EXCEP_DBE,               /* bus error (load/store) */
38:                      EXCEP_Sys,               /* syscall */
39:                      EXCEP_Bp,                /* breakpoint */
40:                      EXCEP_RI,                /* reserved instruction */
41:                      EXCEP_CpU,               /* coprocessor unusable */
42:                      EXCEP_Overflow,          /* arithmetic overflow */
43:                      EXCEP_Trap,              /* trap (possible divide by zero) */
44:                      EXCEP_IS1 = 16,          /* implementation specfic 1 */
45:                      EXCEP_CEU,               /* CorExtend Unuseable */
46:                      EXCEP_C2E                /* coprocessor 2 */
47:                  } _excep_code;
48:                  
49:                  /* static in case exception condition would stop auto variable being created */
50:                  static unsigned int _epc_code;
51:                  static unsigned int _excep_addr;
52:                  
53:                  /******************************************************************************/
54:                  /* Exception Handling                                                         */
55:                  /******************************************************************************/
56:                  
57:                  /* This function overrides the normal _weak_ _generic_exception_handler which
58:                  is defined in the C32 User's Guide.  The _weak_ _generic_exception_handler
59:                  just does an infinite loop. */
60:                  void _general_exception_handler(void)
61:                  {
9D018D8C  27BDFFF0   ADDIU SP, SP, -16
9D018D90  AFBE000C   SW S8, 12(SP)
9D018D94  03A0F021   ADDU S8, SP, ZERO
62:                      unsigned long t0 = _CP0_GET_COUNT(); /* Used for NVMOP 6 us Delay */
9D018D98  40024800   MFC0 V0, Count
9D018D9C  AFC20000   SW V0, 0(S8)
63:                  
64:                      /* Mask off Mask of the ExcCode Field from the Cause Register
65:                      Refer to the MIPs M4K Software User's manual */
66:                      _excep_code=_CP0_GET_CAUSE() & 0x0000007C >> 2;
9D018DA0  40026800   MFC0 V0, Cause
9D018DA4  3042001F   ANDI V0, V0, 31
9D018DA8  AF828110   SW V0, -32496(GP)
67:                      _excep_addr=_CP0_GET_EPC();
9D018DAC  40027000   MFC0 V0, EPC
9D018DB0  AF828118   SW V0, -32488(GP)
68:                  
69:                      _CP0_SET_STATUS(_CP0_GET_STATUS()&0xFFFFFFE); /* Disable Interrupts */
9D018DB4  40036000   MFC0 V1, Status
9D018DB8  3C020FFF   LUI V0, 4095
9D018DBC  3442FFFE   ORI V0, V0, -2
9D018DC0  00621024   AND V0, V1, V0
9D018DC4  40826000   MTC0 V0, Status
9D018DC8  000000C0   EHB
70:                  
71:                  #ifdef WRITE_EXCEPTION_CAUSE_TO_FLASH
72:                  
73:                      /* Store the exception causes in program memory in case the part exhibited
74:                      the problem in release mode.  Gives user a place to start debugging
75:                      the problem. */
76:                  
77:                      NVMCON = 0x4001;            /* set WREN and Word Programing mode */
78:                      NVMADDR = EXCEPTION_CAUSE;  /* PM Address at which we'll store the */
79:                                                  /* cause register */
80:                      NVMDATA   = _excep_code;
81:                  
82:                      /* wait at least 6 us for LVD start-up
83:                      assume we're running at max frequency
84:                      (80 MHz) so we're always safe */
85:                      {
86:                          while (_CP0_GET_COUNT() - t0 < (80/2)*6);
87:                      }
88:                  
89:                      NVMKEY    = 0xAA996655;
90:                      NVMKEY    = 0x556699AA;     /* unlock sequence */
91:                      NVMCONSET = NVMCON_WR;
92:                      while(NVMCON & NVMCON_WR);  /* wait on write to finish */
93:                  
94:                      NVMCON = 0x4001;            /* set WREN and Word Programing mode */
95:                      NVMADDR = EXCEPTION_ADDR;   /* PM Address at which we'll store the */
96:                                                  /* exception address register */
97:                      NVMDATA   = _excep_addr;
98:                  
99:                      /* wait at least 6 us for LVD start-up
100:                     assume we're running at max frequency
101:                     (80 MHz) so we're always safe */
102:                     {
103:                         while (_CP0_GET_COUNT() - t0 < (80/2)*6);
104:                     }
105:                 
106:                     NVMKEY    = 0xAA996655;
107:                     NVMKEY    = 0x556699AA;     /* unlock sequence */
108:                     NVMCONSET = NVMCON_WR;
109:                     while(NVMCON & NVMCON_WR);
110:                 
111:                     /* Write the exception cause and address to the part can be read and
112:                     the cause determined. */
113:                     NVMWriteWord((void*)EXCEPTION_CAUSE, _excep_code);
114:                     NVMWriteWord((void*)EXCEPTION_ADDR, _excep_addr);
115:                 
116:                 #endif
117:                 
118:                     while (1)
119:                     {
120:                         /* Examine _excep_code to identify the type of exception */
121:                         /* Examine _excep_addr to find the address that caused the exception */
122:                     }
9D018DCC  0B406373   J 0x9D018DCC
9D018DD0  00000000   NOP
123:                 }
---  /build/xc32/gcc/libgcc2.c  -------------------------------------------------------------------------
9D011434  00C04021   ADDU T0, A2, ZERO
9D011894  00C01021   ADDU V0, A2, ZERO
9D011438  00804821   ADDU T1, A0, ZERO
9D011898  00804021   ADDU T0, A0, ZERO
9D01143C  14E0003B   BNE A3, ZERO, 0x9D01152C
9D011440  00A01821   ADDU V1, A1, ZERO
9D01189C  14E0003D   BNE A3, ZERO, 0x9D011994
9D0118A0  00A01821   ADDU V1, A1, ZERO
9D011444  00A6102B   SLTU V0, A1, A2
9D011448  10400048   BEQ V0, ZERO, 0x9D01156C
9D01144C  70C21020   CLZ V0, A2
9D0118A4  00A6302B   SLTU A2, A1, A2
9D0118A8  10C00046   BEQ A2, ZERO, 0x9D0119C4
9D0118AC  00000000   NOP
9D0118B0  70442020   CLZ A0, V0
9D011450  50400008   BEQL V0, ZERO, 0x9D011474
9D011454  00083402   SRL A2, T0, 16
9D0118B4  10800008   BEQ A0, ZERO, 0x9D0118D8
9D0118B8  00022C02   SRL A1, V0, 16
9D011464  00464004   SLLV T0, A2, V0
9D0118C8  00821004   SLLV V0, V0, A0
9D011458  00022023   SUBU A0, ZERO, V0
9D01145C  00892006   SRLV A0, T1, A0
9D011460  00451804   SLLV V1, A1, V0
9D011468  00831825   OR V1, A0, V1
9D0118BC  00042823   SUBU A1, ZERO, A0
9D0118C0  00A82806   SRLV A1, T0, A1
9D0118C4  00831804   SLLV V1, V1, A0
9D0118CC  00A31825   OR V1, A1, V1
9D01146C  00494804   SLLV T1, T1, V0
9D0118D0  00884004   SLLV T0, T0, A0
9D011470  00083402   SRL A2, T0, 16
9D011474  0066001B   DIVU V1, A2
9D011478  00C001F4   TEQ A2, ZERO
9D01147C  310CFFFF   ANDI T4, T0, -1
9D011480  00092402   SRL A0, T1, 16
9D011484  00005812   MFLO T3
9D011488  00005010   MFHI T2
9D01148C  000A5400   SLL T2, T2, 16
9D011490  01445025   OR T2, T2, A0
9D011494  716C5802   MUL T3, T3, T4
9D011498  014B682B   SLTU T5, T2, T3
9D01149C  0066001B   DIVU V1, A2
9D0114A0  00C001F4   TEQ A2, ZERO
9D0114A4  51A00009   BEQL T5, ZERO, 0x9D0114CC
9D0114A8  014B5023   SUBU T2, T2, T3
9D0114AC  01485021   ADDU T2, T2, T0
9D0114B0  0148182B   SLTU V1, T2, T0
9D0114B4  54600005   BNEL V1, ZERO, 0x9D0114CC
9D0114B8  014B5023   SUBU T2, T2, T3
9D0114BC  014B182B   SLTU V1, T2, T3
9D0114C0  70682002   MUL A0, V1, T0
9D0114C4  008A5021   ADDU T2, A0, T2
9D0114C8  014B5023   SUBU T2, T2, T3
9D0114CC  0146001B   DIVU T2, A2
9D0114D0  00C001F4   TEQ A2, ZERO
9D0114D4  3129FFFF   ANDI T1, T1, -1
9D0114D8  00002012   MFLO A0
9D0114DC  00001810   MFHI V1
9D0114E0  00031C00   SLL V1, V1, 16
9D0114E4  00694825   OR T1, V1, T1
9D0114E8  708C2002   MUL A0, A0, T4
9D0114EC  0124182B   SLTU V1, T1, A0
9D0114F0  0146001B   DIVU T2, A2
9D0114F4  00C001F4   TEQ A2, ZERO
9D0114F8  50600009   BEQL V1, ZERO, 0x9D011520
9D0114FC  01244823   SUBU T1, T1, A0
9D011500  01284821   ADDU T1, T1, T0
9D011504  0128182B   SLTU V1, T1, T0
9D011508  54600005   BNEL V1, ZERO, 0x9D011520
9D01150C  01244823   SUBU T1, T1, A0
9D011510  0124182B   SLTU V1, T1, A0
9D011514  70682802   MUL A1, V1, T0
9D011518  00A94821   ADDU T1, A1, T1
9D01151C  01244823   SUBU T1, T1, A0
9D0118D4  00022C02   SRL A1, V0, 16
9D0118D8  0065001B   DIVU V1, A1
9D0118DC  00A001F4   TEQ A1, ZERO
9D0118E0  304AFFFF   ANDI T2, V0, -1
9D0118E4  00085C02   SRL T3, T0, 16
9D0118E8  00004812   MFLO T1
9D0118EC  00003810   MFHI A3
9D0118F0  00073C00   SLL A3, A3, 16
9D0118F4  00EB3825   OR A3, A3, T3
9D0118F8  712A2002   MUL A0, T1, T2
9D0118FC  00E4302B   SLTU A2, A3, A0
9D011900  0065001B   DIVU V1, A1
9D011904  00A001F4   TEQ A1, ZERO
9D011908  10C0000B   BEQ A2, ZERO, 0x9D011938
9D01190C  00E41823   SUBU V1, A3, A0
9D011910  00E23821   ADDU A3, A3, V0
9D011914  00E2182B   SLTU V1, A3, V0
9D011918  14600006   BNE V1, ZERO, 0x9D011934
9D01191C  2529FFFF   ADDIU T1, T1, -1
9D011920  00E4182B   SLTU V1, A3, A0
9D011924  10600004   BEQ V1, ZERO, 0x9D011938
9D011928  00E41823   SUBU V1, A3, A0
9D01192C  2529FFFF   ADDIU T1, T1, -1
9D011930  00E23821   ADDU A3, A3, V0
9D011934  00E41823   SUBU V1, A3, A0
9D011938  0065001B   DIVU V1, A1
9D01193C  00A001F4   TEQ A1, ZERO
9D011940  3108FFFF   ANDI T0, T0, -1
9D011944  00002012   MFLO A0
9D011948  00003010   MFHI A2
9D01194C  00063400   SLL A2, A2, 16
9D011950  00C84025   OR T0, A2, T0
9D011954  708A5002   MUL T2, A0, T2
9D011958  010A302B   SLTU A2, T0, T2
9D01195C  0065001B   DIVU V1, A1
9D011960  00A001F4   TEQ A1, ZERO
9D011964  10C00006   BEQ A2, ZERO, 0x9D011980
9D011968  01024021   ADDU T0, T0, V0
9D01196C  0102102B   SLTU V0, T0, V0
9D011970  14400003   BNE V0, ZERO, 0x9D011980
9D011974  2484FFFF   ADDIU A0, A0, -1
9D011978  010A502B   SLTU T2, T0, T2
9D01197C  008A2023   SUBU A0, A0, T2
9D011980  00094C00   SLL T1, T1, 16
9D011984  00892025   OR A0, A0, T1
9D011988  00001821   ADDU V1, ZERO, ZERO
9D01156C  14C00006   BNE A2, ZERO, 0x9D011588
9D011570  71021020   CLZ V0, T0
9D0119C4  14400006   BNE V0, ZERO, 0x9D0119E0
9D0119C8  70463020   CLZ A2, V0
9D011574  24020001   ADDIU V0, ZERO, 1
9D011578  0046001B   DIVU V0, A2
9D01157C  00C001F4   TEQ A2, ZERO
9D011580  00004012   MFLO T0
9D0119CC  24030001   ADDIU V1, ZERO, 1
9D0119D0  0062001B   DIVU V1, V0
9D0119D4  004001F4   TEQ V0, ZERO
9D0119D8  00001012   MFLO V0
9D011584  71021020   CLZ V0, T0
9D0119DC  70463020   CLZ A2, V0
9D011588  5440007C   BNEL V0, ZERO, 0x9D01177C
9D01158C  24090020   ADDIU T1, ZERO, 32
9D0119E0  54C00077   BNEL A2, ZERO, 0x9D011BC0
9D0119E4  24080020   ADDIU T0, ZERO, 32
9D011590  00A82823   SUBU A1, A1, T0
9D011594  00081C02   SRL V1, T0, 16
9D011598  3107FFFF   ANDI A3, T0, -1
9D0119E8  00A24823   SUBU T1, A1, V0
9D0119EC  00023C02   SRL A3, V0, 16
9D0119F0  304CFFFF   ANDI T4, V0, -1
9D0119F4  24030001   ADDIU V1, ZERO, 1
9D01177C  01224823   SUBU T1, T1, V0
9D011BC4  01064023   SUBU T0, T0, A2
9D011780  00484004   SLLV T0, T0, V0
9D011BC0  00C21004   SLLV V0, V0, A2
9D011784  01253006   SRLV A2, A1, T1
9D011BC8  01055006   SRLV T2, A1, T0
9D011798  01245806   SRLV T3, A0, T1
9D01179C  00452804   SLLV A1, A1, V0
9D0117A0  01655825   OR T3, T3, A1
9D011BD8  01044006   SRLV T0, A0, T0
9D011BDC  00C52804   SLLV A1, A1, A2
9D011BE4  01052825   OR A1, T0, A1
9D0117A8  00444804   SLLV T1, A0, V0
9D011BE8  00C44004   SLLV T0, A0, A2
9D011788  00081C02   SRL V1, T0, 16
9D01178C  00C3001B   DIVU A2, V1
9D011790  006001F4   TEQ V1, ZERO
9D011794  3107FFFF   ANDI A3, T0, -1
9D0117A4  000B2C02   SRL A1, T3, 16
9D0117AC  00005012   MFLO T2
9D0117B0  00006010   MFHI T4
9D0117B4  000C2400   SLL A0, T4, 16
9D0117B8  00A42025   OR A0, A1, A0
9D0117BC  71475002   MUL T2, T2, A3
9D0117C0  008A282B   SLTU A1, A0, T2
9D0117C4  00C3001B   DIVU A2, V1
9D0117C8  006001F4   TEQ V1, ZERO
9D0117CC  50A00006   BEQL A1, ZERO, 0x9D0117E8
9D0117D0  008A2023   SUBU A0, A0, T2
9D0117D4  00882021   ADDU A0, A0, T0
9D0117D8  0088282B   SLTU A1, A0, T0
9D0117DC  10A00024   BEQ A1, ZERO, 0x9D011870
9D0117E0  008A282B   SLTU A1, A0, T2
9D0117E4  008A2023   SUBU A0, A0, T2
9D0117E8  0083001B   DIVU A0, V1
9D0117EC  006001F4   TEQ V1, ZERO
9D0117F0  316BFFFF   ANDI T3, T3, -1
9D0117F4  00003012   MFLO A2
9D0117F8  00002810   MFHI A1
9D0117FC  00052C00   SLL A1, A1, 16
9D011800  00AB2825   OR A1, A1, T3
9D011804  70C73002   MUL A2, A2, A3
9D011808  00A6502B   SLTU T2, A1, A2
9D01180C  0083001B   DIVU A0, V1
9D011810  006001F4   TEQ V1, ZERO
9D011814  5140FF61   BEQL T2, ZERO, 0x9D01159C
9D011818  00A62823   SUBU A1, A1, A2
9D01181C  00A82821   ADDU A1, A1, T0
9D011820  00A8202B   SLTU A0, A1, T0
9D011824  5480FF5D   BNEL A0, ZERO, 0x9D01159C
9D011828  00A62823   SUBU A1, A1, A2
9D01182C  00A6202B   SLTU A0, A1, A2
9D011830  70885002   MUL T2, A0, T0
9D011834  01452821   ADDU A1, T2, A1
9D011838  0B404567   J 0x9D01159C
9D01183C  00A62823   SUBU A1, A1, A2
9D011870  70A83002   MUL A2, A1, T0
9D011874  0B4045F9   J 0x9D0117E4
9D011878  00C42021   ADDU A0, A2, A0
9D011BCC  00023C02   SRL A3, V0, 16
9D011BD0  0147001B   DIVU T2, A3
9D011BD4  00E001F4   TEQ A3, ZERO
9D011BE0  304CFFFF   ANDI T4, V0, -1
9D011BEC  00054C02   SRL T1, A1, 16
9D011BF0  00001812   MFLO V1
9D011BF4  00005810   MFHI T3
9D011BF8  000B2400   SLL A0, T3, 16
9D011BFC  01242025   OR A0, T1, A0
9D011C00  00003012   MFLO A2
9D011C04  706C1802   MUL V1, V1, T4
9D011C08  0083482B   SLTU T1, A0, V1
9D011C0C  0147001B   DIVU T2, A3
9D011C10  00E001F4   TEQ A3, ZERO
9D011C14  5120000B   BEQL T1, ZERO, 0x9D011C44
9D011C18  00832023   SUBU A0, A0, V1
9D011C1C  00822021   ADDU A0, A0, V0
9D011C20  0082482B   SLTU T1, A0, V0
9D011C24  15200006   BNE T1, ZERO, 0x9D011C40
9D011C28  24C6FFFF   ADDIU A2, A2, -1
9D011C2C  0083482B   SLTU T1, A0, V1
9D011C30  51200004   BEQL T1, ZERO, 0x9D011C44
9D011C34  00832023   SUBU A0, A0, V1
9D011C38  24C6FFFF   ADDIU A2, A2, -1
9D011C3C  00822021   ADDU A0, A0, V0
9D011C40  00832023   SUBU A0, A0, V1
9D011C44  0087001B   DIVU A0, A3
9D011C48  00E001F4   TEQ A3, ZERO
9D011C4C  30AAFFFF   ANDI T2, A1, -1
9D011C50  00001812   MFLO V1
9D011C54  00004810   MFHI T1
9D011C58  00094C00   SLL T1, T1, 16
9D011C5C  012A4825   OR T1, T1, T2
9D011C60  706C2802   MUL A1, V1, T4
9D011C64  0125502B   SLTU T2, T1, A1
9D011C68  0087001B   DIVU A0, A3
9D011C6C  00E001F4   TEQ A3, ZERO
9D011C70  5140000B   BEQL T2, ZERO, 0x9D011CA0
9D011C74  00063400   SLL A2, A2, 16
9D011C78  01224821   ADDU T1, T1, V0
9D011C7C  0122202B   SLTU A0, T1, V0
9D011C80  14800006   BNE A0, ZERO, 0x9D011C9C
9D011C84  2463FFFF   ADDIU V1, V1, -1
9D011C88  0125202B   SLTU A0, T1, A1
9D011C8C  50800004   BEQL A0, ZERO, 0x9D011CA0
9D011C90  00063400   SLL A2, A2, 16
9D011C94  2463FFFF   ADDIU V1, V1, -1
9D011C98  01224821   ADDU T1, T1, V0
9D011C9C  00063400   SLL A2, A2, 16
9D011CA0  01254823   SUBU T1, T1, A1
9D011CA4  0B40467E   J 0x9D0119F8
9D011CA8  00661825   OR V1, V1, A2
9D01159C  00A3001B   DIVU A1, V1
9D0115A0  006001F4   TEQ V1, ZERO
9D0115A4  00095402   SRL T2, T1, 16
9D0115A8  00002012   MFLO A0
9D0115AC  00003010   MFHI A2
9D0115B0  00063400   SLL A2, A2, 16
9D0115B4  00CA3025   OR A2, A2, T2
9D0115B8  70872002   MUL A0, A0, A3
9D0115BC  00C4502B   SLTU T2, A2, A0
9D0115C0  00A3001B   DIVU A1, V1
9D0115C4  006001F4   TEQ V1, ZERO
9D0115C8  51400009   BEQL T2, ZERO, 0x9D0115F0
9D0115CC  00C43023   SUBU A2, A2, A0
9D0115D0  00C83021   ADDU A2, A2, T0
9D0115D4  00C8282B   SLTU A1, A2, T0
9D0115D8  54A00005   BNEL A1, ZERO, 0x9D0115F0
9D0115DC  00C43023   SUBU A2, A2, A0
9D0115E0  00C4282B   SLTU A1, A2, A0
9D0115E4  70A85002   MUL T2, A1, T0
9D0115E8  01463021   ADDU A2, T2, A2
9D0115EC  00C43023   SUBU A2, A2, A0
9D0115F0  00C3001B   DIVU A2, V1
9D0115F4  006001F4   TEQ V1, ZERO
9D0115F8  3129FFFF   ANDI T1, T1, -1
9D0115FC  00005012   MFLO T2
9D011600  00002010   MFHI A0
9D011604  00042400   SLL A0, A0, 16
9D011608  00894825   OR T1, A0, T1
9D01160C  71473802   MUL A3, T2, A3
9D011610  0127202B   SLTU A0, T1, A3
9D011614  00C3001B   DIVU A2, V1
9D011618  006001F4   TEQ V1, ZERO
9D01161C  50800009   BEQL A0, ZERO, 0x9D011644
9D011620  01274823   SUBU T1, T1, A3
9D011624  01284821   ADDU T1, T1, T0
9D011628  0128182B   SLTU V1, T1, T0
9D01162C  54600005   BNEL V1, ZERO, 0x9D011644
9D011630  01274823   SUBU T1, T1, A3
9D011634  0127182B   SLTU V1, T1, A3
9D011638  70682002   MUL A0, V1, T0
9D01163C  00894821   ADDU T1, A0, T1
9D011640  01274823   SUBU T1, T1, A3
9D0119F8  0127001B   DIVU T1, A3
9D0119FC  00E001F4   TEQ A3, ZERO
9D011A00  00086C02   SRL T5, T0, 16
9D011A04  00005812   MFLO T3
9D011A08  00005010   MFHI T2
9D011A0C  000A5400   SLL T2, T2, 16
9D011A10  014D5025   OR T2, T2, T5
9D011A14  716C2002   MUL A0, T3, T4
9D011A18  0144302B   SLTU A2, T2, A0
9D011A1C  0127001B   DIVU T1, A3
9D011A20  00E001F4   TEQ A3, ZERO
9D011A24  10C00009   BEQ A2, ZERO, 0x9D011A4C
9D011A28  01442823   SUBU A1, T2, A0
9D011A2C  01425021   ADDU T2, T2, V0
9D011A30  0142282B   SLTU A1, T2, V0
9D011A34  14A00004   BNE A1, ZERO, 0x9D011A48
9D011A38  256BFFFF   ADDIU T3, T3, -1
9D011A3C  0144282B   SLTU A1, T2, A0
9D011A40  54A000A2   BNEL A1, ZERO, 0x9D011CCC
9D011A44  256BFFFF   ADDIU T3, T3, -1
9D011A48  01442823   SUBU A1, T2, A0
9D011A4C  00A7001B   DIVU A1, A3
9D011A50  00E001F4   TEQ A3, ZERO
9D011A54  3108FFFF   ANDI T0, T0, -1
9D011A58  00002012   MFLO A0
9D011A5C  00003010   MFHI A2
9D011A60  00063400   SLL A2, A2, 16
9D011A64  00C84025   OR T0, A2, T0
9D011A68  708C6002   MUL T4, A0, T4
9D011A6C  010C302B   SLTU A2, T0, T4
9D011A70  00A7001B   DIVU A1, A3
9D011A74  00E001F4   TEQ A3, ZERO
9D011A78  10C00006   BEQ A2, ZERO, 0x9D011A94
9D011A7C  01024021   ADDU T0, T0, V0
9D011A80  0102102B   SLTU V0, T0, V0
9D011A84  14400003   BNE V0, ZERO, 0x9D011A94
9D011A88  2484FFFF   ADDIU A0, A0, -1
9D011A8C  010C602B   SLTU T4, T0, T4
9D011A90  008C2023   SUBU A0, A0, T4
9D011A94  000B5C00   SLL T3, T3, 16
9D011A98  008B2025   OR A0, A0, T3
9D011CCC  0B404692   J 0x9D011A48
9D011CD0  01425021   ADDU T2, T2, V0
9D011520  00491006   SRLV V0, T1, V0
9D011644  00491006   SRLV V0, T1, V0
9D011524  03E00008   JR RA
9D011528  00001821   ADDU V1, ZERO, ZERO
9D011648  03E00008   JR RA
9D01164C  00001821   ADDU V1, ZERO, ZERO
9D01152C  00A7102B   SLTU V0, A1, A3
9D011530  14400047   BNE V0, ZERO, 0x9D011650
9D011534  70E84020   CLZ T0, A3
9D011994  00A7102B   SLTU V0, A1, A3
9D011998  54400042   BNEL V0, ZERO, 0x9D011AA4
9D01199C  00002021   ADDU A0, ZERO, ZERO
9D011AA4  00001821   ADDU V1, ZERO, ZERO
9D011650  00801021   ADDU V0, A0, ZERO
9D011654  03E00008   JR RA
9D011658  00A01821   ADDU V1, A1, ZERO
9D0119A0  70E31820   CLZ V1, A3
9D011538  15000048   BNE T0, ZERO, 0x9D01165C
9D01153C  240A0020   ADDIU T2, ZERO, 32
9D0119A4  14600042   BNE V1, ZERO, 0x9D011AB0
9D0119A8  240B0020   ADDIU T3, ZERO, 32
9D011540  00E5102B   SLTU V0, A3, A1
9D011544  14400005   BNE V0, ZERO, 0x9D01155C
9D011548  00861023   SUBU V0, A0, A2
9D01154C  0086402B   SLTU T0, A0, A2
9D011550  15000088   BNE T0, ZERO, 0x9D011774
9D011554  00801021   ADDU V0, A0, ZERO
9D0119AC  00E5282B   SLTU A1, A3, A1
9D0119B0  54A000C4   BNEL A1, ZERO, 0x9D011CC4
9D0119B4  00001821   ADDU V1, ZERO, ZERO
9D0119B8  0086202B   SLTU A0, A0, A2
9D0119BC  0B404663   J 0x9D01198C
9D0119C0  2C840001   SLTIU A0, A0, 1
9D011CC4  0B404663   J 0x9D01198C
9D011CC8  24040001   ADDIU A0, ZERO, 1
9D011558  00861023   SUBU V0, A0, A2
9D01155C  00A71823   SUBU V1, A1, A3
9D011560  0082202B   SLTU A0, A0, V0
9D011564  03E00008   JR RA
9D011568  00641823   SUBU V1, V1, A0
9D01165C  01485023   SUBU T2, T2, T0
9D011AB0  01635823   SUBU T3, T3, V1
9D011660  01461006   SRLV V0, A2, T2
9D011664  01073804   SLLV A3, A3, T0
9D011668  00473825   OR A3, V0, A3
9D011AB4  01661006   SRLV V0, A2, T3
9D011AB8  00673804   SLLV A3, A3, V1
9D011ABC  00473825   OR A3, V0, A3
9D011690  01063004   SLLV A2, A2, T0
9D01166C  01455806   SRLV T3, A1, T2
9D011AC0  01654806   SRLV T1, A1, T3
9D011680  01441806   SRLV V1, A0, T2
9D011684  01052804   SLLV A1, A1, T0
9D011688  00652825   OR A1, V1, A1
9D011AD4  01645806   SRLV T3, A0, T3
9D011AD8  00652804   SLLV A1, A1, V1
9D011ADC  01652825   OR A1, T3, A1
9D011670  00074C02   SRL T1, A3, 16
9D011674  0169001B   DIVU T3, T1
9D011678  012001F4   TEQ T1, ZERO
9D01167C  30EDFFFF   ANDI T5, A3, -1
9D01168C  00051C02   SRL V1, A1, 16
9D011694  00006012   MFLO T4
9D011698  00001010   MFHI V0
9D01169C  00021400   SLL V0, V0, 16
9D0116A0  00431025   OR V0, V0, V1
9D0116A4  718D7002   MUL T6, T4, T5
9D0116A8  004E182B   SLTU V1, V0, T6
9D0116AC  0169001B   DIVU T3, T1
9D0116B0  012001F4   TEQ T1, ZERO
9D0116B4  1060000A   BEQ V1, ZERO, 0x9D0116E0
9D0116B8  01042004   SLLV A0, A0, T0
9D0116BC  00471021   ADDU V0, V0, A3
9D0116C0  0047182B   SLTU V1, V0, A3
9D0116C4  14600006   BNE V1, ZERO, 0x9D0116E0
9D0116C8  258CFFFF   ADDIU T4, T4, -1
9D0116CC  004E182B   SLTU V1, V0, T6
9D0116D0  50600004   BEQL V1, ZERO, 0x9D0116E4
9D0116D4  004E1023   SUBU V0, V0, T6
9D0116D8  258CFFFF   ADDIU T4, T4, -1
9D0116DC  00471021   ADDU V0, V0, A3
9D0116E0  004E1023   SUBU V0, V0, T6
9D0116E4  0049001B   DIVU V0, T1
9D0116E8  012001F4   TEQ T1, ZERO
9D0116EC  30A5FFFF   ANDI A1, A1, -1
9D0116F0  00005812   MFLO T3
9D0116F4  00001810   MFHI V1
9D0116F8  00031C00   SLL V1, V1, 16
9D0116FC  00652825   OR A1, V1, A1
9D011700  716D6802   MUL T5, T3, T5
9D011704  00AD182B   SLTU V1, A1, T5
9D011708  0049001B   DIVU V0, T1
9D01170C  012001F4   TEQ T1, ZERO
9D011710  50600006   BEQL V1, ZERO, 0x9D01172C
9D011714  000C6400   SLL T4, T4, 16
9D011718  00A72821   ADDU A1, A1, A3
9D01171C  00A7102B   SLTU V0, A1, A3
9D011720  1040004D   BEQ V0, ZERO, 0x9D011858
9D011724  256BFFFF   ADDIU T3, T3, -1
9D011728  000C6400   SLL T4, T4, 16
9D01172C  016C5825   OR T3, T3, T4
9D011734  00AD2823   SUBU A1, A1, T5
9D011858  00AD102B   SLTU V0, A1, T5
9D01185C  5040FFB3   BEQL V0, ZERO, 0x9D01172C
9D011860  000C6400   SLL T4, T4, 16
9D011864  256BFFFF   ADDIU T3, T3, -1
9D011868  0B4045CA   J 0x9D011728
9D01186C  00A72821   ADDU A1, A1, A3
9D011AC4  00071402   SRL V0, A3, 16
9D011AC8  0122001B   DIVU T1, V0
9D011ACC  004001F4   TEQ V0, ZERO
9D011AD0  30ECFFFF   ANDI T4, A3, -1
9D011AE0  00055C02   SRL T3, A1, 16
9D011AE4  00005012   MFLO T2
9D011AE8  00004010   MFHI T0
9D011AEC  00084400   SLL T0, T0, 16
9D011AF0  010B4025   OR T0, T0, T3
9D011AF4  714C6802   MUL T5, T2, T4
9D011AF8  010D582B   SLTU T3, T0, T5
9D011AFC  0122001B   DIVU T1, V0
9D011B00  004001F4   TEQ V0, ZERO
9D011B04  1160000A   BEQ T3, ZERO, 0x9D011B30
9D011B08  00663004   SLLV A2, A2, V1
9D011B0C  01074021   ADDU T0, T0, A3
9D011B10  0107482B   SLTU T1, T0, A3
9D011B14  15200006   BNE T1, ZERO, 0x9D011B30
9D011B18  254AFFFF   ADDIU T2, T2, -1
9D011B1C  010D482B   SLTU T1, T0, T5
9D011B20  51200004   BEQL T1, ZERO, 0x9D011B34
9D011B24  010D4023   SUBU T0, T0, T5
9D011B28  254AFFFF   ADDIU T2, T2, -1
9D011B2C  01074021   ADDU T0, T0, A3
9D011B30  010D4023   SUBU T0, T0, T5
9D011B34  0102001B   DIVU T0, V0
9D011B38  004001F4   TEQ V0, ZERO
9D011B3C  30A5FFFF   ANDI A1, A1, -1
9D011B40  00004812   MFLO T1
9D011B44  00005810   MFHI T3
9D011B48  000B5C00   SLL T3, T3, 16
9D011B4C  01652825   OR A1, T3, A1
9D011B50  712C6002   MUL T4, T1, T4
9D011B54  00AC582B   SLTU T3, A1, T4
9D011B58  0102001B   DIVU T0, V0
9D011B5C  004001F4   TEQ V0, ZERO
9D011B60  5160000B   BEQL T3, ZERO, 0x9D011B90
9D011B64  000A5400   SLL T2, T2, 16
9D011B68  00A72821   ADDU A1, A1, A3
9D011B6C  00A7102B   SLTU V0, A1, A3
9D011B70  14400006   BNE V0, ZERO, 0x9D011B8C
9D011B74  2529FFFF   ADDIU T1, T1, -1
9D011B78  00AC102B   SLTU V0, A1, T4
9D011B7C  50400004   BEQL V0, ZERO, 0x9D011B90
9D011B80  000A5400   SLL T2, T2, 16
9D011B84  2529FFFF   ADDIU T1, T1, -1
9D011B88  00A72821   ADDU A1, A1, A3
9D011B8C  000A5400   SLL T2, T2, 16
9D011B90  012A4825   OR T1, T1, T2
9D011B98  00AC2823   SUBU A1, A1, T4
9D011730  01660019   MULTU T3, A2
9D011738  0000C810   MFHI T9
9D011740  03207021   ADDU T6, T9, ZERO
9D011754  00001012   MFLO V0
9D011B94  01260019   MULTU T1, A2
9D011B9C  00005810   MFHI T3
9D01173C  00B9682B   SLTU T5, A1, T9
9D011744  15A0003E   BNE T5, ZERO, 0x9D011840
9D011748  00004812   MFLO T1
9D01174C  10B9004B   BEQ A1, T9, 0x9D01187C
9D011750  00B91823   SUBU V1, A1, T9
9D01187C  0089182B   SLTU V1, A0, T1
9D011880  5460FFF0   BNEL V1, ZERO, 0x9D011844
9D011884  01261023   SUBU V0, T1, A2
9D011888  00001012   MFLO V0
9D01188C  0B4045D6   J 0x9D011758
9D011890  00001821   ADDU V1, ZERO, ZERO
9D011BA0  00AB382B   SLTU A3, A1, T3
9D011BA4  14E00044   BNE A3, ZERO, 0x9D011CB8
9D011BA8  00005012   MFLO T2
9D011BAC  50AB003F   BEQL A1, T3, 0x9D011CAC
9D011BB0  00641804   SLLV V1, A0, V1
9D011BB4  01202021   ADDU A0, T1, ZERO
9D011BB8  0B404663   J 0x9D01198C
9D011BBC  00001821   ADDU V1, ZERO, ZERO
9D011CAC  006A182B   SLTU V1, V1, T2
9D011CB0  1060FF36   BEQ V1, ZERO, 0x9D01198C
9D011CB4  01202021   ADDU A0, T1, ZERO
9D011CB8  2524FFFF   ADDIU A0, T1, -1
9D011CBC  0B404663   J 0x9D01198C
9D011CC0  00001821   ADDU V1, ZERO, ZERO
9D011840  01261023   SUBU V0, T1, A2
9D011844  01C71823   SUBU V1, T6, A3
9D011848  0122482B   SLTU T1, T1, V0
9D01184C  00691823   SUBU V1, V1, T1
9D011850  0B4045D6   J 0x9D011758
9D011854  00A31823   SUBU V1, A1, V1
9D011758  00821023   SUBU V0, A0, V0
9D01175C  0082202B   SLTU A0, A0, V0
9D011760  00641823   SUBU V1, V1, A0
9D011764  01435004   SLLV T2, V1, T2
9D011768  01021006   SRLV V0, V0, T0
9D01176C  004A1025   OR V0, V0, T2
9D011770  01031806   SRLV V1, V1, T0
9D011774  03E00008   JR RA
9D011778  00000000   NOP
9D01198C  03E00008   JR RA
9D011990  00801021   ADDU V0, A0, ZERO
9D011A9C  03E00008   JR RA
9D011AA0  00801021   ADDU V0, A0, ZERO
9D011AA8  03E00008   JR RA
9D011AAC  00801021   ADDU V0, A0, ZERO
---  /build/xc32/gcc/config/floatunsisf.c  --------------------------------------------------------------
9D018D40  27BDFFE8   ADDIU SP, SP, -24
9D018D44  AFBF0014   SW RA, 20(SP)
9D018D48  04800006   BLTZ A0, 0x9D018D64
9D018D4C  00801021   ADDU V0, A0, ZERO
9D018D64  30420001   ANDI V0, V0, 1
9D018D68  00042042   SRL A0, A0, 1
9D018D6C  0F4039F4   JAL litofp
9D018D70  00822025   OR A0, A0, V0
9D018D74  00402021   ADDU A0, V0, ZERO
9D018D78  0F403860   JAL fpadd
9D018D7C  00402821   ADDU A1, V0, ZERO
9D018D50  0F4039F4   JAL litofp
9D018D54  00000000   NOP
9D018D58  8FBF0014   LW RA, 20(SP)
9D018D5C  03E00008   JR RA
9D018D60  27BD0018   ADDIU SP, SP, 24
9D018D80  8FBF0014   LW RA, 20(SP)
9D018D84  03E00008   JR RA
9D018D88  27BD0018   ADDIU SP, SP, 24
---  ../Microhip/Graphics/Drivers/HX8347-D.c  -----------------------------------------------------------
9D002568  27BDFFE0   ADDIU SP, SP, -32
9D00256C  AFBF001C   SW RA, 28(SP)
9D002570  AFBE0018   SW S8, 24(SP)
9D002574  03A0F021   ADDU S8, SP, ZERO
9D002578  00801021   ADDU V0, A0, ZERO
9D00257C  A7C20020   SH V0, 32(S8)
9D002580  0B400974   J 0x9D0025D0
9D002584  00000000   NOP
9D0025D0  97C20020   LHU V0, 32(S8)
9D0025D4  0002102B   SLTU V0, ZERO, V0
9D0025D8  304200FF   ANDI V0, V0, 255
9D0025DC  97C30020   LHU V1, 32(S8)
9D0025E0  2463FFFF   ADDIU V1, V1, -1
9D0025E4  A7C30020   SH V1, 32(S8)
9D0025E8  1440FFE7   BNE V0, ZERO, 0x9D002588
9D0025EC  00000000   NOP
9D002588  0F4065D8   JAL INTDisableInterrupts
9D00258C  00000000   NOP
9D002590  AFC20010   SW V0, 16(S8)
9D002594  34049C40   ORI A0, ZERO, -25536
9D002598  0F4065C7   JAL OpenCoreTimer
9D00259C  00000000   NOP
9D0025A0  8FC40010   LW A0, 16(S8)
9D0025A4  0F406578   JAL INTRestoreInterrupts
9D0025A8  00000000   NOP
9D0025AC  3C02BF88   LUI V0, -16504
9D0025B0  24030001   ADDIU V1, ZERO, 1
9D0025B4  AC431034   SW V1, 4148(V0)
9D0025B8  00000000   NOP
9D0025BC  3C02BF88   LUI V0, -16504
9D0025C0  8C421030   LW V0, 4144(V0)
9D0025C4  30420001   ANDI V0, V0, 1
9D0025C8  1040FFFC   BEQ V0, ZERO, 0x9D0025BC
9D0025CC  00000000   NOP
9D0025F0  3C02BF88   LUI V0, -16504
9D0025F4  24030001   ADDIU V1, ZERO, 1
9D0025F8  AC431034   SW V1, 4148(V0)
9D0025FC  03C0E821   ADDU SP, S8, ZERO
9D002600  8FBF001C   LW RA, 28(SP)
9D002604  8FBE0018   LW S8, 24(SP)
9D002608  27BD0020   ADDIU SP, SP, 32
9D00260C  03E00008   JR RA
9D002610  00000000   NOP
9D002614  27BDFFF8   ADDIU SP, SP, -8
9D002618  AFBE0004   SW S8, 4(SP)
9D00261C  03A0F021   ADDU S8, SP, ZERO
9D002620  00801821   ADDU V1, A0, ZERO
9D002624  00A01021   ADDU V0, A1, ZERO
9D002628  A3C30008   SB V1, 8(S8)
9D00262C  A3C2000C   SB V0, 12(S8)
9D002630  3C03BF88   LUI V1, -16504
9D002634  8C626060   LW V0, 24672(V1)
9D002638  7C027384   INS V0, ZERO, 14, 1
9D00263C  AC626060   SW V0, 24672(V1)
9D002640  3C03BF88   LUI V1, -16504
9D002644  8C626060   LW V0, 24672(V1)
9D002648  7C027BC4   INS V0, ZERO, 15, 1
9D00264C  AC626060   SW V0, 24672(V1)
9D002650  93C30008   LBU V1, 8(S8)
9D002654  3C02BF80   LUI V0, -16512
9D002658  AC437040   SW V1, 28736(V0)
9D00265C  3C02BF80   LUI V0, -16512
9D002660  8C427010   LW V0, 28688(V0)
9D002664  30428000   ANDI V0, V0, -32768
9D002668  1440FFFC   BNE V0, ZERO, 0x9D00265C
9D00266C  00000000   NOP
9D002670  3C03BF88   LUI V1, -16504
9D002674  8C626060   LW V0, 24672(V1)
9D002678  24040001   ADDIU A0, ZERO, 1
9D00267C  7C827BC4   INS V0, A0, 15, 1
9D002680  AC626060   SW V0, 24672(V1)
9D002684  93C3000C   LBU V1, 12(S8)
9D002688  3C02BF80   LUI V0, -16512
9D00268C  AC437040   SW V1, 28736(V0)
9D002690  3C02BF80   LUI V0, -16512
9D002694  8C427010   LW V0, 28688(V0)
9D002698  30428000   ANDI V0, V0, -32768
9D00269C  1440FFFC   BNE V0, ZERO, 0x9D002690
9D0026A0  00000000   NOP
9D0026A4  3C03BF88   LUI V1, -16504
9D0026A8  8C626060   LW V0, 24672(V1)
9D0026AC  24040001   ADDIU A0, ZERO, 1
9D0026B0  7C827384   INS V0, A0, 14, 1
9D0026B4  AC626060   SW V0, 24672(V1)
9D0026B8  03C0E821   ADDU SP, S8, ZERO
9D0026BC  8FBE0004   LW S8, 4(SP)
9D0026C0  27BD0008   ADDIU SP, SP, 8
9D0026C4  03E00008   JR RA
9D0026C8  00000000   NOP
9D0026CC  27BDFFE0   ADDIU SP, SP, -32
9D0026D0  AFBF001C   SW RA, 28(SP)
9D0026D4  AFBE0018   SW S8, 24(SP)
9D0026D8  03A0F021   ADDU S8, SP, ZERO
9D0026DC  00801021   ADDU V0, A0, ZERO
9D0026E0  A3C20020   SB V0, 32(S8)
9D0026E4  3C03BF88   LUI V1, -16504
9D0026E8  8C626060   LW V0, 24672(V1)
9D0026EC  7C027384   INS V0, ZERO, 14, 1
9D0026F0  AC626060   SW V0, 24672(V1)
9D0026F4  3C03BF88   LUI V1, -16504
9D0026F8  8C626060   LW V0, 24672(V1)
9D0026FC  7C027BC4   INS V0, ZERO, 15, 1
9D002700  AC626060   SW V0, 24672(V1)
9D002704  93C30020   LBU V1, 32(S8)
9D002708  3C02BF80   LUI V0, -16512
9D00270C  AC437040   SW V1, 28736(V0)
9D002710  3C02BF80   LUI V0, -16512
9D002714  8C427010   LW V0, 28688(V0)
9D002718  30428000   ANDI V0, V0, -32768
9D00271C  1440FFFC   BNE V0, ZERO, 0x9D002710
9D002720  00000000   NOP
9D002724  24040001   ADDIU A0, ZERO, 1
9D002728  0F40095A   JAL DelayMs
9D00272C  00000000   NOP
9D002730  3C03BF88   LUI V1, -16504
9D002734  8C626060   LW V0, 24672(V1)
9D002738  24040001   ADDIU A0, ZERO, 1
9D00273C  7C827BC4   INS V0, A0, 15, 1
9D002740  AC626060   SW V0, 24672(V1)
9D002744  3C02BF80   LUI V0, -16512
9D002748  8C427040   LW V0, 28736(V0)
9D00274C  AFC20010   SW V0, 16(S8)
9D002750  3C02BF80   LUI V0, -16512
9D002754  8C427010   LW V0, 28688(V0)
9D002758  30428000   ANDI V0, V0, -32768
9D00275C  1440FFFC   BNE V0, ZERO, 0x9D002750
9D002760  00000000   NOP
9D002764  3C02BF80   LUI V0, -16512
9D002768  8C427040   LW V0, 28736(V0)
9D00276C  AFC20010   SW V0, 16(S8)
9D002770  3C03BF88   LUI V1, -16504
9D002774  8C626060   LW V0, 24672(V1)
9D002778  24040001   ADDIU A0, ZERO, 1
9D00277C  7C827384   INS V0, A0, 14, 1
9D002780  AC626060   SW V0, 24672(V1)
9D002784  8FC20010   LW V0, 16(S8)
9D002788  03C0E821   ADDU SP, S8, ZERO
9D00278C  8FBF001C   LW RA, 28(SP)
9D002790  8FBE0018   LW S8, 24(SP)
9D002794  27BD0020   ADDIU SP, SP, 32
9D002798  03E00008   JR RA
9D00279C  00000000   NOP
9D0027A0  27BDFFE8   ADDIU SP, SP, -24
9D0027A4  AFBF0014   SW RA, 20(SP)
9D0027A8  AFBE0010   SW S8, 16(SP)
9D0027AC  03A0F021   ADDU S8, SP, ZERO
9D0027B0  3C03BF88   LUI V1, -16504
9D0027B4  8C6260A0   LW V0, 24736(V1)
9D0027B8  7C020844   INS V0, ZERO, 1, 1
9D0027BC  AC6260A0   SW V0, 24736(V1)
9D0027C0  3C03BF88   LUI V1, -16504
9D0027C4  8C626080   LW V0, 24704(V1)
9D0027C8  7C020844   INS V0, ZERO, 1, 1
9D0027CC  AC626080   SW V0, 24704(V1)
9D0027D0  3C03BF88   LUI V1, -16504
9D0027D4  8C626060   LW V0, 24672(V1)
9D0027D8  24040001   ADDIU A0, ZERO, 1
9D0027DC  7C827BC4   INS V0, A0, 15, 1
9D0027E0  AC626060   SW V0, 24672(V1)
9D0027E4  3C03BF88   LUI V1, -16504
9D0027E8  8C626040   LW V0, 24640(V1)
9D0027EC  7C027BC4   INS V0, ZERO, 15, 1
9D0027F0  AC626040   SW V0, 24640(V1)
9D0027F4  3C03BF88   LUI V1, -16504
9D0027F8  8C626060   LW V0, 24672(V1)
9D0027FC  24040001   ADDIU A0, ZERO, 1
9D002800  7C827384   INS V0, A0, 14, 1
9D002804  AC626060   SW V0, 24672(V1)
9D002808  3C03BF88   LUI V1, -16504
9D00280C  8C626040   LW V0, 24640(V1)
9D002810  7C027384   INS V0, ZERO, 14, 1
9D002814  AC626040   SW V0, 24640(V1)
9D002818  3C02BF80   LUI V0, -16512
9D00281C  AC407010   SW ZERO, 28688(V0)
9D002820  3C02BF80   LUI V0, -16512
9D002824  AC407050   SW ZERO, 28752(V0)
9D002828  3C02BF80   LUI V0, -16512
9D00282C  AC407000   SW ZERO, 28672(V0)
9D002830  3C03BF80   LUI V1, -16512
9D002834  8C627010   LW V0, 28688(V1)
9D002838  24040002   ADDIU A0, ZERO, 2
9D00283C  7C824A04   INS V0, A0, 8, 2
9D002840  AC627010   SW V0, 28688(V1)
9D002844  3C03BF80   LUI V1, -16512
9D002848  8C627010   LW V0, 28688(V1)
9D00284C  7C023984   INS V0, ZERO, 6, 2
9D002850  AC627010   SW V0, 28688(V1)
9D002854  3C03BF80   LUI V1, -16512
9D002858  8C627010   LW V0, 28688(V1)
9D00285C  24040003   ADDIU A0, ZERO, 3
9D002860  7C822884   INS V0, A0, 2, 4
9D002864  AC627010   SW V0, 28688(V1)
9D002868  3C03BF80   LUI V1, -16512
9D00286C  8C627010   LW V0, 28688(V1)
9D002870  7C020804   INS V0, ZERO, 0, 2
9D002874  AC627010   SW V0, 28688(V1)
9D002878  3C03BF80   LUI V1, -16512
9D00287C  8C627010   LW V0, 28688(V1)
9D002880  24040001   ADDIU A0, ZERO, 1
9D002884  7C825284   INS V0, A0, 10, 1
9D002888  AC627010   SW V0, 28688(V1)
9D00288C  3C03BF80   LUI V1, -16512
9D002890  8C627000   LW V0, 28672(V1)
9D002894  7C023984   INS V0, ZERO, 6, 2
9D002898  AC627000   SW V0, 28672(V1)
9D00289C  3C03BF80   LUI V1, -16512
9D0028A0  8C627000   LW V0, 28672(V1)
9D0028A4  24040001   ADDIU A0, ZERO, 1
9D0028A8  7C824204   INS V0, A0, 8, 1
9D0028AC  AC627000   SW V0, 28672(V1)
9D0028B0  3C03BF80   LUI V1, -16512
9D0028B4  8C627000   LW V0, 28672(V1)
9D0028B8  24040001   ADDIU A0, ZERO, 1
9D0028BC  7C824A44   INS V0, A0, 9, 1
9D0028C0  AC627000   SW V0, 28672(V1)
9D0028C4  3C03BF80   LUI V1, -16512
9D0028C8  8C627000   LW V0, 28672(V1)
9D0028CC  24040001   ADDIU A0, ZERO, 1
9D0028D0  7C827BC4   INS V0, A0, 15, 1
9D0028D4  AC627000   SW V0, 28672(V1)
9D0028D8  24040064   ADDIU A0, ZERO, 100
9D0028DC  0F40095A   JAL DelayMs
9D0028E0  00000000   NOP
9D0028E4  3C03BF88   LUI V1, -16504
9D0028E8  8C6260A0   LW V0, 24736(V1)
9D0028EC  24040001   ADDIU A0, ZERO, 1
9D0028F0  7C820844   INS V0, A0, 1, 1
9D0028F4  AC6260A0   SW V0, 24736(V1)
9D0028F8  24040096   ADDIU A0, ZERO, 150
9D0028FC  0F40095A   JAL DelayMs
9D002900  00000000   NOP
9D002904  240400EA   ADDIU A0, ZERO, 234
9D002908  00002821   ADDU A1, ZERO, ZERO
9D00290C  0F400985   JAL SetReg
9D002910  00000000   NOP
9D002914  240400EB   ADDIU A0, ZERO, 235
9D002918  24050020   ADDIU A1, ZERO, 32
9D00291C  0F400985   JAL SetReg
9D002920  00000000   NOP
9D002924  240400EC   ADDIU A0, ZERO, 236
9D002928  2405000C   ADDIU A1, ZERO, 12
9D00292C  0F400985   JAL SetReg
9D002930  00000000   NOP
9D002934  240400ED   ADDIU A0, ZERO, 237
9D002938  240500C4   ADDIU A1, ZERO, 196
9D00293C  0F400985   JAL SetReg
9D002940  00000000   NOP
9D002944  240400E8   ADDIU A0, ZERO, 232
9D002948  24050040   ADDIU A1, ZERO, 64
9D00294C  0F400985   JAL SetReg
9D002950  00000000   NOP
9D002954  240400E9   ADDIU A0, ZERO, 233
9D002958  24050038   ADDIU A1, ZERO, 56
9D00295C  0F400985   JAL SetReg
9D002960  00000000   NOP
9D002964  240400F1   ADDIU A0, ZERO, 241
9D002968  24050001   ADDIU A1, ZERO, 1
9D00296C  0F400985   JAL SetReg
9D002970  00000000   NOP
9D002974  240400F2   ADDIU A0, ZERO, 242
9D002978  24050010   ADDIU A1, ZERO, 16
9D00297C  0F400985   JAL SetReg
9D002980  00000000   NOP
9D002984  24040027   ADDIU A0, ZERO, 39
9D002988  240500A3   ADDIU A1, ZERO, 163
9D00298C  0F400985   JAL SetReg
9D002990  00000000   NOP
9D002994  24040040   ADDIU A0, ZERO, 64
9D002998  00002821   ADDU A1, ZERO, ZERO
9D00299C  0F400985   JAL SetReg
9D0029A0  00000000   NOP
9D0029A4  24040041   ADDIU A0, ZERO, 65
9D0029A8  00002821   ADDU A1, ZERO, ZERO
9D0029AC  0F400985   JAL SetReg
9D0029B0  00000000   NOP
9D0029B4  24040042   ADDIU A0, ZERO, 66
9D0029B8  24050001   ADDIU A1, ZERO, 1
9D0029BC  0F400985   JAL SetReg
9D0029C0  00000000   NOP
9D0029C4  24040043   ADDIU A0, ZERO, 67
9D0029C8  24050013   ADDIU A1, ZERO, 19
9D0029CC  0F400985   JAL SetReg
9D0029D0  00000000   NOP
9D0029D4  24040044   ADDIU A0, ZERO, 68
9D0029D8  24050010   ADDIU A1, ZERO, 16
9D0029DC  0F400985   JAL SetReg
9D0029E0  00000000   NOP
9D0029E4  24040045   ADDIU A0, ZERO, 69
9D0029E8  24050026   ADDIU A1, ZERO, 38
9D0029EC  0F400985   JAL SetReg
9D0029F0  00000000   NOP
9D0029F4  24040046   ADDIU A0, ZERO, 70
9D0029F8  24050008   ADDIU A1, ZERO, 8
9D0029FC  0F400985   JAL SetReg
9D002A00  00000000   NOP
9D002A04  24040047   ADDIU A0, ZERO, 71
9D002A08  24050051   ADDIU A1, ZERO, 81
9D002A0C  0F400985   JAL SetReg
9D002A10  00000000   NOP
9D002A14  24040048   ADDIU A0, ZERO, 72
9D002A18  24050002   ADDIU A1, ZERO, 2
9D002A1C  0F400985   JAL SetReg
9D002A20  00000000   NOP
9D002A24  24040049   ADDIU A0, ZERO, 73
9D002A28  24050012   ADDIU A1, ZERO, 18
9D002A2C  0F400985   JAL SetReg
9D002A30  00000000   NOP
9D002A34  2404004A   ADDIU A0, ZERO, 74
9D002A38  24050018   ADDIU A1, ZERO, 24
9D002A3C  0F400985   JAL SetReg
9D002A40  00000000   NOP
9D002A44  2404004B   ADDIU A0, ZERO, 75
9D002A48  24050019   ADDIU A1, ZERO, 25
9D002A4C  0F400985   JAL SetReg
9D002A50  00000000   NOP
9D002A54  2404004C   ADDIU A0, ZERO, 76
9D002A58  24050014   ADDIU A1, ZERO, 20
9D002A5C  0F400985   JAL SetReg
9D002A60  00000000   NOP
9D002A64  24040050   ADDIU A0, ZERO, 80
9D002A68  24050019   ADDIU A1, ZERO, 25
9D002A6C  0F400985   JAL SetReg
9D002A70  00000000   NOP
9D002A74  24040051   ADDIU A0, ZERO, 81
9D002A78  2405002F   ADDIU A1, ZERO, 47
9D002A7C  0F400985   JAL SetReg
9D002A80  00000000   NOP
9D002A84  24040052   ADDIU A0, ZERO, 82
9D002A88  2405002C   ADDIU A1, ZERO, 44
9D002A8C  0F400985   JAL SetReg
9D002A90  00000000   NOP
9D002A94  24040053   ADDIU A0, ZERO, 83
9D002A98  2405003E   ADDIU A1, ZERO, 62
9D002A9C  0F400985   JAL SetReg
9D002AA0  00000000   NOP
9D002AA4  24040054   ADDIU A0, ZERO, 84
9D002AA8  2405003F   ADDIU A1, ZERO, 63
9D002AAC  0F400985   JAL SetReg
9D002AB0  00000000   NOP
9D002AB4  24040055   ADDIU A0, ZERO, 85
9D002AB8  2405003F   ADDIU A1, ZERO, 63
9D002ABC  0F400985   JAL SetReg
9D002AC0  00000000   NOP
9D002AC4  24040056   ADDIU A0, ZERO, 86
9D002AC8  2405002E   ADDIU A1, ZERO, 46
9D002ACC  0F400985   JAL SetReg
9D002AD0  00000000   NOP
9D002AD4  24040057   ADDIU A0, ZERO, 87
9D002AD8  24050077   ADDIU A1, ZERO, 119
9D002ADC  0F400985   JAL SetReg
9D002AE0  00000000   NOP
9D002AE4  24040058   ADDIU A0, ZERO, 88
9D002AE8  2405000B   ADDIU A1, ZERO, 11
9D002AEC  0F400985   JAL SetReg
9D002AF0  00000000   NOP
9D002AF4  24040059   ADDIU A0, ZERO, 89
9D002AF8  24050006   ADDIU A1, ZERO, 6
9D002AFC  0F400985   JAL SetReg
9D002B00  00000000   NOP
9D002B04  2404005A   ADDIU A0, ZERO, 90
9D002B08  24050007   ADDIU A1, ZERO, 7
9D002B0C  0F400985   JAL SetReg
9D002B10  00000000   NOP
9D002B14  2404005B   ADDIU A0, ZERO, 91
9D002B18  2405000D   ADDIU A1, ZERO, 13
9D002B1C  0F400985   JAL SetReg
9D002B20  00000000   NOP
9D002B24  2404005C   ADDIU A0, ZERO, 92
9D002B28  2405001D   ADDIU A1, ZERO, 29
9D002B2C  0F400985   JAL SetReg
9D002B30  00000000   NOP
9D002B34  2404005D   ADDIU A0, ZERO, 93
9D002B38  240500CC   ADDIU A1, ZERO, 204
9D002B3C  0F400985   JAL SetReg
9D002B40  00000000   NOP
9D002B44  24040004   ADDIU A0, ZERO, 4
9D002B48  24050001   ADDIU A1, ZERO, 1
9D002B4C  0F400985   JAL SetReg
9D002B50  00000000   NOP
9D002B54  24040005   ADDIU A0, ZERO, 5
9D002B58  2405003F   ADDIU A1, ZERO, 63
9D002B5C  0F400985   JAL SetReg
9D002B60  00000000   NOP
9D002B64  24040008   ADDIU A0, ZERO, 8
9D002B68  00002821   ADDU A1, ZERO, ZERO
9D002B6C  0F400985   JAL SetReg
9D002B70  00000000   NOP
9D002B74  24040009   ADDIU A0, ZERO, 9
9D002B78  240500EF   ADDIU A1, ZERO, 239
9D002B7C  0F400985   JAL SetReg
9D002B80  00000000   NOP
9D002B84  24040016   ADDIU A0, ZERO, 22
9D002B88  24050068   ADDIU A1, ZERO, 104
9D002B8C  0F400985   JAL SetReg
9D002B90  00000000   NOP
9D002B94  2404001B   ADDIU A0, ZERO, 27
9D002B98  2405001B   ADDIU A1, ZERO, 27
9D002B9C  0F400985   JAL SetReg
9D002BA0  00000000   NOP
9D002BA4  2404001A   ADDIU A0, ZERO, 26
9D002BA8  24050001   ADDIU A1, ZERO, 1
9D002BAC  0F400985   JAL SetReg
9D002BB0  00000000   NOP
9D002BB4  24040024   ADDIU A0, ZERO, 36
9D002BB8  2405002F   ADDIU A1, ZERO, 47
9D002BBC  0F400985   JAL SetReg
9D002BC0  00000000   NOP
9D002BC4  24040025   ADDIU A0, ZERO, 37
9D002BC8  24050057   ADDIU A1, ZERO, 87
9D002BCC  0F400985   JAL SetReg
9D002BD0  00000000   NOP
9D002BD4  24040023   ADDIU A0, ZERO, 35
9D002BD8  2405008D   ADDIU A1, ZERO, 141
9D002BDC  0F400985   JAL SetReg
9D002BE0  00000000   NOP
9D002BE4  24040018   ADDIU A0, ZERO, 24
9D002BE8  24050036   ADDIU A1, ZERO, 54
9D002BEC  0F400985   JAL SetReg
9D002BF0  00000000   NOP
9D002BF4  24040019   ADDIU A0, ZERO, 25
9D002BF8  24050001   ADDIU A1, ZERO, 1
9D002BFC  0F400985   JAL SetReg
9D002C00  00000000   NOP
9D002C04  24040001   ADDIU A0, ZERO, 1
9D002C08  00002821   ADDU A1, ZERO, ZERO
9D002C0C  0F400985   JAL SetReg
9D002C10  00000000   NOP
9D002C14  2404001F   ADDIU A0, ZERO, 31
9D002C18  24050088   ADDIU A1, ZERO, 136
9D002C1C  0F400985   JAL SetReg
9D002C20  00000000   NOP
9D002C24  24040005   ADDIU A0, ZERO, 5
9D002C28  0F40095A   JAL DelayMs
9D002C2C  00000000   NOP
9D002C30  2404001F   ADDIU A0, ZERO, 31
9D002C34  24050080   ADDIU A1, ZERO, 128
9D002C38  0F400985   JAL SetReg
9D002C3C  00000000   NOP
9D002C40  24040005   ADDIU A0, ZERO, 5
9D002C44  0F40095A   JAL DelayMs
9D002C48  00000000   NOP
9D002C4C  2404001F   ADDIU A0, ZERO, 31
9D002C50  24050090   ADDIU A1, ZERO, 144
9D002C54  0F400985   JAL SetReg
9D002C58  00000000   NOP
9D002C5C  24040005   ADDIU A0, ZERO, 5
9D002C60  0F40095A   JAL DelayMs
9D002C64  00000000   NOP
9D002C68  2404001F   ADDIU A0, ZERO, 31
9D002C6C  240500D0   ADDIU A1, ZERO, 208
9D002C70  0F400985   JAL SetReg
9D002C74  00000000   NOP
9D002C78  24040005   ADDIU A0, ZERO, 5
9D002C7C  0F40095A   JAL DelayMs
9D002C80  00000000   NOP
9D002C84  24040017   ADDIU A0, ZERO, 23
9D002C88  24050005   ADDIU A1, ZERO, 5
9D002C8C  0F400985   JAL SetReg
9D002C90  00000000   NOP
9D002C94  24040036   ADDIU A0, ZERO, 54
9D002C98  00002821   ADDU A1, ZERO, ZERO
9D002C9C  0F400985   JAL SetReg
9D002CA0  00000000   NOP
9D002CA4  24040028   ADDIU A0, ZERO, 40
9D002CA8  24050038   ADDIU A1, ZERO, 56
9D002CAC  0F400985   JAL SetReg
9D002CB0  00000000   NOP
9D002CB4  24040028   ADDIU A0, ZERO, 40
9D002CB8  0F40095A   JAL DelayMs
9D002CBC  00000000   NOP
9D002CC0  24040028   ADDIU A0, ZERO, 40
9D002CC4  2405003C   ADDIU A1, ZERO, 60
9D002CC8  0F400985   JAL SetReg
9D002CCC  00000000   NOP
9D002CD0  03C0E821   ADDU SP, S8, ZERO
9D002CD4  8FBF0014   LW RA, 20(SP)
9D002CD8  8FBE0010   LW S8, 16(SP)
9D002CDC  27BD0018   ADDIU SP, SP, 24
9D002CE0  03E00008   JR RA
9D002CE4  00000000   NOP
9D002CE8  27BDFFF8   ADDIU SP, SP, -8
9D002CEC  AFBE0004   SW S8, 4(SP)
9D002CF0  03A0F021   ADDU S8, SP, ZERO
9D002CF4  00801821   ADDU V1, A0, ZERO
9D002CF8  00A01021   ADDU V0, A1, ZERO
9D002CFC  A7C30008   SH V1, 8(S8)
9D002D00  A7C2000C   SH V0, 12(S8)
9D002D04  8782819C   LH V0, -32356(GP)
9D002D08  10400015   BEQ V0, ZERO, 0x9D002D60
9D002D0C  00000000   NOP
9D002D10  8782819A   LH V0, -32358(GP)
9D002D14  87C30008   LH V1, 8(S8)
9D002D18  0062102A   SLT V0, V1, V0
9D002D1C  144000AB   BNE V0, ZERO, 0x9D002FCC
9D002D20  00000000   NOP
9D002FCC  00000000   NOP
9D002FD0  0B400BFD   J 0x9D002FF4
9D002FD4  00000000   NOP
9D002D24  8782819E   LH V0, -32354(GP)
9D002D28  87C30008   LH V1, 8(S8)
9D002D2C  0043102A   SLT V0, V0, V1
9D002D30  144000A9   BNE V0, ZERO, 0x9D002FD8
9D002D34  00000000   NOP
9D002FD8  00000000   NOP
9D002FDC  0B400BFD   J 0x9D002FF4
9D002FE0  00000000   NOP
9D002D38  87828194   LH V0, -32364(GP)
9D002D3C  87C3000C   LH V1, 12(S8)
9D002D40  0062102A   SLT V0, V1, V0
9D002D44  144000A7   BNE V0, ZERO, 0x9D002FE4
9D002D48  00000000   NOP
9D002FE4  00000000   NOP
9D002FE8  0B400BFD   J 0x9D002FF4
9D002FEC  00000000   NOP
9D002D4C  87828196   LH V0, -32362(GP)
9D002D50  87C3000C   LH V1, 12(S8)
9D002D54  0043102A   SLT V0, V0, V1
9D002D58  144000A5   BNE V0, ZERO, 0x9D002FF0
9D002D5C  00000000   NOP
9D002FF0  00000000   NOP
9D002D60  3C03BF88   LUI V1, -16504
9D002D64  8C626060   LW V0, 24672(V1)
9D002D68  7C027384   INS V0, ZERO, 14, 1
9D002D6C  AC626060   SW V0, 24672(V1)
9D002D70  3C03BF88   LUI V1, -16504
9D002D74  8C626060   LW V0, 24672(V1)
9D002D78  7C027BC4   INS V0, ZERO, 15, 1
9D002D7C  AC626060   SW V0, 24672(V1)
9D002D80  3C02BF80   LUI V0, -16512
9D002D84  24030002   ADDIU V1, ZERO, 2
9D002D88  AC437040   SW V1, 28736(V0)
9D002D8C  3C02BF80   LUI V0, -16512
9D002D90  8C427010   LW V0, 28688(V0)
9D002D94  30428000   ANDI V0, V0, -32768
9D002D98  1440FFFC   BNE V0, ZERO, 0x9D002D8C
9D002D9C  00000000   NOP
9D002DA0  3C03BF88   LUI V1, -16504
9D002DA4  8C626060   LW V0, 24672(V1)
9D002DA8  24040001   ADDIU A0, ZERO, 1
9D002DAC  7C827BC4   INS V0, A0, 15, 1
9D002DB0  AC626060   SW V0, 24672(V1)
9D002DB4  97C30008   LHU V1, 8(S8)
9D002DB8  00001021   ADDU V0, ZERO, ZERO
9D002DBC  00601021   ADDU V0, V1, ZERO
9D002DC0  7C423A00   EXT V0, V0, 8, 8
9D002DC4  304200FF   ANDI V0, V0, 255
9D002DC8  00401821   ADDU V1, V0, ZERO
9D002DCC  3C02BF80   LUI V0, -16512
9D002DD0  AC437040   SW V1, 28736(V0)
9D002DD4  3C02BF80   LUI V0, -16512
9D002DD8  8C427010   LW V0, 28688(V0)
9D002DDC  30428000   ANDI V0, V0, -32768
9D002DE0  1440FFFC   BNE V0, ZERO, 0x9D002DD4
9D002DE4  00000000   NOP
9D002DE8  3C03BF88   LUI V1, -16504
9D002DEC  8C626060   LW V0, 24672(V1)
9D002DF0  7C027BC4   INS V0, ZERO, 15, 1
9D002DF4  AC626060   SW V0, 24672(V1)
9D002DF8  3C02BF80   LUI V0, -16512
9D002DFC  24030003   ADDIU V1, ZERO, 3
9D002E00  AC437040   SW V1, 28736(V0)
9D002E04  3C02BF80   LUI V0, -16512
9D002E08  8C427010   LW V0, 28688(V0)
9D002E0C  30428000   ANDI V0, V0, -32768
9D002E10  1440FFFC   BNE V0, ZERO, 0x9D002E04
9D002E14  00000000   NOP
9D002E18  3C03BF88   LUI V1, -16504
9D002E1C  8C626060   LW V0, 24672(V1)
9D002E20  24040001   ADDIU A0, ZERO, 1
9D002E24  7C827BC4   INS V0, A0, 15, 1
9D002E28  AC626060   SW V0, 24672(V1)
9D002E2C  97C30008   LHU V1, 8(S8)
9D002E30  00001021   ADDU V0, ZERO, ZERO
9D002E34  00601021   ADDU V0, V1, ZERO
9D002E38  304200FF   ANDI V0, V0, 255
9D002E3C  00401821   ADDU V1, V0, ZERO
9D002E40  3C02BF80   LUI V0, -16512
9D002E44  AC437040   SW V1, 28736(V0)
9D002E48  3C02BF80   LUI V0, -16512
9D002E4C  8C427010   LW V0, 28688(V0)
9D002E50  30428000   ANDI V0, V0, -32768
9D002E54  1440FFFC   BNE V0, ZERO, 0x9D002E48
9D002E58  00000000   NOP
9D002E5C  3C03BF88   LUI V1, -16504
9D002E60  8C626060   LW V0, 24672(V1)
9D002E64  7C027BC4   INS V0, ZERO, 15, 1
9D002E68  AC626060   SW V0, 24672(V1)
9D002E6C  3C02BF80   LUI V0, -16512
9D002E70  24030006   ADDIU V1, ZERO, 6
9D002E74  AC437040   SW V1, 28736(V0)
9D002E78  3C02BF80   LUI V0, -16512
9D002E7C  8C427010   LW V0, 28688(V0)
9D002E80  30428000   ANDI V0, V0, -32768
9D002E84  1440FFFC   BNE V0, ZERO, 0x9D002E78
9D002E88  00000000   NOP
9D002E8C  3C03BF88   LUI V1, -16504
9D002E90  8C626060   LW V0, 24672(V1)
9D002E94  24040001   ADDIU A0, ZERO, 1
9D002E98  7C827BC4   INS V0, A0, 15, 1
9D002E9C  AC626060   SW V0, 24672(V1)
9D002EA0  97C3000C   LHU V1, 12(S8)
9D002EA4  00001021   ADDU V0, ZERO, ZERO
9D002EA8  00601021   ADDU V0, V1, ZERO
9D002EAC  7C423A00   EXT V0, V0, 8, 8
9D002EB0  304200FF   ANDI V0, V0, 255
9D002EB4  00401821   ADDU V1, V0, ZERO
9D002EB8  3C02BF80   LUI V0, -16512
9D002EBC  AC437040   SW V1, 28736(V0)
9D002EC0  3C02BF80   LUI V0, -16512
9D002EC4  8C427010   LW V0, 28688(V0)
9D002EC8  30428000   ANDI V0, V0, -32768
9D002ECC  1440FFFC   BNE V0, ZERO, 0x9D002EC0
9D002ED0  00000000   NOP
9D002ED4  3C03BF88   LUI V1, -16504
9D002ED8  8C626060   LW V0, 24672(V1)
9D002EDC  7C027BC4   INS V0, ZERO, 15, 1
9D002EE0  AC626060   SW V0, 24672(V1)
9D002EE4  3C02BF80   LUI V0, -16512
9D002EE8  24030007   ADDIU V1, ZERO, 7
9D002EEC  AC437040   SW V1, 28736(V0)
9D002EF0  3C02BF80   LUI V0, -16512
9D002EF4  8C427010   LW V0, 28688(V0)
9D002EF8  30428000   ANDI V0, V0, -32768
9D002EFC  1440FFFC   BNE V0, ZERO, 0x9D002EF0
9D002F00  00000000   NOP
9D002F04  3C03BF88   LUI V1, -16504
9D002F08  8C626060   LW V0, 24672(V1)
9D002F0C  24040001   ADDIU A0, ZERO, 1
9D002F10  7C827BC4   INS V0, A0, 15, 1
9D002F14  AC626060   SW V0, 24672(V1)
9D002F18  97C3000C   LHU V1, 12(S8)
9D002F1C  00001021   ADDU V0, ZERO, ZERO
9D002F20  00601021   ADDU V0, V1, ZERO
9D002F24  304200FF   ANDI V0, V0, 255
9D002F28  00401821   ADDU V1, V0, ZERO
9D002F2C  3C02BF80   LUI V0, -16512
9D002F30  AC437040   SW V1, 28736(V0)
9D002F34  3C02BF80   LUI V0, -16512
9D002F38  8C427010   LW V0, 28688(V0)
9D002F3C  30428000   ANDI V0, V0, -32768
9D002F40  1440FFFC   BNE V0, ZERO, 0x9D002F34
9D002F44  00000000   NOP
9D002F48  3C03BF88   LUI V1, -16504
9D002F4C  8C626060   LW V0, 24672(V1)
9D002F50  7C027BC4   INS V0, ZERO, 15, 1
9D002F54  AC626060   SW V0, 24672(V1)
9D002F58  3C02BF80   LUI V0, -16512
9D002F5C  24030022   ADDIU V1, ZERO, 34
9D002F60  AC437040   SW V1, 28736(V0)
9D002F64  3C02BF80   LUI V0, -16512
9D002F68  8C427010   LW V0, 28688(V0)
9D002F6C  30428000   ANDI V0, V0, -32768
9D002F70  1440FFFC   BNE V0, ZERO, 0x9D002F64
9D002F74  00000000   NOP
9D002F78  3C03BF88   LUI V1, -16504
9D002F7C  8C626060   LW V0, 24672(V1)
9D002F80  24040001   ADDIU A0, ZERO, 1
9D002F84  7C827BC4   INS V0, A0, 15, 1
9D002F88  AC626060   SW V0, 24672(V1)
9D002F8C  97828198   LHU V0, -32360(GP)
9D002F90  00401821   ADDU V1, V0, ZERO
9D002F94  3C02BF80   LUI V0, -16512
9D002F98  AC437040   SW V1, 28736(V0)
9D002F9C  3C02BF80   LUI V0, -16512
9D002FA0  8C427010   LW V0, 28688(V0)
9D002FA4  30428000   ANDI V0, V0, -32768
9D002FA8  1440FFFC   BNE V0, ZERO, 0x9D002F9C
9D002FAC  00000000   NOP
9D002FB0  3C03BF88   LUI V1, -16504
9D002FB4  8C626060   LW V0, 24672(V1)
9D002FB8  24040001   ADDIU A0, ZERO, 1
9D002FBC  7C827384   INS V0, A0, 14, 1
9D002FC0  AC626060   SW V0, 24672(V1)
9D002FC4  0B400BFD   J 0x9D002FF4
9D002FC8  00000000   NOP
9D002FF4  03C0E821   ADDU SP, S8, ZERO
9D002FF8  8FBE0004   LW S8, 4(SP)
9D002FFC  27BD0008   ADDIU SP, SP, 8
9D003000  03E00008   JR RA
9D003004  00000000   NOP
9D003008  27BDFFF0   ADDIU SP, SP, -16
9D00300C  AFBE000C   SW S8, 12(SP)
9D003010  AFB10008   SW S1, 8(SP)
9D003014  AFB00004   SW S0, 4(SP)
9D003018  03A0F021   ADDU S8, SP, ZERO
9D00301C  00804021   ADDU T0, A0, ZERO
9D003020  00A02021   ADDU A0, A1, ZERO
9D003024  00C01821   ADDU V1, A2, ZERO
9D003028  00E01021   ADDU V0, A3, ZERO
9D00302C  A7C80010   SH T0, 16(S8)
9D003030  A7C40014   SH A0, 20(S8)
9D003034  A7C30018   SH V1, 24(S8)
9D003038  A7C2001C   SH V0, 28(S8)
9D00303C  8782819C   LH V0, -32356(GP)
9D003040  1040001D   BEQ V0, ZERO, 0x9D0030B8
9D003044  00000000   NOP
9D003048  8782819A   LH V0, -32358(GP)
9D00304C  87C30010   LH V1, 16(S8)
9D003050  0062102A   SLT V0, V1, V0
9D003054  10400003   BEQ V0, ZERO, 0x9D003064
9D003058  00000000   NOP
9D00305C  9782819A   LHU V0, -32358(GP)
9D003060  A7C20010   SH V0, 16(S8)
9D003064  8782819E   LH V0, -32354(GP)
9D003068  87C30018   LH V1, 24(S8)
9D00306C  0043102A   SLT V0, V0, V1
9D003070  10400003   BEQ V0, ZERO, 0x9D003080
9D003074  00000000   NOP
9D003078  9782819E   LHU V0, -32354(GP)
9D00307C  A7C20018   SH V0, 24(S8)
9D003080  87828194   LH V0, -32364(GP)
9D003084  87C30014   LH V1, 20(S8)
9D003088  0062102A   SLT V0, V1, V0
9D00308C  10400003   BEQ V0, ZERO, 0x9D00309C
9D003090  00000000   NOP
9D003094  97828194   LHU V0, -32364(GP)
9D003098  A7C20014   SH V0, 20(S8)
9D00309C  87828196   LH V0, -32362(GP)
9D0030A0  87C3001C   LH V1, 28(S8)
9D0030A4  0043102A   SLT V0, V0, V1
9D0030A8  10400003   BEQ V0, ZERO, 0x9D0030B8
9D0030AC  00000000   NOP
9D0030B0  97828196   LHU V0, -32362(GP)
9D0030B4  A7C2001C   SH V0, 28(S8)
9D0030B8  3C03BF88   LUI V1, -16504
9D0030BC  8C626060   LW V0, 24672(V1)
9D0030C0  7C027384   INS V0, ZERO, 14, 1
9D0030C4  AC626060   SW V0, 24672(V1)
9D0030C8  87D00014   LH S0, 20(S8)
9D0030CC  0B400CD2   J 0x9D003348
9D0030D0  00000000   NOP
9D003340  26020001   ADDIU V0, S0, 1
9D003344  7C028620   SEH S0, V0
9D003348  02001821   ADDU V1, S0, ZERO
9D00334C  87C2001C   LH V0, 28(S8)
9D003350  24420001   ADDIU V0, V0, 1
9D003354  0062102A   SLT V0, V1, V0
9D003358  1440FF5E   BNE V0, ZERO, 0x9D0030D4
9D00335C  00000000   NOP
9D0030D4  3C03BF88   LUI V1, -16504
9D0030D8  8C626060   LW V0, 24672(V1)
9D0030DC  7C027BC4   INS V0, ZERO, 15, 1
9D0030E0  AC626060   SW V0, 24672(V1)
9D0030E4  3C02BF80   LUI V0, -16512
9D0030E8  24030002   ADDIU V1, ZERO, 2
9D0030EC  AC437040   SW V1, 28736(V0)
9D0030F0  3C02BF80   LUI V0, -16512
9D0030F4  8C427010   LW V0, 28688(V0)
9D0030F8  30428000   ANDI V0, V0, -32768
9D0030FC  1440FFFC   BNE V0, ZERO, 0x9D0030F0
9D003100  00000000   NOP
9D003104  3C03BF88   LUI V1, -16504
9D003108  8C626060   LW V0, 24672(V1)
9D00310C  24040001   ADDIU A0, ZERO, 1
9D003110  7C827BC4   INS V0, A0, 15, 1
9D003114  AC626060   SW V0, 24672(V1)
9D003118  97C30010   LHU V1, 16(S8)
9D00311C  00001021   ADDU V0, ZERO, ZERO
9D003120  00601021   ADDU V0, V1, ZERO
9D003124  7C423A00   EXT V0, V0, 8, 8
9D003128  304200FF   ANDI V0, V0, 255
9D00312C  00401821   ADDU V1, V0, ZERO
9D003130  3C02BF80   LUI V0, -16512
9D003134  AC437040   SW V1, 28736(V0)
9D003138  3C02BF80   LUI V0, -16512
9D00313C  8C427010   LW V0, 28688(V0)
9D003140  30428000   ANDI V0, V0, -32768
9D003144  1440FFFC   BNE V0, ZERO, 0x9D003138
9D003148  00000000   NOP
9D00314C  3C03BF88   LUI V1, -16504
9D003150  8C626060   LW V0, 24672(V1)
9D003154  7C027BC4   INS V0, ZERO, 15, 1
9D003158  AC626060   SW V0, 24672(V1)
9D00315C  3C02BF80   LUI V0, -16512
9D003160  24030003   ADDIU V1, ZERO, 3
9D003164  AC437040   SW V1, 28736(V0)
9D003168  3C02BF80   LUI V0, -16512
9D00316C  8C427010   LW V0, 28688(V0)
9D003170  30428000   ANDI V0, V0, -32768
9D003174  1440FFFC   BNE V0, ZERO, 0x9D003168
9D003178  00000000   NOP
9D00317C  3C03BF88   LUI V1, -16504
9D003180  8C626060   LW V0, 24672(V1)
9D003184  24040001   ADDIU A0, ZERO, 1
9D003188  7C827BC4   INS V0, A0, 15, 1
9D00318C  AC626060   SW V0, 24672(V1)
9D003190  97C30010   LHU V1, 16(S8)
9D003194  00001021   ADDU V0, ZERO, ZERO
9D003198  00601021   ADDU V0, V1, ZERO
9D00319C  304200FF   ANDI V0, V0, 255
9D0031A0  00401821   ADDU V1, V0, ZERO
9D0031A4  3C02BF80   LUI V0, -16512
9D0031A8  AC437040   SW V1, 28736(V0)
9D0031AC  3C02BF80   LUI V0, -16512
9D0031B0  8C427010   LW V0, 28688(V0)
9D0031B4  30428000   ANDI V0, V0, -32768
9D0031B8  1440FFFC   BNE V0, ZERO, 0x9D0031AC
9D0031BC  00000000   NOP
9D0031C0  3C03BF88   LUI V1, -16504
9D0031C4  8C626060   LW V0, 24672(V1)
9D0031C8  7C027BC4   INS V0, ZERO, 15, 1
9D0031CC  AC626060   SW V0, 24672(V1)
9D0031D0  3C02BF80   LUI V0, -16512
9D0031D4  24030006   ADDIU V1, ZERO, 6
9D0031D8  AC437040   SW V1, 28736(V0)
9D0031DC  3C02BF80   LUI V0, -16512
9D0031E0  8C427010   LW V0, 28688(V0)
9D0031E4  30428000   ANDI V0, V0, -32768
9D0031E8  1440FFFC   BNE V0, ZERO, 0x9D0031DC
9D0031EC  00000000   NOP
9D0031F0  3C03BF88   LUI V1, -16504
9D0031F4  8C626060   LW V0, 24672(V1)
9D0031F8  24040001   ADDIU A0, ZERO, 1
9D0031FC  7C827BC4   INS V0, A0, 15, 1
9D003200  AC626060   SW V0, 24672(V1)
9D003204  3203FFFF   ANDI V1, S0, -1
9D003208  00001021   ADDU V0, ZERO, ZERO
9D00320C  00601021   ADDU V0, V1, ZERO
9D003210  7C423A00   EXT V0, V0, 8, 8
9D003214  304200FF   ANDI V0, V0, 255
9D003218  00401821   ADDU V1, V0, ZERO
9D00321C  3C02BF80   LUI V0, -16512
9D003220  AC437040   SW V1, 28736(V0)
9D003224  3C02BF80   LUI V0, -16512
9D003228  8C427010   LW V0, 28688(V0)
9D00322C  30428000   ANDI V0, V0, -32768
9D003230  1440FFFC   BNE V0, ZERO, 0x9D003224
9D003234  00000000   NOP
9D003238  3C03BF88   LUI V1, -16504
9D00323C  8C626060   LW V0, 24672(V1)
9D003240  7C027BC4   INS V0, ZERO, 15, 1
9D003244  AC626060   SW V0, 24672(V1)
9D003248  3C02BF80   LUI V0, -16512
9D00324C  24030007   ADDIU V1, ZERO, 7
9D003250  AC437040   SW V1, 28736(V0)
9D003254  3C02BF80   LUI V0, -16512
9D003258  8C427010   LW V0, 28688(V0)
9D00325C  30428000   ANDI V0, V0, -32768
9D003260  1440FFFC   BNE V0, ZERO, 0x9D003254
9D003264  00000000   NOP
9D003268  3C03BF88   LUI V1, -16504
9D00326C  8C626060   LW V0, 24672(V1)
9D003270  24040001   ADDIU A0, ZERO, 1
9D003274  7C827BC4   INS V0, A0, 15, 1
9D003278  AC626060   SW V0, 24672(V1)
9D00327C  3203FFFF   ANDI V1, S0, -1
9D003280  00001021   ADDU V0, ZERO, ZERO
9D003284  00601021   ADDU V0, V1, ZERO
9D003288  304200FF   ANDI V0, V0, 255
9D00328C  00401821   ADDU V1, V0, ZERO
9D003290  3C02BF80   LUI V0, -16512
9D003294  AC437040   SW V1, 28736(V0)
9D003298  3C02BF80   LUI V0, -16512
9D00329C  8C427010   LW V0, 28688(V0)
9D0032A0  30428000   ANDI V0, V0, -32768
9D0032A4  1440FFFC   BNE V0, ZERO, 0x9D003298
9D0032A8  00000000   NOP
9D0032AC  3C03BF88   LUI V1, -16504
9D0032B0  8C626060   LW V0, 24672(V1)
9D0032B4  7C027BC4   INS V0, ZERO, 15, 1
9D0032B8  AC626060   SW V0, 24672(V1)
9D0032BC  3C02BF80   LUI V0, -16512
9D0032C0  24030022   ADDIU V1, ZERO, 34
9D0032C4  AC437040   SW V1, 28736(V0)
9D0032C8  3C02BF80   LUI V0, -16512
9D0032CC  8C427010   LW V0, 28688(V0)
9D0032D0  30428000   ANDI V0, V0, -32768
9D0032D4  1440FFFC   BNE V0, ZERO, 0x9D0032C8
9D0032D8  00000000   NOP
9D0032DC  87D10010   LH S1, 16(S8)
9D0032E0  0B400CCA   J 0x9D003328
9D0032E4  00000000   NOP
9D003320  26220001   ADDIU V0, S1, 1
9D003324  7C028E20   SEH S1, V0
9D003328  02201821   ADDU V1, S1, ZERO
9D00332C  87C20018   LH V0, 24(S8)
9D003330  24420001   ADDIU V0, V0, 1
9D003334  0062102A   SLT V0, V1, V0
9D003338  1440FFEB   BNE V0, ZERO, 0x9D0032E8
9D00333C  00000000   NOP
9D0032E8  3C03BF88   LUI V1, -16504
9D0032EC  8C626060   LW V0, 24672(V1)
9D0032F0  24040001   ADDIU A0, ZERO, 1
9D0032F4  7C827BC4   INS V0, A0, 15, 1
9D0032F8  AC626060   SW V0, 24672(V1)
9D0032FC  97828198   LHU V0, -32360(GP)
9D003300  00401821   ADDU V1, V0, ZERO
9D003304  3C02BF80   LUI V0, -16512
9D003308  AC437040   SW V1, 28736(V0)
9D00330C  3C02BF80   LUI V0, -16512
9D003310  8C427010   LW V0, 28688(V0)
9D003314  30428000   ANDI V0, V0, -32768
9D003318  1440FFFC   BNE V0, ZERO, 0x9D00330C
9D00331C  00000000   NOP
9D003360  3C03BF88   LUI V1, -16504
9D003364  8C626060   LW V0, 24672(V1)
9D003368  24040001   ADDIU A0, ZERO, 1
9D00336C  7C827384   INS V0, A0, 14, 1
9D003370  AC626060   SW V0, 24672(V1)
9D003374  24020001   ADDIU V0, ZERO, 1
9D003378  03C0E821   ADDU SP, S8, ZERO
9D00337C  8FBE000C   LW S8, 12(SP)
9D003380  8FB10008   LW S1, 8(SP)
9D003384  8FB00004   LW S0, 4(SP)
9D003388  27BD0010   ADDIU SP, SP, 16
9D00338C  03E00008   JR RA
9D003390  00000000   NOP
9D003394  27BDFFF0   ADDIU SP, SP, -16
9D003398  AFBE000C   SW S8, 12(SP)
9D00339C  03A0F021   ADDU S8, SP, ZERO
9D0033A0  3C03BF88   LUI V1, -16504
9D0033A4  8C626060   LW V0, 24672(V1)
9D0033A8  7C027384   INS V0, ZERO, 14, 1
9D0033AC  AC626060   SW V0, 24672(V1)
9D0033B0  3C03BF88   LUI V1, -16504
9D0033B4  8C626060   LW V0, 24672(V1)
9D0033B8  7C027BC4   INS V0, ZERO, 15, 1
9D0033BC  AC626060   SW V0, 24672(V1)
9D0033C0  3C02BF80   LUI V0, -16512
9D0033C4  24030002   ADDIU V1, ZERO, 2
9D0033C8  AC437040   SW V1, 28736(V0)
9D0033CC  3C02BF80   LUI V0, -16512
9D0033D0  8C427010   LW V0, 28688(V0)
9D0033D4  30428000   ANDI V0, V0, -32768
9D0033D8  1440FFFC   BNE V0, ZERO, 0x9D0033CC
9D0033DC  00000000   NOP
9D0033E0  3C03BF88   LUI V1, -16504
9D0033E4  8C626060   LW V0, 24672(V1)
9D0033E8  24040001   ADDIU A0, ZERO, 1
9D0033EC  7C827BC4   INS V0, A0, 15, 1
9D0033F0  AC626060   SW V0, 24672(V1)
9D0033F4  00001021   ADDU V0, ZERO, ZERO
9D0033F8  7C423A00   EXT V0, V0, 8, 8
9D0033FC  304200FF   ANDI V0, V0, 255
9D003400  00401821   ADDU V1, V0, ZERO
9D003404  3C02BF80   LUI V0, -16512
9D003408  AC437040   SW V1, 28736(V0)
9D00340C  3C02BF80   LUI V0, -16512
9D003410  8C427010   LW V0, 28688(V0)
9D003414  30428000   ANDI V0, V0, -32768
9D003418  1440FFFC   BNE V0, ZERO, 0x9D00340C
9D00341C  00000000   NOP
9D003420  3C03BF88   LUI V1, -16504
9D003424  8C626060   LW V0, 24672(V1)
9D003428  7C027BC4   INS V0, ZERO, 15, 1
9D00342C  AC626060   SW V0, 24672(V1)
9D003430  3C02BF80   LUI V0, -16512
9D003434  24030003   ADDIU V1, ZERO, 3
9D003438  AC437040   SW V1, 28736(V0)
9D00343C  3C02BF80   LUI V0, -16512
9D003440  8C427010   LW V0, 28688(V0)
9D003444  30428000   ANDI V0, V0, -32768
9D003448  1440FFFC   BNE V0, ZERO, 0x9D00343C
9D00344C  00000000   NOP
9D003450  3C03BF88   LUI V1, -16504
9D003454  8C626060   LW V0, 24672(V1)
9D003458  24040001   ADDIU A0, ZERO, 1
9D00345C  7C827BC4   INS V0, A0, 15, 1
9D003460  AC626060   SW V0, 24672(V1)
9D003464  00001021   ADDU V0, ZERO, ZERO
9D003468  304200FF   ANDI V0, V0, 255
9D00346C  00401821   ADDU V1, V0, ZERO
9D003470  3C02BF80   LUI V0, -16512
9D003474  AC437040   SW V1, 28736(V0)
9D003478  3C02BF80   LUI V0, -16512
9D00347C  8C427010   LW V0, 28688(V0)
9D003480  30428000   ANDI V0, V0, -32768
9D003484  1440FFFC   BNE V0, ZERO, 0x9D003478
9D003488  00000000   NOP
9D00348C  3C03BF88   LUI V1, -16504
9D003490  8C626060   LW V0, 24672(V1)
9D003494  7C027BC4   INS V0, ZERO, 15, 1
9D003498  AC626060   SW V0, 24672(V1)
9D00349C  3C02BF80   LUI V0, -16512
9D0034A0  24030006   ADDIU V1, ZERO, 6
9D0034A4  AC437040   SW V1, 28736(V0)
9D0034A8  3C02BF80   LUI V0, -16512
9D0034AC  8C427010   LW V0, 28688(V0)
9D0034B0  30428000   ANDI V0, V0, -32768
9D0034B4  1440FFFC   BNE V0, ZERO, 0x9D0034A8
9D0034B8  00000000   NOP
9D0034BC  3C03BF88   LUI V1, -16504
9D0034C0  8C626060   LW V0, 24672(V1)
9D0034C4  24040001   ADDIU A0, ZERO, 1
9D0034C8  7C827BC4   INS V0, A0, 15, 1
9D0034CC  AC626060   SW V0, 24672(V1)
9D0034D0  00001021   ADDU V0, ZERO, ZERO
9D0034D4  7C423A00   EXT V0, V0, 8, 8
9D0034D8  304200FF   ANDI V0, V0, 255
9D0034DC  00401821   ADDU V1, V0, ZERO
9D0034E0  3C02BF80   LUI V0, -16512
9D0034E4  AC437040   SW V1, 28736(V0)
9D0034E8  3C02BF80   LUI V0, -16512
9D0034EC  8C427010   LW V0, 28688(V0)
9D0034F0  30428000   ANDI V0, V0, -32768
9D0034F4  1440FFFC   BNE V0, ZERO, 0x9D0034E8
9D0034F8  00000000   NOP
9D0034FC  3C03BF88   LUI V1, -16504
9D003500  8C626060   LW V0, 24672(V1)
9D003504  7C027BC4   INS V0, ZERO, 15, 1
9D003508  AC626060   SW V0, 24672(V1)
9D00350C  3C02BF80   LUI V0, -16512
9D003510  24030007   ADDIU V1, ZERO, 7
9D003514  AC437040   SW V1, 28736(V0)
9D003518  3C02BF80   LUI V0, -16512
9D00351C  8C427010   LW V0, 28688(V0)
9D003520  30428000   ANDI V0, V0, -32768
9D003524  1440FFFC   BNE V0, ZERO, 0x9D003518
9D003528  00000000   NOP
9D00352C  3C03BF88   LUI V1, -16504
9D003530  8C626060   LW V0, 24672(V1)
9D003534  24040001   ADDIU A0, ZERO, 1
9D003538  7C827BC4   INS V0, A0, 15, 1
9D00353C  AC626060   SW V0, 24672(V1)
9D003540  00001021   ADDU V0, ZERO, ZERO
9D003544  304200FF   ANDI V0, V0, 255
9D003548  00401821   ADDU V1, V0, ZERO
9D00354C  3C02BF80   LUI V0, -16512
9D003550  AC437040   SW V1, 28736(V0)
9D003554  3C02BF80   LUI V0, -16512
9D003558  8C427010   LW V0, 28688(V0)
9D00355C  30428000   ANDI V0, V0, -32768
9D003560  1440FFFC   BNE V0, ZERO, 0x9D003554
9D003564  00000000   NOP
9D003568  3C03BF88   LUI V1, -16504
9D00356C  8C626060   LW V0, 24672(V1)
9D003570  7C027BC4   INS V0, ZERO, 15, 1
9D003574  AC626060   SW V0, 24672(V1)
9D003578  3C02BF80   LUI V0, -16512
9D00357C  24030022   ADDIU V1, ZERO, 34
9D003580  AC437040   SW V1, 28736(V0)
9D003584  3C02BF80   LUI V0, -16512
9D003588  8C427010   LW V0, 28688(V0)
9D00358C  30428000   ANDI V0, V0, -32768
9D003590  1440FFFC   BNE V0, ZERO, 0x9D003584
9D003594  00000000   NOP
9D003598  AFC00000   SW ZERO, 0(S8)
9D00359C  0B400D7A   J 0x9D0035E8
9D0035A0  00000000   NOP
9D0035DC  8FC20000   LW V0, 0(S8)
9D0035E0  24420001   ADDIU V0, V0, 1
9D0035E4  AFC20000   SW V0, 0(S8)
9D0035E8  8FC30000   LW V1, 0(S8)
9D0035EC  3C020001   LUI V0, 1
9D0035F0  34422C00   ORI V0, V0, 11264
9D0035F4  0062102B   SLTU V0, V1, V0
9D0035F8  1440FFEA   BNE V0, ZERO, 0x9D0035A4
9D0035FC  00000000   NOP
9D0035A4  3C03BF88   LUI V1, -16504
9D0035A8  8C626060   LW V0, 24672(V1)
9D0035AC  24040001   ADDIU A0, ZERO, 1
9D0035B0  7C827BC4   INS V0, A0, 15, 1
9D0035B4  AC626060   SW V0, 24672(V1)
9D0035B8  97828198   LHU V0, -32360(GP)
9D0035BC  00401821   ADDU V1, V0, ZERO
9D0035C0  3C02BF80   LUI V0, -16512
9D0035C4  AC437040   SW V1, 28736(V0)
9D0035C8  3C02BF80   LUI V0, -16512
9D0035CC  8C427010   LW V0, 28688(V0)
9D0035D0  30428000   ANDI V0, V0, -32768
9D0035D4  1440FFFC   BNE V0, ZERO, 0x9D0035C8
9D0035D8  00000000   NOP
9D003600  3C03BF88   LUI V1, -16504
9D003604  8C626060   LW V0, 24672(V1)
9D003608  24040001   ADDIU A0, ZERO, 1
9D00360C  7C827384   INS V0, A0, 14, 1
9D003610  AC626060   SW V0, 24672(V1)
9D003614  03C0E821   ADDU SP, S8, ZERO
9D003618  8FBE000C   LW S8, 12(SP)
9D00361C  27BD0010   ADDIU SP, SP, 16
9D003620  03E00008   JR RA
9D003624  00000000   NOP
9D003628  27BDFFD8   ADDIU SP, SP, -40
9D00362C  AFBF0024   SW RA, 36(SP)
9D003630  AFBE0020   SW S8, 32(SP)
9D003634  03A0F021   ADDU S8, SP, ZERO
9D003638  00A01821   ADDU V1, A1, ZERO
9D00363C  AFC60030   SW A2, 48(S8)
9D003640  00E01021   ADDU V0, A3, ZERO
9D003644  A7C40028   SH A0, 40(S8)
9D003648  A7C3002C   SH V1, 44(S8)
9D00364C  A3C20034   SB V0, 52(S8)
9D003650  97828198   LHU V0, -32360(GP)
9D003654  A7C20010   SH V0, 16(S8)
9D003658  8FC20030   LW V0, 48(S8)
9D00365C  84420000   LH V0, 0(V0)
9D003660  14400045   BNE V0, ZERO, 0x9D003778
9D003664  00000000   NOP
9D003668  8FC20030   LW V0, 48(S8)
9D00366C  8C420004   LW V0, 4(V0)
9D003670  AFC20014   SW V0, 20(S8)
9D003674  8FC20014   LW V0, 20(S8)
9D003678  24420001   ADDIU V0, V0, 1
9D00367C  90420000   LBU V0, 0(V0)
9D003680  A3C20018   SB V0, 24(S8)
9D003684  93C20018   LBU V0, 24(S8)
9D003688  24030004   ADDIU V1, ZERO, 4
9D00368C  1043001B   BEQ V0, V1, 0x9D0036FC
9D003690  00000000   NOP
9D003694  28430005   SLTI V1, V0, 5
9D003698  10600006   BEQ V1, ZERO, 0x9D0036B4
9D00369C  00000000   NOP
9D0036A0  24030001   ADDIU V1, ZERO, 1
9D0036A4  1043000B   BEQ V0, V1, 0x9D0036D4
9D0036A8  00000000   NOP
9D0036B4  24030008   ADDIU V1, ZERO, 8
9D0036B8  1043001A   BEQ V0, V1, 0x9D003724
9D0036BC  00000000   NOP
9D0036C0  24030010   ADDIU V1, ZERO, 16
9D0036C4  10430021   BEQ V0, V1, 0x9D00374C
9D0036C8  00000000   NOP
9D0036D4  87C40028   LH A0, 40(S8)
9D0036D8  87C3002C   LH V1, 44(S8)
9D0036DC  93C20034   LBU V0, 52(S8)
9D0036E0  00602821   ADDU A1, V1, ZERO
9D0036E4  8FC60014   LW A2, 20(S8)
9D0036E8  00403821   ADDU A3, V0, ZERO
9D0036EC  0F400DE8   JAL PutImage1BPP
9D0036F0  00000000   NOP
9D0036F4  0B400DDC   J 0x9D003770
9D0036F8  00000000   NOP
9D0036FC  87C40028   LH A0, 40(S8)
9D003700  87C3002C   LH V1, 44(S8)
9D003704  93C20034   LBU V0, 52(S8)
9D003708  00602821   ADDU A1, V1, ZERO
9D00370C  8FC60014   LW A2, 20(S8)
9D003710  00403821   ADDU A3, V0, ZERO
9D003714  0F400EEE   JAL PutImage4BPP
9D003718  00000000   NOP
9D00371C  0B400DDC   J 0x9D003770
9D003720  00000000   NOP
9D003724  87C40028   LH A0, 40(S8)
9D003728  87C3002C   LH V1, 44(S8)
9D00372C  93C20034   LBU V0, 52(S8)
9D003730  00602821   ADDU A1, V1, ZERO
9D003734  8FC60014   LW A2, 20(S8)
9D003738  00403821   ADDU A3, V0, ZERO
9D00373C  0F400FFC   JAL PutImage8BPP
9D003740  00000000   NOP
9D003744  0B400DDC   J 0x9D003770
9D003748  00000000   NOP
9D00374C  87C40028   LH A0, 40(S8)
9D003750  87C3002C   LH V1, 44(S8)
9D003754  93C20034   LBU V0, 52(S8)
9D003758  00602821   ADDU A1, V1, ZERO
9D00375C  8FC60014   LW A2, 20(S8)
9D003760  00403821   ADDU A3, V0, ZERO
9D003764  0F4010FB   JAL PutImage16BPP
9D003768  00000000   NOP
9D00376C  00000000   NOP
9D0036AC  0B400DDF   J 0x9D00377C
9D0036B0  00000000   NOP
9D0036CC  0B400DDF   J 0x9D00377C
9D0036D0  00000000   NOP
9D003770  0B400DDF   J 0x9D00377C
9D003774  00000000   NOP
9D003778  00000000   NOP
9D00377C  97C20010   LHU V0, 16(S8)
9D003780  A7828198   SH V0, -32360(GP)
9D003784  24020001   ADDIU V0, ZERO, 1
9D003788  03C0E821   ADDU SP, S8, ZERO
9D00378C  8FBF0024   LW RA, 36(SP)
9D003790  8FBE0020   LW S8, 32(SP)
9D003794  27BD0028   ADDIU SP, SP, 40
9D003798  03E00008   JR RA
9D00379C  00000000   NOP
9D0037A0  27BDFFD8   ADDIU SP, SP, -40
9D0037A4  AFBE0024   SW S8, 36(SP)
9D0037A8  AFB10020   SW S1, 32(SP)
9D0037AC  AFB0001C   SW S0, 28(SP)
9D0037B0  03A0F021   ADDU S8, SP, ZERO
9D0037B4  00A01821   ADDU V1, A1, ZERO
9D0037B8  AFC60030   SW A2, 48(S8)
9D0037BC  00E01021   ADDU V0, A3, ZERO
9D0037C0  A7C40028   SH A0, 40(S8)
9D0037C4  A7C3002C   SH V1, 44(S8)
9D0037C8  A3C20034   SB V0, 52(S8)
9D0037CC  8FC20030   LW V0, 48(S8)
9D0037D0  24500002   ADDIU S0, V0, 2
9D0037D4  02001021   ADDU V0, S0, ZERO
9D0037D8  94420000   LHU V0, 0(V0)
9D0037DC  A7C2000A   SH V0, 10(S8)
9D0037E0  26100002   ADDIU S0, S0, 2
9D0037E4  02001021   ADDU V0, S0, ZERO
9D0037E8  94420000   LHU V0, 0(V0)
9D0037EC  A7C2000C   SH V0, 12(S8)
9D0037F0  26100002   ADDIU S0, S0, 2
9D0037F4  02001021   ADDU V0, S0, ZERO
9D0037F8  94420000   LHU V0, 0(V0)
9D0037FC  A7C20010   SH V0, 16(S8)
9D003800  26100002   ADDIU S0, S0, 2
9D003804  02001021   ADDU V0, S0, ZERO
9D003808  94420000   LHU V0, 0(V0)
9D00380C  A7C20012   SH V0, 18(S8)
9D003810  26100002   ADDIU S0, S0, 2
9D003814  3C03BF88   LUI V1, -16504
9D003818  8C626060   LW V0, 24672(V1)
9D00381C  7C027384   INS V0, ZERO, 14, 1
9D003820  AC626060   SW V0, 24672(V1)
9D003824  A7C00004   SH ZERO, 4(S8)
9D003828  0B400EDD   J 0x9D003B74
9D00382C  00000000   NOP
9D003B68  97C20004   LHU V0, 4(S8)
9D003B6C  24420001   ADDIU V0, V0, 1
9D003B70  A7C20004   SH V0, 4(S8)
9D003B74  97C30004   LHU V1, 4(S8)
9D003B78  97C2000A   LHU V0, 10(S8)
9D003B7C  0062102B   SLTU V0, V1, V0
9D003B80  1440FF2B   BNE V0, ZERO, 0x9D003830
9D003B84  00000000   NOP
9D003830  02008821   ADDU S1, S0, ZERO
9D003834  A3C00007   SB ZERO, 7(S8)
9D003838  0B400ED5   J 0x9D003B54
9D00383C  00000000   NOP
9D003B48  93C20007   LBU V0, 7(S8)
9D003B4C  24420001   ADDIU V0, V0, 1
9D003B50  A3C20007   SB V0, 7(S8)
9D003B54  93C30007   LBU V1, 7(S8)
9D003B58  93C20034   LBU V0, 52(S8)
9D003B5C  0062102B   SLTU V0, V1, V0
9D003B60  1440FF37   BNE V0, ZERO, 0x9D003840
9D003B64  00000000   NOP
9D003840  02208021   ADDU S0, S1, ZERO
9D003844  3C03BF88   LUI V1, -16504
9D003848  8C626060   LW V0, 24672(V1)
9D00384C  7C027BC4   INS V0, ZERO, 15, 1
9D003850  AC626060   SW V0, 24672(V1)
9D003854  3C02BF80   LUI V0, -16512
9D003858  24030002   ADDIU V1, ZERO, 2
9D00385C  AC437040   SW V1, 28736(V0)
9D003860  3C02BF80   LUI V0, -16512
9D003864  8C427010   LW V0, 28688(V0)
9D003868  30428000   ANDI V0, V0, -32768
9D00386C  1440FFFC   BNE V0, ZERO, 0x9D003860
9D003870  00000000   NOP
9D003874  3C03BF88   LUI V1, -16504
9D003878  8C626060   LW V0, 24672(V1)
9D00387C  24040001   ADDIU A0, ZERO, 1
9D003880  7C827BC4   INS V0, A0, 15, 1
9D003884  AC626060   SW V0, 24672(V1)
9D003888  97C30028   LHU V1, 40(S8)
9D00388C  00001021   ADDU V0, ZERO, ZERO
9D003890  00601021   ADDU V0, V1, ZERO
9D003894  7C423A00   EXT V0, V0, 8, 8
9D003898  304200FF   ANDI V0, V0, 255
9D00389C  00401821   ADDU V1, V0, ZERO
9D0038A0  3C02BF80   LUI V0, -16512
9D0038A4  AC437040   SW V1, 28736(V0)
9D0038A8  3C02BF80   LUI V0, -16512
9D0038AC  8C427010   LW V0, 28688(V0)
9D0038B0  30428000   ANDI V0, V0, -32768
9D0038B4  1440FFFC   BNE V0, ZERO, 0x9D0038A8
9D0038B8  00000000   NOP
9D0038BC  3C03BF88   LUI V1, -16504
9D0038C0  8C626060   LW V0, 24672(V1)
9D0038C4  7C027BC4   INS V0, ZERO, 15, 1
9D0038C8  AC626060   SW V0, 24672(V1)
9D0038CC  3C02BF80   LUI V0, -16512
9D0038D0  24030003   ADDIU V1, ZERO, 3
9D0038D4  AC437040   SW V1, 28736(V0)
9D0038D8  3C02BF80   LUI V0, -16512
9D0038DC  8C427010   LW V0, 28688(V0)
9D0038E0  30428000   ANDI V0, V0, -32768
9D0038E4  1440FFFC   BNE V0, ZERO, 0x9D0038D8
9D0038E8  00000000   NOP
9D0038EC  3C03BF88   LUI V1, -16504
9D0038F0  8C626060   LW V0, 24672(V1)
9D0038F4  24040001   ADDIU A0, ZERO, 1
9D0038F8  7C827BC4   INS V0, A0, 15, 1
9D0038FC  AC626060   SW V0, 24672(V1)
9D003900  97C30028   LHU V1, 40(S8)
9D003904  00001021   ADDU V0, ZERO, ZERO
9D003908  00601021   ADDU V0, V1, ZERO
9D00390C  304200FF   ANDI V0, V0, 255
9D003910  00401821   ADDU V1, V0, ZERO
9D003914  3C02BF80   LUI V0, -16512
9D003918  AC437040   SW V1, 28736(V0)
9D00391C  3C02BF80   LUI V0, -16512
9D003920  8C427010   LW V0, 28688(V0)
9D003924  30428000   ANDI V0, V0, -32768
9D003928  1440FFFC   BNE V0, ZERO, 0x9D00391C
9D00392C  00000000   NOP
9D003930  3C03BF88   LUI V1, -16504
9D003934  8C626060   LW V0, 24672(V1)
9D003938  7C027BC4   INS V0, ZERO, 15, 1
9D00393C  AC626060   SW V0, 24672(V1)
9D003940  3C02BF80   LUI V0, -16512
9D003944  24030006   ADDIU V1, ZERO, 6
9D003948  AC437040   SW V1, 28736(V0)
9D00394C  3C02BF80   LUI V0, -16512
9D003950  8C427010   LW V0, 28688(V0)
9D003954  30428000   ANDI V0, V0, -32768
9D003958  1440FFFC   BNE V0, ZERO, 0x9D00394C
9D00395C  00000000   NOP
9D003960  3C03BF88   LUI V1, -16504
9D003964  8C626060   LW V0, 24672(V1)
9D003968  24040001   ADDIU A0, ZERO, 1
9D00396C  7C827BC4   INS V0, A0, 15, 1
9D003970  AC626060   SW V0, 24672(V1)
9D003974  97C3002C   LHU V1, 44(S8)
9D003978  00001021   ADDU V0, ZERO, ZERO
9D00397C  00601021   ADDU V0, V1, ZERO
9D003980  7C423A00   EXT V0, V0, 8, 8
9D003984  304200FF   ANDI V0, V0, 255
9D003988  00401821   ADDU V1, V0, ZERO
9D00398C  3C02BF80   LUI V0, -16512
9D003990  AC437040   SW V1, 28736(V0)
9D003994  3C02BF80   LUI V0, -16512
9D003998  8C427010   LW V0, 28688(V0)
9D00399C  30428000   ANDI V0, V0, -32768
9D0039A0  1440FFFC   BNE V0, ZERO, 0x9D003994
9D0039A4  00000000   NOP
9D0039A8  3C03BF88   LUI V1, -16504
9D0039AC  8C626060   LW V0, 24672(V1)
9D0039B0  7C027BC4   INS V0, ZERO, 15, 1
9D0039B4  AC626060   SW V0, 24672(V1)
9D0039B8  3C02BF80   LUI V0, -16512
9D0039BC  24030007   ADDIU V1, ZERO, 7
9D0039C0  AC437040   SW V1, 28736(V0)
9D0039C4  3C02BF80   LUI V0, -16512
9D0039C8  8C427010   LW V0, 28688(V0)
9D0039CC  30428000   ANDI V0, V0, -32768
9D0039D0  1440FFFC   BNE V0, ZERO, 0x9D0039C4
9D0039D4  00000000   NOP
9D0039D8  3C03BF88   LUI V1, -16504
9D0039DC  8C626060   LW V0, 24672(V1)
9D0039E0  24040001   ADDIU A0, ZERO, 1
9D0039E4  7C827BC4   INS V0, A0, 15, 1
9D0039E8  AC626060   SW V0, 24672(V1)
9D0039EC  97C3002C   LHU V1, 44(S8)
9D0039F0  00001021   ADDU V0, ZERO, ZERO
9D0039F4  00601021   ADDU V0, V1, ZERO
9D0039F8  304200FF   ANDI V0, V0, 255
9D0039FC  00401821   ADDU V1, V0, ZERO
9D003A00  3C02BF80   LUI V0, -16512
9D003A04  AC437040   SW V1, 28736(V0)
9D003A08  3C02BF80   LUI V0, -16512
9D003A0C  8C427010   LW V0, 28688(V0)
9D003A10  30428000   ANDI V0, V0, -32768
9D003A14  1440FFFC   BNE V0, ZERO, 0x9D003A08
9D003A18  00000000   NOP
9D003A1C  3C03BF88   LUI V1, -16504
9D003A20  8C626060   LW V0, 24672(V1)
9D003A24  7C027BC4   INS V0, ZERO, 15, 1
9D003A28  AC626060   SW V0, 24672(V1)
9D003A2C  3C02BF80   LUI V0, -16512
9D003A30  24030022   ADDIU V1, ZERO, 34
9D003A34  AC437040   SW V1, 28736(V0)
9D003A38  3C02BF80   LUI V0, -16512
9D003A3C  8C427010   LW V0, 28688(V0)
9D003A40  30428000   ANDI V0, V0, -32768
9D003A44  1440FFFC   BNE V0, ZERO, 0x9D003A38
9D003A48  00000000   NOP
9D003A4C  A3C00008   SB ZERO, 8(S8)
9D003A50  A7C00002   SH ZERO, 2(S8)
9D003A54  0B400ECA   J 0x9D003B28
9D003A58  00000000   NOP
9D003B1C  97C20002   LHU V0, 2(S8)
9D003B20  24420001   ADDIU V0, V0, 1
9D003B24  A7C20002   SH V0, 2(S8)
9D003B28  97C30002   LHU V1, 2(S8)
9D003B2C  97C2000C   LHU V0, 12(S8)
9D003B30  0062102B   SLTU V0, V1, V0
9D003B34  1440FFC9   BNE V0, ZERO, 0x9D003A5C
9D003B38  00000000   NOP
9D003A5C  93C20008   LBU V0, 8(S8)
9D003A60  14400006   BNE V0, ZERO, 0x9D003A7C
9D003A64  00000000   NOP
9D003A68  92020000   LBU V0, 0(S0)
9D003A6C  A3C20000   SB V0, 0(S8)
9D003A70  26100001   ADDIU S0, S0, 1
9D003A74  2402FF80   ADDIU V0, ZERO, -128
9D003A78  A3C20008   SB V0, 8(S8)
9D003A7C  93C30008   LBU V1, 8(S8)
9D003A80  93C20000   LBU V0, 0(S8)
9D003A84  00621024   AND V0, V1, V0
9D003A88  304200FF   ANDI V0, V0, 255
9D003A8C  10400005   BEQ V0, ZERO, 0x9D003AA4
9D003A90  00000000   NOP
9D003A94  97C20012   LHU V0, 18(S8)
9D003A98  A7828198   SH V0, -32360(GP)
9D003A9C  0B400EAB   J 0x9D003AAC
9D003AA0  00000000   NOP
9D003AA4  97C20010   LHU V0, 16(S8)
9D003AA8  A7828198   SH V0, -32360(GP)
9D003AAC  A3C00006   SB ZERO, 6(S8)
9D003AB0  0B400EBF   J 0x9D003AFC
9D003AB4  00000000   NOP
9D003AF0  93C20006   LBU V0, 6(S8)
9D003AF4  24420001   ADDIU V0, V0, 1
9D003AF8  A3C20006   SB V0, 6(S8)
9D003AFC  93C30006   LBU V1, 6(S8)
9D003B00  93C20034   LBU V0, 52(S8)
9D003B04  0062102B   SLTU V0, V1, V0
9D003B08  1440FFEB   BNE V0, ZERO, 0x9D003AB8
9D003B0C  00000000   NOP
9D003AB8  3C03BF88   LUI V1, -16504
9D003ABC  8C626060   LW V0, 24672(V1)
9D003AC0  24040001   ADDIU A0, ZERO, 1
9D003AC4  7C827BC4   INS V0, A0, 15, 1
9D003AC8  AC626060   SW V0, 24672(V1)
9D003ACC  97828198   LHU V0, -32360(GP)
9D003AD0  00401821   ADDU V1, V0, ZERO
9D003AD4  3C02BF80   LUI V0, -16512
9D003AD8  AC437040   SW V1, 28736(V0)
9D003ADC  3C02BF80   LUI V0, -16512
9D003AE0  8C427010   LW V0, 28688(V0)
9D003AE4  30428000   ANDI V0, V0, -32768
9D003AE8  1440FFFC   BNE V0, ZERO, 0x9D003ADC
9D003AEC  00000000   NOP
9D003B10  93C20008   LBU V0, 8(S8)
9D003B14  00021042   SRL V0, V0, 1
9D003B18  A3C20008   SB V0, 8(S8)
9D003B3C  97C2002C   LHU V0, 44(S8)
9D003B40  24420001   ADDIU V0, V0, 1
9D003B44  A7C2002C   SH V0, 44(S8)
9D003B88  3C03BF88   LUI V1, -16504
9D003B8C  8C626060   LW V0, 24672(V1)
9D003B90  24040001   ADDIU A0, ZERO, 1
9D003B94  7C827384   INS V0, A0, 14, 1
9D003B98  AC626060   SW V0, 24672(V1)
9D003B9C  03C0E821   ADDU SP, S8, ZERO
9D003BA0  8FBE0024   LW S8, 36(SP)
9D003BA4  8FB10020   LW S1, 32(SP)
9D003BA8  8FB0001C   LW S0, 28(SP)
9D003BAC  27BD0028   ADDIU SP, SP, 40
9D003BB0  03E00008   JR RA
9D003BB4  00000000   NOP
9D003BB8  27BDFFB8   ADDIU SP, SP, -72
9D003BBC  AFBE0044   SW S8, 68(SP)
9D003BC0  AFB50040   SW S5, 64(SP)
9D003BC4  AFB4003C   SW S4, 60(SP)
9D003BC8  AFB30038   SW S3, 56(SP)
9D003BCC  AFB20034   SW S2, 52(SP)
9D003BD0  AFB10030   SW S1, 48(SP)
9D003BD4  AFB0002C   SW S0, 44(SP)
9D003BD8  03A0F021   ADDU S8, SP, ZERO
9D003BDC  00A01821   ADDU V1, A1, ZERO
9D003BE0  AFC60050   SW A2, 80(S8)
9D003BE4  00E01021   ADDU V0, A3, ZERO
9D003BE8  A7C40048   SH A0, 72(S8)
9D003BEC  A7C3004C   SH V1, 76(S8)
9D003BF0  A3C20054   SB V0, 84(S8)
9D003BF4  8FC20050   LW V0, 80(S8)
9D003BF8  24500002   ADDIU S0, V0, 2
9D003BFC  02001021   ADDU V0, S0, ZERO
9D003C00  94420000   LHU V0, 0(V0)
9D003C04  A7C20004   SH V0, 4(S8)
9D003C08  26100002   ADDIU S0, S0, 2
9D003C0C  02001021   ADDU V0, S0, ZERO
9D003C10  94420000   LHU V0, 0(V0)
9D003C14  A7C20006   SH V0, 6(S8)
9D003C18  26100002   ADDIU S0, S0, 2
9D003C1C  A7C00002   SH ZERO, 2(S8)
9D003C20  0B400F14   J 0x9D003C50
9D003C24  00000000   NOP
9D003C44  97C20002   LHU V0, 2(S8)
9D003C48  24420001   ADDIU V0, V0, 1
9D003C4C  A7C20002   SH V0, 2(S8)
9D003C50  97C20002   LHU V0, 2(S8)
9D003C54  2C420010   SLTIU V0, V0, 16
9D003C58  1440FFF3   BNE V0, ZERO, 0x9D003C28
9D003C5C  00000000   NOP
9D003C28  97C20002   LHU V0, 2(S8)
9D003C2C  02001821   ADDU V1, S0, ZERO
9D003C30  94630000   LHU V1, 0(V1)
9D003C34  00021040   SLL V0, V0, 1
9D003C38  03C21021   ADDU V0, S8, V0
9D003C3C  A4430008   SH V1, 8(V0)
9D003C40  26100002   ADDIU S0, S0, 2
9D003C60  3C03BF88   LUI V1, -16504
9D003C64  8C626060   LW V0, 24672(V1)
9D003C68  7C027384   INS V0, ZERO, 14, 1
9D003C6C  AC626060   SW V0, 24672(V1)
9D003C70  00009021   ADDU S2, ZERO, ZERO
9D003C74  0B400FE8   J 0x9D003FA0
9D003C78  00000000   NOP
9D003F98  26420001   ADDIU V0, S2, 1
9D003F9C  3052FFFF   ANDI S2, V0, -1
9D003FA0  97C20004   LHU V0, 4(S8)
9D003FA4  0242102B   SLTU V0, S2, V0
9D003FA8  1440FF34   BNE V0, ZERO, 0x9D003C7C
9D003FAC  00000000   NOP
9D003C7C  0200A821   ADDU S5, S0, ZERO
9D003C80  00009821   ADDU S3, ZERO, ZERO
9D003C84  0B400FE2   J 0x9D003F88
9D003C88  00000000   NOP
9D003F80  26620001   ADDIU V0, S3, 1
9D003F84  305300FF   ANDI S3, V0, 255
9D003F88  93C20054   LBU V0, 84(S8)
9D003F8C  0262102B   SLTU V0, S3, V0
9D003F90  1440FF3E   BNE V0, ZERO, 0x9D003C8C
9D003F94  00000000   NOP
9D003C8C  02A08021   ADDU S0, S5, ZERO
9D003C90  3C03BF88   LUI V1, -16504
9D003C94  8C626060   LW V0, 24672(V1)
9D003C98  7C027BC4   INS V0, ZERO, 15, 1
9D003C9C  AC626060   SW V0, 24672(V1)
9D003CA0  3C02BF80   LUI V0, -16512
9D003CA4  24030002   ADDIU V1, ZERO, 2
9D003CA8  AC437040   SW V1, 28736(V0)
9D003CAC  3C02BF80   LUI V0, -16512
9D003CB0  8C427010   LW V0, 28688(V0)
9D003CB4  30428000   ANDI V0, V0, -32768
9D003CB8  1440FFFC   BNE V0, ZERO, 0x9D003CAC
9D003CBC  00000000   NOP
9D003CC0  3C03BF88   LUI V1, -16504
9D003CC4  8C626060   LW V0, 24672(V1)
9D003CC8  24040001   ADDIU A0, ZERO, 1
9D003CCC  7C827BC4   INS V0, A0, 15, 1
9D003CD0  AC626060   SW V0, 24672(V1)
9D003CD4  97C30048   LHU V1, 72(S8)
9D003CD8  00001021   ADDU V0, ZERO, ZERO
9D003CDC  00601021   ADDU V0, V1, ZERO
9D003CE0  7C423A00   EXT V0, V0, 8, 8
9D003CE4  304200FF   ANDI V0, V0, 255
9D003CE8  00401821   ADDU V1, V0, ZERO
9D003CEC  3C02BF80   LUI V0, -16512
9D003CF0  AC437040   SW V1, 28736(V0)
9D003CF4  3C02BF80   LUI V0, -16512
9D003CF8  8C427010   LW V0, 28688(V0)
9D003CFC  30428000   ANDI V0, V0, -32768
9D003D00  1440FFFC   BNE V0, ZERO, 0x9D003CF4
9D003D04  00000000   NOP
9D003D08  3C03BF88   LUI V1, -16504
9D003D0C  8C626060   LW V0, 24672(V1)
9D003D10  7C027BC4   INS V0, ZERO, 15, 1
9D003D14  AC626060   SW V0, 24672(V1)
9D003D18  3C02BF80   LUI V0, -16512
9D003D1C  24030003   ADDIU V1, ZERO, 3
9D003D20  AC437040   SW V1, 28736(V0)
9D003D24  3C02BF80   LUI V0, -16512
9D003D28  8C427010   LW V0, 28688(V0)
9D003D2C  30428000   ANDI V0, V0, -32768
9D003D30  1440FFFC   BNE V0, ZERO, 0x9D003D24
9D003D34  00000000   NOP
9D003D38  3C03BF88   LUI V1, -16504
9D003D3C  8C626060   LW V0, 24672(V1)
9D003D40  24040001   ADDIU A0, ZERO, 1
9D003D44  7C827BC4   INS V0, A0, 15, 1
9D003D48  AC626060   SW V0, 24672(V1)
9D003D4C  97C30048   LHU V1, 72(S8)
9D003D50  00001021   ADDU V0, ZERO, ZERO
9D003D54  00601021   ADDU V0, V1, ZERO
9D003D58  304200FF   ANDI V0, V0, 255
9D003D5C  00401821   ADDU V1, V0, ZERO
9D003D60  3C02BF80   LUI V0, -16512
9D003D64  AC437040   SW V1, 28736(V0)
9D003D68  3C02BF80   LUI V0, -16512
9D003D6C  8C427010   LW V0, 28688(V0)
9D003D70  30428000   ANDI V0, V0, -32768
9D003D74  1440FFFC   BNE V0, ZERO, 0x9D003D68
9D003D78  00000000   NOP
9D003D7C  3C03BF88   LUI V1, -16504
9D003D80  8C626060   LW V0, 24672(V1)
9D003D84  7C027BC4   INS V0, ZERO, 15, 1
9D003D88  AC626060   SW V0, 24672(V1)
9D003D8C  3C02BF80   LUI V0, -16512
9D003D90  24030006   ADDIU V1, ZERO, 6
9D003D94  AC437040   SW V1, 28736(V0)
9D003D98  3C02BF80   LUI V0, -16512
9D003D9C  8C427010   LW V0, 28688(V0)
9D003DA0  30428000   ANDI V0, V0, -32768
9D003DA4  1440FFFC   BNE V0, ZERO, 0x9D003D98
9D003DA8  00000000   NOP
9D003DAC  3C03BF88   LUI V1, -16504
9D003DB0  8C626060   LW V0, 24672(V1)
9D003DB4  24040001   ADDIU A0, ZERO, 1
9D003DB8  7C827BC4   INS V0, A0, 15, 1
9D003DBC  AC626060   SW V0, 24672(V1)
9D003DC0  97C3004C   LHU V1, 76(S8)
9D003DC4  00001021   ADDU V0, ZERO, ZERO
9D003DC8  00601021   ADDU V0, V1, ZERO
9D003DCC  7C423A00   EXT V0, V0, 8, 8
9D003DD0  304200FF   ANDI V0, V0, 255
9D003DD4  00401821   ADDU V1, V0, ZERO
9D003DD8  3C02BF80   LUI V0, -16512
9D003DDC  AC437040   SW V1, 28736(V0)
9D003DE0  3C02BF80   LUI V0, -16512
9D003DE4  8C427010   LW V0, 28688(V0)
9D003DE8  30428000   ANDI V0, V0, -32768
9D003DEC  1440FFFC   BNE V0, ZERO, 0x9D003DE0
9D003DF0  00000000   NOP
9D003DF4  3C03BF88   LUI V1, -16504
9D003DF8  8C626060   LW V0, 24672(V1)
9D003DFC  7C027BC4   INS V0, ZERO, 15, 1
9D003E00  AC626060   SW V0, 24672(V1)
9D003E04  3C02BF80   LUI V0, -16512
9D003E08  24030007   ADDIU V1, ZERO, 7
9D003E0C  AC437040   SW V1, 28736(V0)
9D003E10  3C02BF80   LUI V0, -16512
9D003E14  8C427010   LW V0, 28688(V0)
9D003E18  30428000   ANDI V0, V0, -32768
9D003E1C  1440FFFC   BNE V0, ZERO, 0x9D003E10
9D003E20  00000000   NOP
9D003E24  3C03BF88   LUI V1, -16504
9D003E28  8C626060   LW V0, 24672(V1)
9D003E2C  24040001   ADDIU A0, ZERO, 1
9D003E30  7C827BC4   INS V0, A0, 15, 1
9D003E34  AC626060   SW V0, 24672(V1)
9D003E38  97C3004C   LHU V1, 76(S8)
9D003E3C  00001021   ADDU V0, ZERO, ZERO
9D003E40  00601021   ADDU V0, V1, ZERO
9D003E44  304200FF   ANDI V0, V0, 255
9D003E48  00401821   ADDU V1, V0, ZERO
9D003E4C  3C02BF80   LUI V0, -16512
9D003E50  AC437040   SW V1, 28736(V0)
9D003E54  3C02BF80   LUI V0, -16512
9D003E58  8C427010   LW V0, 28688(V0)
9D003E5C  30428000   ANDI V0, V0, -32768
9D003E60  1440FFFC   BNE V0, ZERO, 0x9D003E54
9D003E64  00000000   NOP
9D003E68  3C03BF88   LUI V1, -16504
9D003E6C  8C626060   LW V0, 24672(V1)
9D003E70  7C027BC4   INS V0, ZERO, 15, 1
9D003E74  AC626060   SW V0, 24672(V1)
9D003E78  3C02BF80   LUI V0, -16512
9D003E7C  24030022   ADDIU V1, ZERO, 34
9D003E80  AC437040   SW V1, 28736(V0)
9D003E84  3C02BF80   LUI V0, -16512
9D003E88  8C427010   LW V0, 28688(V0)
9D003E8C  30428000   ANDI V0, V0, -32768
9D003E90  1440FFFC   BNE V0, ZERO, 0x9D003E84
9D003E94  00000000   NOP
9D003E98  00008821   ADDU S1, ZERO, ZERO
9D003E9C  0B400FD9   J 0x9D003F64
9D003EA0  00000000   NOP
9D003F5C  26220001   ADDIU V0, S1, 1
9D003F60  3051FFFF   ANDI S1, V0, -1
9D003F64  97C20006   LHU V0, 6(S8)
9D003F68  0222102B   SLTU V0, S1, V0
9D003F6C  1440FFCD   BNE V0, ZERO, 0x9D003EA4
9D003F70  00000000   NOP
9D003EA4  02201021   ADDU V0, S1, ZERO
9D003EA8  30420001   ANDI V0, V0, 1
9D003EAC  304200FF   ANDI V0, V0, 255
9D003EB0  1040000A   BEQ V0, ZERO, 0x9D003EDC
9D003EB4  00000000   NOP
9D003EB8  93C20000   LBU V0, 0(S8)
9D003EBC  00021102   SRL V0, V0, 4
9D003EC0  304200FF   ANDI V0, V0, 255
9D003EC4  00021040   SLL V0, V0, 1
9D003EC8  03C21021   ADDU V0, S8, V0
9D003ECC  94420008   LHU V0, 8(V0)
9D003ED0  A7828198   SH V0, -32360(GP)
9D003ED4  0B400FC0   J 0x9D003F00
9D003ED8  00000000   NOP
9D003EDC  92020000   LBU V0, 0(S0)
9D003EE0  A3C20000   SB V0, 0(S8)
9D003EE4  26100001   ADDIU S0, S0, 1
9D003EE8  93C20000   LBU V0, 0(S8)
9D003EEC  3042000F   ANDI V0, V0, 15
9D003EF0  00021040   SLL V0, V0, 1
9D003EF4  03C21021   ADDU V0, S8, V0
9D003EF8  94420008   LHU V0, 8(V0)
9D003EFC  A7828198   SH V0, -32360(GP)
9D003F00  0000A021   ADDU S4, ZERO, ZERO
9D003F04  0B400FD3   J 0x9D003F4C
9D003F08  00000000   NOP
9D003F44  26820001   ADDIU V0, S4, 1
9D003F48  305400FF   ANDI S4, V0, 255
9D003F4C  93C20054   LBU V0, 84(S8)
9D003F50  0282102B   SLTU V0, S4, V0
9D003F54  1440FFED   BNE V0, ZERO, 0x9D003F0C
9D003F58  00000000   NOP
9D003F0C  3C03BF88   LUI V1, -16504
9D003F10  8C626060   LW V0, 24672(V1)
9D003F14  24040001   ADDIU A0, ZERO, 1
9D003F18  7C827BC4   INS V0, A0, 15, 1
9D003F1C  AC626060   SW V0, 24672(V1)
9D003F20  97828198   LHU V0, -32360(GP)
9D003F24  00401821   ADDU V1, V0, ZERO
9D003F28  3C02BF80   LUI V0, -16512
9D003F2C  AC437040   SW V1, 28736(V0)
9D003F30  3C02BF80   LUI V0, -16512
9D003F34  8C427010   LW V0, 28688(V0)
9D003F38  30428000   ANDI V0, V0, -32768
9D003F3C  1440FFFC   BNE V0, ZERO, 0x9D003F30
9D003F40  00000000   NOP
9D003F74  97C2004C   LHU V0, 76(S8)
9D003F78  24420001   ADDIU V0, V0, 1
9D003F7C  A7C2004C   SH V0, 76(S8)
9D003FB0  3C03BF88   LUI V1, -16504
9D003FB4  8C626060   LW V0, 24672(V1)
9D003FB8  24040001   ADDIU A0, ZERO, 1
9D003FBC  7C827384   INS V0, A0, 14, 1
9D003FC0  AC626060   SW V0, 24672(V1)
9D003FC4  03C0E821   ADDU SP, S8, ZERO
9D003FC8  8FBE0044   LW S8, 68(SP)
9D003FCC  8FB50040   LW S5, 64(SP)
9D003FD0  8FB4003C   LW S4, 60(SP)
9D003FD4  8FB30038   LW S3, 56(SP)
9D003FD8  8FB20034   LW S2, 52(SP)
9D003FDC  8FB10030   LW S1, 48(SP)
9D003FE0  8FB0002C   LW S0, 44(SP)
9D003FE4  27BD0048   ADDIU SP, SP, 72
9D003FE8  03E00008   JR RA
9D003FEC  00000000   NOP
9D003FF0  27BDFDE0   ADDIU SP, SP, -544
9D003FF4  AFBE021C   SW S8, 540(SP)
9D003FF8  AFB10218   SW S1, 536(SP)
9D003FFC  AFB00214   SW S0, 532(SP)
9D004000  03A0F021   ADDU S8, SP, ZERO
9D004004  00A01821   ADDU V1, A1, ZERO
9D004008  AFC60228   SW A2, 552(S8)
9D00400C  00E01021   ADDU V0, A3, ZERO
9D004010  A7C40220   SH A0, 544(S8)
9D004014  A7C30224   SH V1, 548(S8)
9D004018  A3C2022C   SB V0, 556(S8)
9D00401C  8FC20228   LW V0, 552(S8)
9D004020  24500002   ADDIU S0, V0, 2
9D004024  02001021   ADDU V0, S0, ZERO
9D004028  94420000   LHU V0, 0(V0)
9D00402C  A7C20008   SH V0, 8(S8)
9D004030  26100002   ADDIU S0, S0, 2
9D004034  02001021   ADDU V0, S0, ZERO
9D004038  94420000   LHU V0, 0(V0)
9D00403C  A7C2000A   SH V0, 10(S8)
9D004040  26100002   ADDIU S0, S0, 2
9D004044  A7C00006   SH ZERO, 6(S8)
9D004048  0B40101E   J 0x9D004078
9D00404C  00000000   NOP
9D00406C  97C20006   LHU V0, 6(S8)
9D004070  24420001   ADDIU V0, V0, 1
9D004074  A7C20006   SH V0, 6(S8)
9D004078  97C20006   LHU V0, 6(S8)
9D00407C  2C420100   SLTIU V0, V0, 256
9D004080  1440FFF3   BNE V0, ZERO, 0x9D004050
9D004084  00000000   NOP
9D004050  97C20006   LHU V0, 6(S8)
9D004054  02001821   ADDU V1, S0, ZERO
9D004058  94630000   LHU V1, 0(V1)
9D00405C  00021040   SLL V0, V0, 1
9D004060  03C21021   ADDU V0, S8, V0
9D004064  A4430010   SH V1, 16(V0)
9D004068  26100002   ADDIU S0, S0, 2
9D004088  3C03BF88   LUI V1, -16504
9D00408C  8C626060   LW V0, 24672(V1)
9D004090  7C027384   INS V0, ZERO, 14, 1
9D004094  AC626060   SW V0, 24672(V1)
9D004098  A7C00002   SH ZERO, 2(S8)
9D00409C  0B4010EA   J 0x9D0043A8
9D0040A0  00000000   NOP
9D00439C  97C20002   LHU V0, 2(S8)
9D0043A0  24420001   ADDIU V0, V0, 1
9D0043A4  A7C20002   SH V0, 2(S8)
9D0043A8  97C30002   LHU V1, 2(S8)
9D0043AC  97C20008   LHU V0, 8(S8)
9D0043B0  0062102B   SLTU V0, V1, V0
9D0043B4  1440FF3B   BNE V0, ZERO, 0x9D0040A4
9D0043B8  00000000   NOP
9D0040A4  02008821   ADDU S1, S0, ZERO
9D0040A8  A3C00005   SB ZERO, 5(S8)
9D0040AC  0B4010E2   J 0x9D004388
9D0040B0  00000000   NOP
9D00437C  93C20005   LBU V0, 5(S8)
9D004380  24420001   ADDIU V0, V0, 1
9D004384  A3C20005   SB V0, 5(S8)
9D004388  93C30005   LBU V1, 5(S8)
9D00438C  93C2022C   LBU V0, 556(S8)
9D004390  0062102B   SLTU V0, V1, V0
9D004394  1440FF47   BNE V0, ZERO, 0x9D0040B4
9D004398  00000000   NOP
9D0040B4  02208021   ADDU S0, S1, ZERO
9D0040B8  3C03BF88   LUI V1, -16504
9D0040BC  8C626060   LW V0, 24672(V1)
9D0040C0  7C027BC4   INS V0, ZERO, 15, 1
9D0040C4  AC626060   SW V0, 24672(V1)
9D0040C8  3C02BF80   LUI V0, -16512
9D0040CC  24030002   ADDIU V1, ZERO, 2
9D0040D0  AC437040   SW V1, 28736(V0)
9D0040D4  3C02BF80   LUI V0, -16512
9D0040D8  8C427010   LW V0, 28688(V0)
9D0040DC  30428000   ANDI V0, V0, -32768
9D0040E0  1440FFFC   BNE V0, ZERO, 0x9D0040D4
9D0040E4  00000000   NOP
9D0040E8  3C03BF88   LUI V1, -16504
9D0040EC  8C626060   LW V0, 24672(V1)
9D0040F0  24040001   ADDIU A0, ZERO, 1
9D0040F4  7C827BC4   INS V0, A0, 15, 1
9D0040F8  AC626060   SW V0, 24672(V1)
9D0040FC  97C30220   LHU V1, 544(S8)
9D004100  00001021   ADDU V0, ZERO, ZERO
9D004104  00601021   ADDU V0, V1, ZERO
9D004108  7C423A00   EXT V0, V0, 8, 8
9D00410C  304200FF   ANDI V0, V0, 255
9D004110  00401821   ADDU V1, V0, ZERO
9D004114  3C02BF80   LUI V0, -16512
9D004118  AC437040   SW V1, 28736(V0)
9D00411C  3C02BF80   LUI V0, -16512
9D004120  8C427010   LW V0, 28688(V0)
9D004124  30428000   ANDI V0, V0, -32768
9D004128  1440FFFC   BNE V0, ZERO, 0x9D00411C
9D00412C  00000000   NOP
9D004130  3C03BF88   LUI V1, -16504
9D004134  8C626060   LW V0, 24672(V1)
9D004138  7C027BC4   INS V0, ZERO, 15, 1
9D00413C  AC626060   SW V0, 24672(V1)
9D004140  3C02BF80   LUI V0, -16512
9D004144  24030003   ADDIU V1, ZERO, 3
9D004148  AC437040   SW V1, 28736(V0)
9D00414C  3C02BF80   LUI V0, -16512
9D004150  8C427010   LW V0, 28688(V0)
9D004154  30428000   ANDI V0, V0, -32768
9D004158  1440FFFC   BNE V0, ZERO, 0x9D00414C
9D00415C  00000000   NOP
9D004160  3C03BF88   LUI V1, -16504
9D004164  8C626060   LW V0, 24672(V1)
9D004168  24040001   ADDIU A0, ZERO, 1
9D00416C  7C827BC4   INS V0, A0, 15, 1
9D004170  AC626060   SW V0, 24672(V1)
9D004174  97C30220   LHU V1, 544(S8)
9D004178  00001021   ADDU V0, ZERO, ZERO
9D00417C  00601021   ADDU V0, V1, ZERO
9D004180  304200FF   ANDI V0, V0, 255
9D004184  00401821   ADDU V1, V0, ZERO
9D004188  3C02BF80   LUI V0, -16512
9D00418C  AC437040   SW V1, 28736(V0)
9D004190  3C02BF80   LUI V0, -16512
9D004194  8C427010   LW V0, 28688(V0)
9D004198  30428000   ANDI V0, V0, -32768
9D00419C  1440FFFC   BNE V0, ZERO, 0x9D004190
9D0041A0  00000000   NOP
9D0041A4  3C03BF88   LUI V1, -16504
9D0041A8  8C626060   LW V0, 24672(V1)
9D0041AC  7C027BC4   INS V0, ZERO, 15, 1
9D0041B0  AC626060   SW V0, 24672(V1)
9D0041B4  3C02BF80   LUI V0, -16512
9D0041B8  24030006   ADDIU V1, ZERO, 6
9D0041BC  AC437040   SW V1, 28736(V0)
9D0041C0  3C02BF80   LUI V0, -16512
9D0041C4  8C427010   LW V0, 28688(V0)
9D0041C8  30428000   ANDI V0, V0, -32768
9D0041CC  1440FFFC   BNE V0, ZERO, 0x9D0041C0
9D0041D0  00000000   NOP
9D0041D4  3C03BF88   LUI V1, -16504
9D0041D8  8C626060   LW V0, 24672(V1)
9D0041DC  24040001   ADDIU A0, ZERO, 1
9D0041E0  7C827BC4   INS V0, A0, 15, 1
9D0041E4  AC626060   SW V0, 24672(V1)
9D0041E8  97C30224   LHU V1, 548(S8)
9D0041EC  00001021   ADDU V0, ZERO, ZERO
9D0041F0  00601021   ADDU V0, V1, ZERO
9D0041F4  7C423A00   EXT V0, V0, 8, 8
9D0041F8  304200FF   ANDI V0, V0, 255
9D0041FC  00401821   ADDU V1, V0, ZERO
9D004200  3C02BF80   LUI V0, -16512
9D004204  AC437040   SW V1, 28736(V0)
9D004208  3C02BF80   LUI V0, -16512
9D00420C  8C427010   LW V0, 28688(V0)
9D004210  30428000   ANDI V0, V0, -32768
9D004214  1440FFFC   BNE V0, ZERO, 0x9D004208
9D004218  00000000   NOP
9D00421C  3C03BF88   LUI V1, -16504
9D004220  8C626060   LW V0, 24672(V1)
9D004224  7C027BC4   INS V0, ZERO, 15, 1
9D004228  AC626060   SW V0, 24672(V1)
9D00422C  3C02BF80   LUI V0, -16512
9D004230  24030007   ADDIU V1, ZERO, 7
9D004234  AC437040   SW V1, 28736(V0)
9D004238  3C02BF80   LUI V0, -16512
9D00423C  8C427010   LW V0, 28688(V0)
9D004240  30428000   ANDI V0, V0, -32768
9D004244  1440FFFC   BNE V0, ZERO, 0x9D004238
9D004248  00000000   NOP
9D00424C  3C03BF88   LUI V1, -16504
9D004250  8C626060   LW V0, 24672(V1)
9D004254  24040001   ADDIU A0, ZERO, 1
9D004258  7C827BC4   INS V0, A0, 15, 1
9D00425C  AC626060   SW V0, 24672(V1)
9D004260  97C30224   LHU V1, 548(S8)
9D004264  00001021   ADDU V0, ZERO, ZERO
9D004268  00601021   ADDU V0, V1, ZERO
9D00426C  304200FF   ANDI V0, V0, 255
9D004270  00401821   ADDU V1, V0, ZERO
9D004274  3C02BF80   LUI V0, -16512
9D004278  AC437040   SW V1, 28736(V0)
9D00427C  3C02BF80   LUI V0, -16512
9D004280  8C427010   LW V0, 28688(V0)
9D004284  30428000   ANDI V0, V0, -32768
9D004288  1440FFFC   BNE V0, ZERO, 0x9D00427C
9D00428C  00000000   NOP
9D004290  3C03BF88   LUI V1, -16504
9D004294  8C626060   LW V0, 24672(V1)
9D004298  7C027BC4   INS V0, ZERO, 15, 1
9D00429C  AC626060   SW V0, 24672(V1)
9D0042A0  3C02BF80   LUI V0, -16512
9D0042A4  24030022   ADDIU V1, ZERO, 34
9D0042A8  AC437040   SW V1, 28736(V0)
9D0042AC  3C02BF80   LUI V0, -16512
9D0042B0  8C427010   LW V0, 28688(V0)
9D0042B4  30428000   ANDI V0, V0, -32768
9D0042B8  1440FFFC   BNE V0, ZERO, 0x9D0042AC
9D0042BC  00000000   NOP
9D0042C0  A7C00000   SH ZERO, 0(S8)
9D0042C4  0B4010D7   J 0x9D00435C
9D0042C8  00000000   NOP
9D004350  97C20000   LHU V0, 0(S8)
9D004354  24420001   ADDIU V0, V0, 1
9D004358  A7C20000   SH V0, 0(S8)
9D00435C  97C30000   LHU V1, 0(S8)
9D004360  97C2000A   LHU V0, 10(S8)
9D004364  0062102B   SLTU V0, V1, V0
9D004368  1440FFD8   BNE V0, ZERO, 0x9D0042CC
9D00436C  00000000   NOP
9D0042CC  92020000   LBU V0, 0(S0)
9D0042D0  A3C2000C   SB V0, 12(S8)
9D0042D4  26100001   ADDIU S0, S0, 1
9D0042D8  93C2000C   LBU V0, 12(S8)
9D0042DC  00021040   SLL V0, V0, 1
9D0042E0  03C21021   ADDU V0, S8, V0
9D0042E4  94420010   LHU V0, 16(V0)
9D0042E8  A7828198   SH V0, -32360(GP)
9D0042EC  A3C00004   SB ZERO, 4(S8)
9D0042F0  0B4010CF   J 0x9D00433C
9D0042F4  00000000   NOP
9D004330  93C20004   LBU V0, 4(S8)
9D004334  24420001   ADDIU V0, V0, 1
9D004338  A3C20004   SB V0, 4(S8)
9D00433C  93C30004   LBU V1, 4(S8)
9D004340  93C2022C   LBU V0, 556(S8)
9D004344  0062102B   SLTU V0, V1, V0
9D004348  1440FFEB   BNE V0, ZERO, 0x9D0042F8
9D00434C  00000000   NOP
9D0042F8  3C03BF88   LUI V1, -16504
9D0042FC  8C626060   LW V0, 24672(V1)
9D004300  24040001   ADDIU A0, ZERO, 1
9D004304  7C827BC4   INS V0, A0, 15, 1
9D004308  AC626060   SW V0, 24672(V1)
9D00430C  97828198   LHU V0, -32360(GP)
9D004310  00401821   ADDU V1, V0, ZERO
9D004314  3C02BF80   LUI V0, -16512
9D004318  AC437040   SW V1, 28736(V0)
9D00431C  3C02BF80   LUI V0, -16512
9D004320  8C427010   LW V0, 28688(V0)
9D004324  30428000   ANDI V0, V0, -32768
9D004328  1440FFFC   BNE V0, ZERO, 0x9D00431C
9D00432C  00000000   NOP
9D004370  97C20224   LHU V0, 548(S8)
9D004374  24420001   ADDIU V0, V0, 1
9D004378  A7C20224   SH V0, 548(S8)
9D0043BC  3C03BF88   LUI V1, -16504
9D0043C0  8C626060   LW V0, 24672(V1)
9D0043C4  24040001   ADDIU A0, ZERO, 1
9D0043C8  7C827384   INS V0, A0, 14, 1
9D0043CC  AC626060   SW V0, 24672(V1)
9D0043D0  03C0E821   ADDU SP, S8, ZERO
9D0043D4  8FBE021C   LW S8, 540(SP)
9D0043D8  8FB10218   LW S1, 536(SP)
9D0043DC  8FB00214   LW S0, 532(SP)
9D0043E0  27BD0220   ADDIU SP, SP, 544
9D0043E4  03E00008   JR RA
9D0043E8  00000000   NOP
9D0043EC  27BDFFD8   ADDIU SP, SP, -40
9D0043F0  AFBE0024   SW S8, 36(SP)
9D0043F4  AFB50020   SW S5, 32(SP)
9D0043F8  AFB4001C   SW S4, 28(SP)
9D0043FC  AFB30018   SW S3, 24(SP)
9D004400  AFB20014   SW S2, 20(SP)
9D004404  AFB10010   SW S1, 16(SP)
9D004408  AFB0000C   SW S0, 12(SP)
9D00440C  03A0F021   ADDU S8, SP, ZERO
9D004410  00A01821   ADDU V1, A1, ZERO
9D004414  AFC60030   SW A2, 48(S8)
9D004418  00E01021   ADDU V0, A3, ZERO
9D00441C  A7C40028   SH A0, 40(S8)
9D004420  A7C3002C   SH V1, 44(S8)
9D004424  A3C20034   SB V0, 52(S8)
9D004428  8FC20030   LW V0, 48(S8)
9D00442C  24500002   ADDIU S0, V0, 2
9D004430  96020000   LHU V0, 0(S0)
9D004434  A7C20000   SH V0, 0(S8)
9D004438  26100002   ADDIU S0, S0, 2
9D00443C  96020000   LHU V0, 0(S0)
9D004440  A7C20002   SH V0, 2(S8)
9D004444  26100002   ADDIU S0, S0, 2
9D004448  3C03BF88   LUI V1, -16504
9D00444C  8C626060   LW V0, 24672(V1)
9D004450  7C027384   INS V0, ZERO, 14, 1
9D004454  AC626060   SW V0, 24672(V1)
9D004458  00008821   ADDU S1, ZERO, ZERO
9D00445C  0B4011D0   J 0x9D004740
9D004460  00000000   NOP
9D004738  26220001   ADDIU V0, S1, 1
9D00473C  3051FFFF   ANDI S1, V0, -1
9D004740  97C20000   LHU V0, 0(S8)
9D004744  0222102B   SLTU V0, S1, V0
9D004748  1440FF46   BNE V0, ZERO, 0x9D004464
9D00474C  00000000   NOP
9D004464  0200A821   ADDU S5, S0, ZERO
9D004468  00009021   ADDU S2, ZERO, ZERO
9D00446C  0B4011CA   J 0x9D004728
9D004470  00000000   NOP
9D004720  26420001   ADDIU V0, S2, 1
9D004724  305200FF   ANDI S2, V0, 255
9D004728  93C20034   LBU V0, 52(S8)
9D00472C  0242102B   SLTU V0, S2, V0
9D004730  1440FF50   BNE V0, ZERO, 0x9D004474
9D004734  00000000   NOP
9D004474  02A08021   ADDU S0, S5, ZERO
9D004478  3C03BF88   LUI V1, -16504
9D00447C  8C626060   LW V0, 24672(V1)
9D004480  7C027BC4   INS V0, ZERO, 15, 1
9D004484  AC626060   SW V0, 24672(V1)
9D004488  3C02BF80   LUI V0, -16512
9D00448C  24030002   ADDIU V1, ZERO, 2
9D004490  AC437040   SW V1, 28736(V0)
9D004494  3C02BF80   LUI V0, -16512
9D004498  8C427010   LW V0, 28688(V0)
9D00449C  30428000   ANDI V0, V0, -32768
9D0044A0  1440FFFC   BNE V0, ZERO, 0x9D004494
9D0044A4  00000000   NOP
9D0044A8  3C03BF88   LUI V1, -16504
9D0044AC  8C626060   LW V0, 24672(V1)
9D0044B0  24040001   ADDIU A0, ZERO, 1
9D0044B4  7C827BC4   INS V0, A0, 15, 1
9D0044B8  AC626060   SW V0, 24672(V1)
9D0044BC  97C30028   LHU V1, 40(S8)
9D0044C0  00001021   ADDU V0, ZERO, ZERO
9D0044C4  00601021   ADDU V0, V1, ZERO
9D0044C8  7C423A00   EXT V0, V0, 8, 8
9D0044CC  304200FF   ANDI V0, V0, 255
9D0044D0  00401821   ADDU V1, V0, ZERO
9D0044D4  3C02BF80   LUI V0, -16512
9D0044D8  AC437040   SW V1, 28736(V0)
9D0044DC  3C02BF80   LUI V0, -16512
9D0044E0  8C427010   LW V0, 28688(V0)
9D0044E4  30428000   ANDI V0, V0, -32768
9D0044E8  1440FFFC   BNE V0, ZERO, 0x9D0044DC
9D0044EC  00000000   NOP
9D0044F0  3C03BF88   LUI V1, -16504
9D0044F4  8C626060   LW V0, 24672(V1)
9D0044F8  7C027BC4   INS V0, ZERO, 15, 1
9D0044FC  AC626060   SW V0, 24672(V1)
9D004500  3C02BF80   LUI V0, -16512
9D004504  24030003   ADDIU V1, ZERO, 3
9D004508  AC437040   SW V1, 28736(V0)
9D00450C  3C02BF80   LUI V0, -16512
9D004510  8C427010   LW V0, 28688(V0)
9D004514  30428000   ANDI V0, V0, -32768
9D004518  1440FFFC   BNE V0, ZERO, 0x9D00450C
9D00451C  00000000   NOP
9D004520  3C03BF88   LUI V1, -16504
9D004524  8C626060   LW V0, 24672(V1)
9D004528  24040001   ADDIU A0, ZERO, 1
9D00452C  7C827BC4   INS V0, A0, 15, 1
9D004530  AC626060   SW V0, 24672(V1)
9D004534  97C30028   LHU V1, 40(S8)
9D004538  00001021   ADDU V0, ZERO, ZERO
9D00453C  00601021   ADDU V0, V1, ZERO
9D004540  304200FF   ANDI V0, V0, 255
9D004544  00401821   ADDU V1, V0, ZERO
9D004548  3C02BF80   LUI V0, -16512
9D00454C  AC437040   SW V1, 28736(V0)
9D004550  3C02BF80   LUI V0, -16512
9D004554  8C427010   LW V0, 28688(V0)
9D004558  30428000   ANDI V0, V0, -32768
9D00455C  1440FFFC   BNE V0, ZERO, 0x9D004550
9D004560  00000000   NOP
9D004564  3C03BF88   LUI V1, -16504
9D004568  8C626060   LW V0, 24672(V1)
9D00456C  7C027BC4   INS V0, ZERO, 15, 1
9D004570  AC626060   SW V0, 24672(V1)
9D004574  3C02BF80   LUI V0, -16512
9D004578  24030006   ADDIU V1, ZERO, 6
9D00457C  AC437040   SW V1, 28736(V0)
9D004580  3C02BF80   LUI V0, -16512
9D004584  8C427010   LW V0, 28688(V0)
9D004588  30428000   ANDI V0, V0, -32768
9D00458C  1440FFFC   BNE V0, ZERO, 0x9D004580
9D004590  00000000   NOP
9D004594  3C03BF88   LUI V1, -16504
9D004598  8C626060   LW V0, 24672(V1)
9D00459C  24040001   ADDIU A0, ZERO, 1
9D0045A0  7C827BC4   INS V0, A0, 15, 1
9D0045A4  AC626060   SW V0, 24672(V1)
9D0045A8  97C3002C   LHU V1, 44(S8)
9D0045AC  00001021   ADDU V0, ZERO, ZERO
9D0045B0  00601021   ADDU V0, V1, ZERO
9D0045B4  7C423A00   EXT V0, V0, 8, 8
9D0045B8  304200FF   ANDI V0, V0, 255
9D0045BC  00401821   ADDU V1, V0, ZERO
9D0045C0  3C02BF80   LUI V0, -16512
9D0045C4  AC437040   SW V1, 28736(V0)
9D0045C8  3C02BF80   LUI V0, -16512
9D0045CC  8C427010   LW V0, 28688(V0)
9D0045D0  30428000   ANDI V0, V0, -32768
9D0045D4  1440FFFC   BNE V0, ZERO, 0x9D0045C8
9D0045D8  00000000   NOP
9D0045DC  3C03BF88   LUI V1, -16504
9D0045E0  8C626060   LW V0, 24672(V1)
9D0045E4  7C027BC4   INS V0, ZERO, 15, 1
9D0045E8  AC626060   SW V0, 24672(V1)
9D0045EC  3C02BF80   LUI V0, -16512
9D0045F0  24030007   ADDIU V1, ZERO, 7
9D0045F4  AC437040   SW V1, 28736(V0)
9D0045F8  3C02BF80   LUI V0, -16512
9D0045FC  8C427010   LW V0, 28688(V0)
9D004600  30428000   ANDI V0, V0, -32768
9D004604  1440FFFC   BNE V0, ZERO, 0x9D0045F8
9D004608  00000000   NOP
9D00460C  3C03BF88   LUI V1, -16504
9D004610  8C626060   LW V0, 24672(V1)
9D004614  24040001   ADDIU A0, ZERO, 1
9D004618  7C827BC4   INS V0, A0, 15, 1
9D00461C  AC626060   SW V0, 24672(V1)
9D004620  97C3002C   LHU V1, 44(S8)
9D004624  00001021   ADDU V0, ZERO, ZERO
9D004628  00601021   ADDU V0, V1, ZERO
9D00462C  304200FF   ANDI V0, V0, 255
9D004630  00401821   ADDU V1, V0, ZERO
9D004634  3C02BF80   LUI V0, -16512
9D004638  AC437040   SW V1, 28736(V0)
9D00463C  3C02BF80   LUI V0, -16512
9D004640  8C427010   LW V0, 28688(V0)
9D004644  30428000   ANDI V0, V0, -32768
9D004648  1440FFFC   BNE V0, ZERO, 0x9D00463C
9D00464C  00000000   NOP
9D004650  3C03BF88   LUI V1, -16504
9D004654  8C626060   LW V0, 24672(V1)
9D004658  7C027BC4   INS V0, ZERO, 15, 1
9D00465C  AC626060   SW V0, 24672(V1)
9D004660  3C02BF80   LUI V0, -16512
9D004664  24030022   ADDIU V1, ZERO, 34
9D004668  AC437040   SW V1, 28736(V0)
9D00466C  3C02BF80   LUI V0, -16512
9D004670  8C427010   LW V0, 28688(V0)
9D004674  30428000   ANDI V0, V0, -32768
9D004678  1440FFFC   BNE V0, ZERO, 0x9D00466C
9D00467C  00000000   NOP
9D004680  00009821   ADDU S3, ZERO, ZERO
9D004684  0B4011C1   J 0x9D004704
9D004688  00000000   NOP
9D0046FC  26620001   ADDIU V0, S3, 1
9D004700  3053FFFF   ANDI S3, V0, -1
9D004704  97C20002   LHU V0, 2(S8)
9D004708  0262102B   SLTU V0, S3, V0
9D00470C  1440FFDF   BNE V0, ZERO, 0x9D00468C
9D004710  00000000   NOP
9D00468C  96020000   LHU V0, 0(S0)
9D004690  A7C20004   SH V0, 4(S8)
9D004694  26100002   ADDIU S0, S0, 2
9D004698  97C20004   LHU V0, 4(S8)
9D00469C  A7828198   SH V0, -32360(GP)
9D0046A0  0000A021   ADDU S4, ZERO, ZERO
9D0046A4  0B4011BB   J 0x9D0046EC
9D0046A8  00000000   NOP
9D0046E4  26820001   ADDIU V0, S4, 1
9D0046E8  305400FF   ANDI S4, V0, 255
9D0046EC  93C20034   LBU V0, 52(S8)
9D0046F0  0282102B   SLTU V0, S4, V0
9D0046F4  1440FFED   BNE V0, ZERO, 0x9D0046AC
9D0046F8  00000000   NOP
9D0046AC  3C03BF88   LUI V1, -16504
9D0046B0  8C626060   LW V0, 24672(V1)
9D0046B4  24040001   ADDIU A0, ZERO, 1
9D0046B8  7C827BC4   INS V0, A0, 15, 1
9D0046BC  AC626060   SW V0, 24672(V1)
9D0046C0  97828198   LHU V0, -32360(GP)
9D0046C4  00401821   ADDU V1, V0, ZERO
9D0046C8  3C02BF80   LUI V0, -16512
9D0046CC  AC437040   SW V1, 28736(V0)
9D0046D0  3C02BF80   LUI V0, -16512
9D0046D4  8C427010   LW V0, 28688(V0)
9D0046D8  30428000   ANDI V0, V0, -32768
9D0046DC  1440FFFC   BNE V0, ZERO, 0x9D0046D0
9D0046E0  00000000   NOP
9D004714  97C2002C   LHU V0, 44(S8)
9D004718  24420001   ADDIU V0, V0, 1
9D00471C  A7C2002C   SH V0, 44(S8)
9D004750  3C03BF88   LUI V1, -16504
9D004754  8C626060   LW V0, 24672(V1)
9D004758  24040001   ADDIU A0, ZERO, 1
9D00475C  7C827384   INS V0, A0, 14, 1
9D004760  AC626060   SW V0, 24672(V1)
9D004764  03C0E821   ADDU SP, S8, ZERO
9D004768  8FBE0024   LW S8, 36(SP)
9D00476C  8FB50020   LW S5, 32(SP)
9D004770  8FB4001C   LW S4, 28(SP)
9D004774  8FB30018   LW S3, 24(SP)
9D004778  8FB20014   LW S2, 20(SP)
9D00477C  8FB10010   LW S1, 16(SP)
9D004780  8FB0000C   LW S0, 12(SP)
9D004784  27BD0028   ADDIU SP, SP, 40
9D004788  03E00008   JR RA
9D00478C  00000000   NOP
